<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一次Frp引发的VPS的相关配置</title>
      <link href="//Other/VpsAndNasAboutConfig/"/>
      <url>//Other/VpsAndNasAboutConfig/</url>
      
        <content type="html"><![CDATA[<h1 id="一次Frp引发的VPS的相关配置"><a href="#一次Frp引发的VPS的相关配置" class="headerlink" title="一次Frp引发的VPS的相关配置"></a>一次Frp引发的VPS的相关配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先说明，这个文档，不涉及到具体的安装步骤，仅仅只是粗略的配置，以及 如何设置开机自启动。本文档的目的，是为了在后续vps迁移时，有一个可以参考的步骤。</p><p>另外，当前文档中，大部分附件，都设置密码，仅供本人使用。</p><p>前一阵时间，买了一个Nas服务器，但是呢，买完就后悔了。为什么呢？因为我的家里没有公网IP。哎。。想到<code>Qnap</code>提供的远程登录和文件传输，指的是想象就吐了。为此，在网上找了一堆<code>内网穿透</code> 的方案，最终还是决定使用<code>Frp</code>。为什么呢？</p><ol><li>网上文档比较多</li><li>简单</li></ol><p>真的，简单成为了我选择这个的最重要的方式。</p><p>废话不多说，直接上步骤吧。</p><h2 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h2><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="https://shengouqiang.cn/nas/frp.zip?_blank">Frp文件</a></p><h3 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h3><h4 id="文件位置"><a href="#文件位置" class="headerlink" title="文件位置"></a>文件位置</h4><p><code>/lib/systemd/system/frps.service</code></p><h4 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h4><pre><code class="shell">[Unit]Description=frpsAfter=network.target[Service]TimeoutStartSec=30ExecStart=/root/frp/frps -c /root/frp/frps.iniExecStop=/bin/kill $MAINPID[Install]WantedBy=multi-user.target</code></pre><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><pre><code class="shell">systemctl enable frpssystemctl start frpssystemctl status frpssystemctl stop frps</code></pre><h2 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h2><h3 id="附件-1"><a href="#附件-1" class="headerlink" title="附件"></a>附件</h3><p><a href="https://shengouqiang.cn/nas/bbr.sh?_blank" target="_blank">BBR文件</a></p><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h3 id="附件-2"><a href="#附件-2" class="headerlink" title="附件"></a>附件</h3><p><a href="https://shengouqiang.cn/nas/nginx.zip?_blank">Nginx文件</a></p><h3 id="前置配置"><a href="#前置配置" class="headerlink" title="前置配置"></a>前置配置</h3><pre><code class="shell">yum install -y openssl openssl-devel  pcre pcre-devel zlib zlib-devel gcc gcc-c++ kernel-headers kernel-devel gcc make -y</code></pre><h3 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h3><h4 id="文件位置-1"><a href="#文件位置-1" class="headerlink" title="文件位置"></a>文件位置</h4><p><code>/lib/systemd/system/nginx.service</code></p><h4 id="文件内容-1"><a href="#文件内容-1" class="headerlink" title="文件内容"></a>文件内容</h4><pre><code class="shell">[Unit]Description = nginxAfter = network.target[Service]Type = forkingExecStart = /root/nginx/nginx/sbin/nginx -c /root/nginx/nginx/conf/nginx_443.confExecReload = /root/nginx/nginx/sbin/nginx -c /root/nginx/nginx/conf/nginx_443.conf -s reloadExecStop = /root/nginx/nginx/sbin/nginx -c /root/nginx/nginx/conf/nginx_443.conf -s stopPrivateTmp = true[Install]WantedBy = multi-user.target</code></pre><h4 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h4><pre><code class="shell">systemctl enable nginxsystemctl start nginxsystemctl status nginxsystemctl stop nginx</code></pre><h2 id="Jrebel"><a href="#Jrebel" class="headerlink" title="Jrebel"></a>Jrebel</h2><h3 id="附件-3"><a href="#附件-3" class="headerlink" title="附件"></a>附件</h3><p><a href="https://shengouqiang.cn/nas/jdk8.zip.001?_blank">JDK文件-第一部分</a></p><p><a href="https://shengouqiang.cn/nas/jdk8.zip.002?_blank">JDK文件-第二部分</a></p><p><a href="https://shengouqiang.cn/nas/Jrebel.zip?_blank">Jrebel文件</a></p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h4 id="文件位置-2"><a href="#文件位置-2" class="headerlink" title="文件位置"></a>文件位置</h4><p><code>/etc/profile</code></p><h4 id="追加内容"><a href="#追加内容" class="headerlink" title="追加内容"></a>追加内容</h4><pre><code class="shell">JAVA_HOME=/root/jdkJRE_HOME=$JAVA_HOME/jreCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin#PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:</code></pre><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><h4 id="java程序自启动"><a href="#java程序自启动" class="headerlink" title="java程序自启动"></a>java程序自启动</h4><h5 id="文件位置-3"><a href="#文件位置-3" class="headerlink" title="文件位置"></a>文件位置</h5><p><code>/etc/rc.d/rc.local</code></p><h5 id="文件内容-2"><a href="#文件内容-2" class="headerlink" title="文件内容"></a>文件内容</h5><pre><code class="shell">/root/jdk/bin/java -jar /root/Jrebel/boot.jar -p 8081 &amp; &gt; /root/Jrebel/default.log 2&gt;&amp;1</code></pre><h4 id="nginx程序自动启"><a href="#nginx程序自动启" class="headerlink" title="nginx程序自动启"></a>nginx程序自动启</h4><h5 id="前置命令"><a href="#前置命令" class="headerlink" title="前置命令"></a>前置命令</h5><pre><code class="shell">cp nginx_jrebel.conf ~/nginx/nginx/conf/</code></pre><h5 id="文件位置-4"><a href="#文件位置-4" class="headerlink" title="文件位置"></a>文件位置</h5><p><code>/lib/systemd/system/nginx_jrebel.service</code></p><h5 id="文件内容-3"><a href="#文件内容-3" class="headerlink" title="文件内容"></a>文件内容</h5><pre><code class="shell">[Unit]Description = nginxAfter = network.target[Service]Type = forkingExecStart = /root/nginx/nginx/sbin/nginx -c /root/nginx/nginx/conf/nginx_jrebel.confExecReload = /root/nginx/nginx/sbin/nginx -c /root/nginx/nginx/conf/nginx_jrebel.conf -s reloadExecStop = /root/nginx/nginx/sbin/nginx -c /root/nginx/nginx/conf/nginx_jrebel.conf -s stopPrivateTmp = true[Install]WantedBy = multi-user.target</code></pre><h5 id="相关命令-2"><a href="#相关命令-2" class="headerlink" title="相关命令"></a>相关命令</h5><pre><code class="shell">systemctl enable nginx_jrebelsystemctl start nginx_jrebelsystemctl status nginx_jrebelsystemctl stop nginx_jrebel</code></pre><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><h3 id="前置命令-1"><a href="#前置命令-1" class="headerlink" title="前置命令"></a>前置命令</h3><pre><code class="shell">yum -y install dockersystemctl start dockersystemctl status docker</code></pre><h3 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h3><p><font style="color:red;">注意，要改变Root密码</font></p><pre><code class="shell">docker search mysqldocker pull mysql:5.7docker run  --restart always --name mysql5.7.19 -p 3306:3306 -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d  -e MYSQL_ROOT_PASSWORD=??&gt;&gt;&lt;&lt;??__++ -d mysql:5.7.19docker exec -i -t  mysql5.7.19 /bin/bashmysql -uroot -p</code></pre><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.jianshu.com/p/185840de08a8">用docker部署mysql服务</a></p><h2 id="Aria"><a href="#Aria" class="headerlink" title="Aria"></a>Aria</h2><h3 id="AriaNg"><a href="#AriaNg" class="headerlink" title="AriaNg"></a>AriaNg</h3><h4 id="附件-4"><a href="#附件-4" class="headerlink" title="附件"></a>附件</h4><p><a href="https://shengouqiang.cn/nas/aria.zip?_blank">AriaNg文件</a></p><h3 id="Aria-Pro"><a href="#Aria-Pro" class="headerlink" title="Aria Pro"></a>Aria Pro</h3><h4 id="前置命令-2"><a href="#前置命令-2" class="headerlink" title="前置命令"></a>前置命令</h4><pre><code class="shell">yum -y install docker</code></pre><h4 id="安装命令-1"><a href="#安装命令-1" class="headerlink" title="安装命令"></a>安装命令</h4><pre><code class="shell">docker run -d --restart unless-stopped --log-opt max-size=1m --network host -e PUID=$UID -e PGID=$GID -v /mnt/disk/aria2-config:/config -v /mnt/disk/aria2-downloads:/downloads  p3terx/aria2-pro</code></pre><h4 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://p3terx.com/archives/docker-aria2-pro.html">Aria2 Pro</a> </p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> Frps </tag>
            
            <tag> Nginx </tag>
            
            <tag> BBR </tag>
            
            <tag> Jrebel </tag>
            
            <tag> MySql </tag>
            
            <tag> Aria </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP之三次握手、四次挥手</title>
      <link href="//NetWork/NetWorkLearnDay01/"/>
      <url>//NetWork/NetWorkLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP之三次握手、四次挥手"><a href="#TCP之三次握手、四次挥手" class="headerlink" title="TCP之三次握手、四次挥手"></a>TCP之三次握手、四次挥手</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为对于<code>TCP</code>而言，是默认的全双工协议，因此可以是客户端向服务器端发起连接，也可以是服务端向客户端发起连接。在这里，我们以客户端向服务端发起连接请求。</p><h2 id="大体过程"><a href="#大体过程" class="headerlink" title="大体过程"></a>大体过程</h2><p><img src="https://shengouqiang.cn/img/NetWork/Day01/TCP_01.png" alt="TCP协议流程图"></p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>下面，我们分别介绍下一些专有名词：</p><ol><li><code>SYN</code>：发起一个新的连接</li><li><code>ACK</code>：代表确认序列号生效</li><li><code>SEQ</code>：序列号：代表的是从源端到目标端的序列号</li><li><code>ACK</code>：确认序列号，一般为接收到的<code>SEQ +1</code>，并且只有在<code>ACK</code>的<code>Flag</code>位为<code>1</code>的时候生效</li><li><code>FIN</code>：释放一个连接</li><li><code>MSL</code>： 最大报文生成时间</li></ol><h3 id="三次握手流程"><a href="#三次握手流程" class="headerlink" title="三次握手流程"></a>三次握手流程</h3><ol><li>当<code>server</code>端 开放了某个端口后，此时 会从<code>CLOSED</code> 阶段 进入到<code>LISTEN</code> 接口</li><li>当<code>client</code>想要连接<code>server</code>的时候，此时会从 发送一个 <code>SYN</code> 报文，同时从<code>CLOSED</code> 阶段进入到<code>SYN-SENT</code>阶段。</li><li>当<code>server</code>收到了来自<code>client</code>的<code>SYN</code>后，此时会从 <code>LISTEN</code> 阶段 转到 <code>SYN-RCVD</code> 接口，同时通知<code>client</code>的<code>ACK</code>和<code>SYN</code></li><li>当<code>client</code>接收到<code>server</code>的确认和请求连接后，发送<code>ACK</code>告知<code>server</code>端，同时 <code>client</code> 端从<code>SYN-SENT</code> 阶段 进入到<code>ESTABLISHED</code> 阶段</li><li>当<code>server</code>收到了<code>client</code>的确认后，也从 <code>SYN-RCVD</code> 阶段 进入到 <code>ESTABLISHED</code> 阶段</li></ol><h4 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h4><ol><li>保证服务器资源的防止浪费的情况，如果是两次握手，就会出现当网络阻塞，客户端没有在一定的时间内收到服务端的请求，此时客户端会重新启动一个新的连接，此时客户端又会启动一个新的端口连接对应。此时就会出现服务器端资源浪费的情况</li><li>因为有<code>SEQ</code>的版本控制问题，当有一个请求包在网络阻塞很久之后，到达<code>server</code>端，<code>server</code>端可以根据<code>SEQ</code>判断当前的包是否是有效的数据包</li></ol><h4 id="为什么不是四次握手？"><a href="#为什么不是四次握手？" class="headerlink" title="为什么不是四次握手？"></a>为什么不是四次握手？</h4><p>没有必要，因为三次已经能够保证全双工了</p><h3 id="四次挥手流程"><a href="#四次挥手流程" class="headerlink" title="四次挥手流程"></a>四次挥手流程</h3><ol><li>当<code>client</code>准备关闭与<code>server</code>的连接时，此时会发送一个报文通知<code>server</code>端，同时客户端会从 <code>ESTABLISHED</code> 状态进入到 <code>FIN-WAIT-1</code> 状态，此时客户端处于半关闭状态，已经无法通过<code>client</code>向<code>server</code>发送数据包，但是允许接收<code>server</code>到<code>client</code>的数据包。这里要注意一点，这里<code>client</code>不能向<code>server</code>发送的仅仅是数据包，不代表不能发送确认包。</li><li>当<code>server</code>端收到了<code>client</code>端想要断开连接的请求后，此时<code>server</code>会从 <code>ESTABLISHED</code> 状态进入到<code>CLOSE-WAIT</code>状态。此时客户端也进入了一个半关闭的状态。</li><li>当执行完第2步骤后，此时<code>client</code>端接收到了<code>server</code>的确认，则可以正式的关闭了从<code>client</code>端到<code>server</code>端的连接。并且进入到 <code>FIN-WAIT-2</code> 阶段。</li><li>当<code>server</code>端经历过 <code>CLOSE_WAIT</code> 阶段后，并且做好了与客户端断开连接的准备后，此时<code>server</code>端会向<code>client</code>发送关闭从<code>server</code>端到<code>client</code>端的连接的请求，并且自动进入到 <code>LAST-ACK</code> 阶段。在这个阶段，<code>server</code>端不在向<code>client</code>端发送任何数据，但是允许接收从<code>client</code>发送过来的确认包。</li><li>当<code>client</code>端收到了<code>server</code>端的主动关闭请求后，此时会从<code>FIN-WAIT-2</code>阶段到 <code>TIME-WAITED</code> 阶段。并且告知<code>server</code>端已收到关闭请求通知。</li><li>当<code>server</code>端接收到回应后，此时会停止 <code>CLOSE-WAIT</code> 阶段，进入 <code>CLOSED</code> 阶段。在这个时候，已经正式的确认了从 <code>server</code> 到 <code>client</code>端的连接的关闭。</li><li>当客户端发送了<code>server</code>端关闭请求的回应后，等到<code>2MSL</code>，自动进入<code>CLOSED</code> 阶段，在这个时候，已经正式的确认了从<code>client</code>到 <code>server</code>端的连接的关闭。</li></ol><h4 id="为什么客户端的TIME-WAIT需要2MSL？"><a href="#为什么客户端的TIME-WAIT需要2MSL？" class="headerlink" title="为什么客户端的TIME_WAIT需要2MSL？"></a>为什么客户端的<code>TIME_WAIT</code>需要<code>2MSL</code>？</h4><p>为了保证<code>server</code>端能够最大安全的关闭：</p><ol><li>如果<code>client</code>在<code>2MSL</code>时间内，再次收到了来自<code>server</code>的<code>FIN</code>报文，说明<code>server</code>由于各种原因没有接收到<code>client</code>发出的<code>ACK</code>确认报文。<code>client</code>再次向<code>server</code>发出<code>ACK</code>确认报文，计时器重置，重新开始<code>2MSL</code>的计时</li><li><code>client</code>在<code>2MSL</code>内没有再次收到来自<code>server</code>的<code>FIN</code>报文，说明<code>server</code>正常接收了<code>ACK</code>确认报文，<code>client</code>可以进入<code>CLOSED</code>阶段</li></ol><h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><code>client</code>伪造大量的<code>虚拟IP</code>，并向<code>server</code>端发送<code>SYN</code>包</li><li><code>server</code>端收到后，发送 <code>ACK +SYN</code>包给<code>虚拟IP</code></li><li>因为<code>虚拟IP</code>不存在，所以不会回应<code>server</code>端的 <code>ACK+SYN</code></li><li>当<code>server</code>端收不到确认后，此时会认为是确认包丢失，此时会不断重发，直到超时</li></ol><p>因为这些虚拟的<code>SYN</code>包会长期占用未连接队列，就会导致真实的<code>client</code>端请求无法加入到队列中，从而被丢弃，最终造成网络拥堵和瘫痪。</p><p>在<code>Linux</code>系统中，我们可以采用<code>netstat -nap | grep SYN_RECV</code>命令进行查看</p><h2 id="系统存在大量的TIME-WAIT"><a href="#系统存在大量的TIME-WAIT" class="headerlink" title="系统存在大量的TIME_WAIT:"></a>系统存在大量的<code>TIME_WAIT</code>:</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li>系统中存在非常频繁的 <code>TCP</code>连接打开-关闭的进程</li><li>网络状态不太好，<code>server</code>端总是在<code>2MSL</code>的时间内，重新发送 <code>FIN</code> 关闭请求，导致 <code>client</code>端总是在重置<code>2MSL</code></li></ol><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ol><li>消耗系统的连接数</li><li>过多的消耗内存，平均一个 <code>TIME-WAIT</code>要占用<code>4K</code>大小的内存</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code class="shell">1.vi /etc/sysctl.conf#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_syncookies = 1    #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1       #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1    #修改系統默认的 TIMEOUT 时间。net.ipv4.tcp_fin_timeout        #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。net.ipv4.tcp_keepalive_time = 1200   #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）net.ipv4.ip_local_port_range = 10000 65000   #表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。net.ipv4.tcp_max_syn_backlog = 8192#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默 认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT的最大数量，避免Squid服务器被大量的TIME_WAIT拖死net.ipv4.tcp_max_tw_buckets = 50002./sbin/sysctl -p</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自编写Shell脚本-删除Maven无效的文件</title>
      <link href="//Shell/BatchDeleteUnusedMavenFile/"/>
      <url>//Shell/BatchDeleteUnusedMavenFile/</url>
      
        <content type="html"><![CDATA[<h1 id="自编写Shell脚本-删除Maven无效的文件"><a href="#自编写Shell脚本-删除Maven无效的文件" class="headerlink" title="自编写Shell脚本-删除Maven无效的文件"></a>自编写Shell脚本-删除Maven无效的文件</h1><p>这几天家里的网有问题，总是在<code>maven</code>下载<code>jar</code>包的时候断开，然后就在本地<code>maven</code>的<code>localRepository</code>中生成了<code>&quot;*.lastUpdated&quot;</code>和<code>&quot;_remote.repositories&quot;</code>等文件，导致当网络恢复的时候就下载不下来了。为了能下载，只能一个一个的删除。但是这种删除方式过于的麻烦。所以写了一个脚本放在这里，如果脚本本身有问题，烦请各位大佬批评指正。</p><p>对于这两个文件的含义，网上一搜一大堆，在这里不在过多的阐述。下面不废话，直接上代码：</p><pre><code class="shell">#bin/bash# author：BiggerShen# date：2020年08月12日 23:51:15# 下面的maven_localRepository_Path和should_be_deleted_file_array是唯一要改动的地方# 其中，maven_localRepository_Path 代表的是你的maven的localRepository的Path路径，可以使用绝对路径，也可以采用相对路径whoami，路径中可以存在&quot;.&quot;,例如路径是&quot;/Users/$(whoami)/.m2/repository&quot;# 也可以是下面demo中的普通路径# 另外，当前脚本支持一次删除多种类型的文件，对于要删除的文件，只需要下载在 should_be_deleted_file_array 数组中即可，一行代表一种类型，在这里可以指定明确的文件名称，也可以采用通配符的方式，# 详情请见下面的demomaven_localRepository_Path=&quot;/Users/$(whoami)/maven/localRepository&quot;should_be_deleted_file_array=(&quot;*.lastUpdated&quot;&quot;_remote.repositories&quot;)# 下面的代码是删除逻辑执行代码，如无必要，请尽量不要改动，若因私自改动造成文件的误删和破坏，本人不承担任何责任。echo &quot;Maven 的 LocalRepository Path 是---&gt;\033[36m $maven_localRepository_Path \033[0m&quot;for single_file_name in $&#123;should_be_deleted_file_array[@]&#125;do    tempCount=`(find $maven_localRepository_Path  -name $single_file_name  | wc -l)`    echo -e &quot;当前操作的对象文件名为：\033[36m $single_file_name \033[0m, 个数为：\033[31m $tempCount \033[0m&quot;    find $maven_localRepository_Path  -name $single_file_name  | xargs rm -rf    echo &quot;文件：\033[36m $single_file_name \033[0m 删除成功&quot;done</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Shell脚本 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构--字典</title>
      <link href="//Redis/RedisDictht/"/>
      <url>//Redis/RedisDictht/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据结构–字典"><a href="#Redis数据结构–字典" class="headerlink" title="Redis数据结构–字典"></a>Redis数据结构–字典</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>字典，又称为符号表（<code>symbol table</code>）、关联数组（<code>associative array</code>）或映射（<code>map</code>），是一种用于保存键值对（<code>key-value pair</code>）的抽象数据结构。</p><p>字典在<code>Redis</code>中的应用相当广泛，比如<code>Redis</code>的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，<code>Redis</code>就会使用字典作为哈希键的底层实现。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>Redis</code>的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><pre><code class="c">typedef struct dictht &#123;      // 哈希表数组      dictEntry **table;      // 哈希表大小      unsigned long size;      //哈希表大小掩码，用于计算索引值      //总是等于size-1      unsigned long sizemask;      // 该哈希表已有节点的数量      unsigned long used; &#125; dictht;</code></pre><p><code>table</code>属性是一个数组，数组中的每个元素都是一个指向<code>dict.h/dictEntry</code>结构的指针，每个<code>dictEntry</code>结构保存着一个键值对。<code>size</code>属性记录了哈希表的大小，也即是<code>table</code>数组的大小，而<code>used</code>属性则记录了哈希表目前已有节点（键值对）的数量。<code>sizemask</code>属性的值总是等于<code>size-1</code>，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</p><h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用<code>dictEntry</code>结构表示，每个<code>dictEntry</code>结构都保存着一个键值对：</p><pre><code class="c">typedef struct dictEntry &#123;  // 键      void *key;      // 值      union&#123;            void *val;            uint64_tu64;            int64_ts64;      &#125; v;      // 指向下个哈希表节点，形成链表      struct dictEntry *next;&#125; dictEntry;</code></pre><p><code>key</code>属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个<code>uint64_t</code>整数，又或者是一个<code>int64_t</code>整数。</p><p><code>next</code>属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突<code>（colli-sion）</code>的问题。</p><p>接下来， 我们通过图片的方式，展示哈希表的结构：</p><p><img src="https://shengouqiang.cn/img/Redis/Redis_Dict/Redis_dictht_struct.jpg" alt="哈希表存储结构"></p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>首先，我们看下字典的数据结构</p><pre><code class="c">typedef struct dict &#123;      // 类型特定函数      dictType *type;      // 私有数据      void *privdata;      // 哈希表      dictht ht[2];      // rehash索引      //当rehash不在进行时，值为-1      int rehashidx; &#125; dict;</code></pre><p><code>type</code>属性和<code>privdata</code>属性是针对不同类型的键值对，为创建多态字典而设置的：</p><ul><li><code>type</code>属性是一个指向<code>dictType</code>结构的指针，每个<code>dictType</code>结构保存了一簇用于操作特定类型键值对的函数，<code>Redis</code>会为用途不同的字典设置不同的类型特定函数。<ul><li>而<code>privdata</code>属性则保存了需要传给那些类型特定函数的可选参数。</li></ul></li></ul><pre><code class="c">typedef struct dictType &#123;      // 计算哈希值的函数      unsigned int (*hashFunction)(const void *key);      // 复制键的函数      void *(*keyDup)(void *privdata, const void *key);      // 复制值的函数      void *(*valDup)(void *privdata, const void *obj);      // 对比键的函数      int (*keyCompare)(void *privdata, const void *key1, const void *key2);      // 销毁键的函数      void (*keyDestructor)(void *privdata, void *key);      // 销毁值的函数      void (*valDestructor)(void *privdata, void *obj);&#125; dictType;</code></pre><p><code>ht</code>属性是一个包含两个项的数组，数组中的每个项都是一个<code>dictht</code>哈希表，一般情况下，字典只使用<code>ht[0]</code>哈希表，<code>ht[1]</code>哈希表只会在对<code>ht[0]</code>哈希表进行<code>rehash</code>时使用。</p><p>除了<code>ht[1]</code>之外，另一个和<code>rehash</code>有关的属性就是<code>rehashidx</code>，它记录了<code>rehash</code>目前的进度，如果目前没有在进行<code>rehash</code>，那么它的值为<code>-1</code>。</p><p>接下来， 我们通过图片的方式，展示字典的结构：</p><p><img src="https://shengouqiang.cn/img/Redis/Redis_Dict/Redis_dict_struct.jpg" alt="字典存储结构"></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="hash算法-amp-解决冲突"><a href="#hash算法-amp-解决冲突" class="headerlink" title="hash算法 &amp; 解决冲突"></a>hash算法 &amp; 解决冲突</h3><p>对于整个<code>Redis</code>的算法很简单，大致流程如下：</p><ol><li>根据<code>key</code>来确定<code>hash</code></li><li>根据<code>rehashidx</code>确定使用 <code>ht[0]</code> 还是<code>ht[1]</code></li><li>根据 <code>hash &amp; sizemask</code> 来确定最终的数组下标位置</li><li>将节点添加到数据，如果当前节点有值，则添加到链表上，采用的是<code>链地址法</code>，并且采用的是<code>头插法</code>。</li></ol><p>基于上面的内容，我们可以发现一个现象，哈希表的<code>length</code>大小始终为2<sup>n</sup>。至于<code>redis</code>是如果通过<code>key</code>来获取<code>hash</code>的，则是通过<code>MurmurHash2</code>算法实现的。</p><h3 id="rehash-amp-渐进式rehash"><a href="#rehash-amp-渐进式rehash" class="headerlink" title="rehash &amp; 渐进式rehash"></a>rehash &amp; 渐进式rehash</h3><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子<code>（load factor）</code>维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。</p><p>扩展和收缩哈希表的工作可以通过执行<code>rehash</code>（重新散列）操作来完成，<code>Redis</code>对字典的哈希表执行<code>rehash</code>的步骤如下：</p><ol><li>为字典的<code>ht[1]</code>哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是<code>ht[0].used</code>属性的值）<ul><li>如果执行的是扩展操作，那么<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used*2</code>的2<sup>n</sup></li><li>如果执行的是收缩操作，那么<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used</code>的2<sup>n</sup></li></ul></li><li>将保存在<code>ht[0</code>]中的所有键值对<code>rehash</code>到<code>ht[1]</code>上面：<code>rehash</code>指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上</li><li>当<code>ht[0]</code>包含的所有键值对都迁移到了<code>ht[1]</code>之后（<code>ht[0</code>]变为空表），释放<code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次<code>rehash</code>做准备</li></ol><hr><h4 id="负载因子的计算"><a href="#负载因子的计算" class="headerlink" title="负载因子的计算"></a>负载因子的计算</h4><p><span style="color:red">负载因子= 哈希表已保存节点数量/ 哈希表大小</span></p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p><ul><li>服务器目前没有在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子大于等于<code>1</code></li><li>服务器目前正在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子大于等于<code>5</code></li></ul><p>根据<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行<code>BGSAVE</code>命令或<code>BGREWRITEAOF</code>命令的过程中，<code>Redis</code>需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制<code>（copy-on-write）</code>技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p><p>另一方面，当哈希表的负载因子小于<code>0.1</code>时，程序自动开始对哈希表执行收缩操作。</p><hr><p>但是对于<code>rehash</code>而言，如果我们的哈希表中存放的数据特别的多，此时就会造成阻塞<code>client</code>的现象，也就造成了服务不可用的问题，为了解决这个问题，从而衍伸出了<code>渐进式rehash</code>。</p><p><code>渐进式rehash</code>，服务器不是一次性将<code>ht[0]</code>里面的所有键值对全部<code>rehash</code>到<code>ht[1]</code>，而是分多次、渐进式地将<code>ht[0]</code>里面的键值对慢慢地<code>rehash</code>到<code>ht[1]</code>。</p><p>以下是哈希表渐进式<code>rehash</code>的详细步骤：</p><ol><li>为<code>ht[1]</code>分配空间，让字典同时持有<code>ht[0]</code>和<code>ht[1]</code>两个哈希表</li><li>在字典中维持一个索引计数器变量<code>rehashidx</code>，并将它的值设置为<code>0</code>，表示<code>rehash</code>工作正式开始。</li><li>在<code>rehash</code>进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将<code>ht[0</code>]哈希表在<code>rehashidx</code>索引上的所有键值对<code>rehash</code>到<code>ht[1]</code>，当<code>rehash</code>工作完成之后，程序将<code>rehashidx</code>属性的值增一。</li><li>随着字典操作的不断执行，最终在某个时间点上，<code>ht[0]</code>的所有键值对都会被<code>rehash</code>至<code>ht[1]</code>，这时程序将<code>rehashidx</code>属性的值设为<code>-1</code>，表示<code>rehash</code>操作已完成。</li></ol><p>渐进式<code>rehash</code>的好处在于它采取分而治之的方式，将<code>rehash</code>键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式<code>rehash</code>而带来的庞大计算量。</p><p>因为在进行渐进式<code>rehash</code>的过程中，字典会同时使用<code>ht[0]</code>和<code>ht[1]</code>两个哈希表，所以在渐进式<code>rehash</code>进行期间，字典的删除（<code>delete</code>）、查找（<code>find</code>）、更新（<code>update</code>）等操作会在两个哈希表上进行。例如，要在字典里面查找一个键的话，程序会先在<code>ht[0]</code>里面进行查找，如果没找到的话，就会继续到<code>ht[1]</code>里面进行查找，诸如此类。</p><p>另外，在渐进式<code>rehash</code>执行期间，新添加到字典的键值对一律会被保存到<code>ht[1]</code>里面，而<code>ht[0]</code>则不再进行任何添加操作，这一措施保证了<code>ht[0]</code>包含的键值对数量会只减不增，并随着<code>rehash</code>操作的执行而最终变成空表。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于<code>Redis</code>而言，字典和哈希表的数据结构是非常重要的。并且对于哈希表的<code>rehash</code>也是非常重要的。在这里，做一个总结。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的RDB与AOF</title>
      <link href="//Redis/RedisPersistence/"/>
      <url>//Redis/RedisPersistence/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的RDB与AOF"><a href="#Redis的RDB与AOF" class="headerlink" title="Redis的RDB与AOF"></a>Redis的RDB与AOF</h1><p> 对于<code>Redis</code>而言，它的数据都是存在内存当中的。如果我们想要将数据永久性的存下来，或者下次重启<code>Server</code>后，想要以前的数据依然在，那么我们就需要将内存中的数据持久化到硬盘中。而<code>Redis</code>对于这样的需求，为我们提供了两套服务，分别是<code>RDB</code>与<code>AOF</code>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 在讲解什么是<code>RDB</code>，什么是<code>AOF</code>之前，我们要先明白对于任何一个<code>内存型</code>的<code>DB</code>而言，如果我们想要持久化数据，我们应该怎么做？但是，本节主讲<code>Redis</code>。因此在这里，我们依然以<code>Redis</code>举例。</p><p> 假如我们有一个<code>Redis</code>，这个<code>Redis</code>运行了很久，在内存中产生了很多的数据。此时我们需要将这些内存中的数据持久化到硬盘上，供后续的其他操作使用。在这样的情况下，我们有两个操作：</p><ol><li>阻塞掉前端所有的<code>client</code>端的操作。然后将这些数据缓缓的写到磁盘当中。只有将全部的数据写入完毕之后，此时再放行<code>client</code>端的操作。</li><li>通过新启动一个子进程的方式，通过子进程的方式，将内存中的数据缓缓的写入到磁盘当中。<code>Redis</code>的工作线程依然处理客户端的请求。</li></ol><p> 这两种方式各自有各自的特点。接下来，我们开始一一讨论。</p><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p> 首先，我们要明确一点，对于整个系统而言，最大的瓶颈是<code>IO</code>操作，至于为什么是<code>IO</code>操作，详情可以参考<a href="https://www.baidu.com">百度</a>。那么如果采用的是当前的方式，就会出现如果当前内存的数据量特别大的时候，此时<code>Redis</code>将内存中的数据写入硬盘的时间就会特别的长，从而就会造成<code>Redis</code>长时间处于一种服务不可用的状态。对于这样的情况，虽然可以保证我们缓存到硬盘的内容是<code>100%</code>准确的，但是我想没有几个公司会同意这样的解决方案的。这也是为什么很多公司将<code>Redis</code>的<code>SAVE</code>命令给禁用的原因。</p><p> 这里说明下，<code>Redis</code>是支持第一种方案的。对应的的命令是<code>SAVE</code>。</p><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p> 既然第一种方式公司不让用，那么我们来看下第二种方案。对于第二种方案而言，你可能会想，这样的方式虽然保证了服务的可用性，但是如果我在缓存的过程中，如果我将对应的<code>key</code>的值给改了，或者将这个<code>Key</code>对应的值给删除了，怎么办？这样就会造成数据不一致的问题。如果想要数据一致的话，还是需要<code>STW</code>的，事实上真的是这样吗？我们做一个例子：</p><hr><h3 id="进程间资源隔离的例子"><a href="#进程间资源隔离的例子" class="headerlink" title="进程间资源隔离的例子"></a>进程间资源隔离的例子</h3><p>首先，我们新开一个<code>session</code>，然后执行<code>pstree</code>命令，如图所示：</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/Parent_PSTree_01.jpg" alt="父进程的PSTREE"></p><p>我们发现，目前我们处在<code>bash</code>下，执行的<code>pstree</code>命令。此时我们设定一个变量<code>b</code>，值为<code>10</code>。</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/Parent_Set_b_01.jpg" alt="父进程设值"></p><p>通过上图所示，我们已经在当前的<code>session</code>中，设置了一个变量<code>b</code>，值为<code>10</code>，并且已经能够成功的取出。</p><p>接下来，我们创建一个子进程，使用<code>/bin/bash</code>命令。然后我们再看一下<code>pstree</code>。</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/Child_PSTree_01.jpg" alt="子进程的PSTREE"></p><p>此时我们发现，和之前的<code>pstree</code>进行比较，我们目前是在<code>bash-&gt;bash</code>下执行的<code>pstree</code>。此时我们在获取之前创建的变量<code>b</code>.</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/Child_Get_b_01.jpg" alt="子进程取值"></p><p>此时我们发现，我们并没有得到<code>b</code>的值，这是为什么呢？</p><p>这是因为在<code>Linux</code>系统中，进行之间的资源是相互隔离的。如果我们想要让<code>b</code>在两个<code>session</code>之前共享，最简单的办法就是使用<code>export</code>命令，然后在子进程就能够获取的到了。</p><hr><p><code>OK</code>，通过上面的例子，我们知道了线程间的资源隔离问题。那么对应到<code>Redis</code>而言，又是怎么做的呢？在这里，我们还需要另外一个知识，<code>虚拟地址映射。</code></p><p>对于<code>Redis</code>而言，我们每次存储的一个<code>key-value</code>的键值对，都是存在真实的物理内存中的，而这些地址，在<code>Redis</code>中存在着一份映射关系。我们通过下面的图，举个栗子，<span style="color:red;" >(这里说明下，下图的内容仅仅只是为了理解，而不是Redis底层的真正实现) </span>。</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/memory_map_01.jpg" alt="工作进程映射关系"></p><p>此时<code>Redis</code>要进行数据持久化的时候，是通过调用系统的<code>fork</code>命令来创建一个子进程的。而子进程依然会保留着这份映射关系，并且<code>fork</code>的时间特别的快，不会阻塞到<code>client</code>端的请求。也就是会变成下图的样子：</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/memory_map_fork_01.jpg" alt="fork子进程"></p><p>如果我们的<code>Redis</code>的工作进程，需要对<code>k1</code>进行修改，此时<code>Redis</code>会采用<code>copy-on-write</code>的方式，也就是说，他不会去改<code>物理内存</code>中<code>1号位置</code>的值，而是将新的内容写入到<code>2号位置</code>，<code>改变指针</code>即可。这样对于<code>子进程</code>而言，我拿到的依然是<code>修改前</code>的值。</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/memory_map_fork_02.jpg" alt="copy-on-write"></p><p>对于这样的操作方式，<code>Redis</code>也为我们提供了指令<code>BGSAVE</code>。我们可以通过调用<code>BGSAVE</code>，来实现将数据异步的存储到硬盘中。</p><h2 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h2><p>通过上面的解释，我们知道了<code>Redis</code>是如何将数据存储到硬盘中的。而<code>RDB</code>就是采用的上述描述的第二种方式。因此，对于<code>RDB</code>而言，我们存储的数据并不是<code>实时</code>的。例如我们在8点钟执行了<code>BGSAVE</code>，或者系统自动触发。在9点钟的时候，完成了数据的持久化，根据上面的讲解，我们知道对于8点到9点之间的数据变更，并没有存储到<code>RDB</code>文件当中，并且<code>BGSAVE</code>操作，每次存储数据都是全量存储的。所以这样的存储方式会产生数据遗漏的问题。</p><h3 id="RDB的配置"><a href="#RDB的配置" class="headerlink" title="RDB的配置"></a><code>RDB</code>的配置</h3><p>对于<code>RDB</code>的生成，我们可以采用前面介绍的命令<code>BGSAVE</code>，或者也可以采用配置文件的方式进行配置，在这里，我主要讲解下配置文件的配置方式：</p><pre><code>save 900 1save 300 10save 60 10000</code></pre><p>对于<code>Redis</code>而言，默认已经开启了<code>RDB</code>持久化，同时，给出的默认设置是：</p><pre><code>1.如果60s内的写操作大于10000次，则自动开启BGSAVE2.如果300s内的写操作大于10次，则自动开启BGSAVE3.如果900s内的写操作大于1次，则自动开启BGSAVE</code></pre><p>以上的三个条件，只要满足其中的一个，就会触发<code>BGSAVE</code>。</p><p>这里要注意下，在配置文件中，虽然我们是通过<code>save指令</code>来指定<code>RDB</code>的触发机制，但是在<code>Redis</code>中，触发的不是<code>save指令</code>，而是<code>BGSAVE指令</code>。</p><p>同时，我们可以通过<code>dbfilename</code>与<code>dir</code>分别指定<code>RDB</code>文件的名称和存储的路径。</p><h2 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是<code>AOF</code></h2><p>上面我们介绍了<code>RDB</code>的一个执行的原理和过程，但是我们发现一个问题，它并不能实时的持久化最新的数据，基于这个问题，Redis给我们提供了另外一种存储方式<code>AOF</code>。</p><p>对于<code>AOF</code>而言，他存储的并不是内存中的数据，而是用户的一条条指令。<code>Redis</code>会将用户的每一条指令，通过追加到文件的方式，写入到一个日志文件中，这个就是<code>AOF</code>。</p><p>在这里，我们要注意下，对于<code>AOF</code>，<code>Redis</code>默认并没有自动开启，需要我们手动的在<code>redis.conf</code>配置文件中开启。开启的命令就是将<code>appendonly</code>从<code>no</code>改成<code>yes</code>。同时可以通过<code>appendfilename</code>指定AOF文件的名称。</p><p>在这里，我们要注意下，对于<code>AOF</code>的写入存在着以下三个时机：</p><ol><li><code>no</code>：指的是当每次内核中的<code>缓冲buffer</code>满了以后，会自动的往<code>AOF文件</code>中<code>flush</code>一次。<ul><li>优点：降低了<code>IO</code>的频率</li><li>缺点：容易丢失一个<code>buffer</code>的数据</li></ul></li><li><code>always</code>：指的是当每次发生一次写操作，都会立即往<code>AOF</code>文件中<code>flush</code>一次。<ul><li>优点：最大可能的保证了数据的准确性</li><li>确定：提高了<code>IO</code>的频率</li></ul></li><li><code>everysec</code>：每秒中调用一次<code>flush</code>，是上面两个方案的折中。</li></ol><p>在<code>Redis</code>的配置文件中，默认采用的是<code>第3种</code>方案，可以通过修改<code>redis.conf</code>中的<code>appendfsync</code>对应的<code>value</code>来起到改变策略的目的。</p><p>同样的，对于<code>AOF</code>的操作，我们也可以采用<code>BGREWRITEAOF</code>命令来手动的发起。</p><h3 id="AOF策略的优化"><a href="#AOF策略的优化" class="headerlink" title="AOF策略的优化"></a>AOF策略的优化</h3><h4 id="Redis-4-0之前的版本"><a href="#Redis-4-0之前的版本" class="headerlink" title="Redis 4.0之前的版本"></a>Redis 4.0之前的版本</h4><p>在<code>Redis4.0</code>之前的版本中，<code>Redis</code>对于<code>AOF</code>的操作的优化主要是在<code>rewrite</code>中进行的。</p><p>在这里我们举个栗子：假如我们有一个新的<code>Redis</code>实例，里面的数据为空，此时我们有个程序，不停的对同一个<code>key</code>进行<code>incr</code>。在执行完<code>100W</code>次以后，此时我们的<code>AOF</code>文件会变得很大。因为<code>AOF</code>文件，相当于要记录下<code>100W</code>操作的每次的完整的命令。在这里，我们以<code>k1</code>为<code>key</code>做演示，仅<code>INCR</code>一次，我们看下<code>AOF</code>的文件内容：</p><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/Redis_INCR_01.jpg" alt="Redis-INCR"></p><p>此时我们通过客户端，执行<code>set incr get</code> 命令后，通过配置文件，找到对应的<code>AOF</code>文件，然后打开(我已将<code>appendfsync</code>改成了<code>always</code>,方便看到效果 )：</p><pre><code>*2$6SELECT$10*3$3set$2k1$11*2$4incr$2k1</code></pre><p>此时我们发现，AOF的文件内容居然是这样的。接下来，我们解读下当前命令：</p><ol><li><code>*2</code>:代表的是接下来，我要读取两个值，分别是<code>SELECT</code>和<code>0</code>。代表我们读取第0号数据库。</li><li><code>$6</code>、<code>$1</code>代表的是指令的长度，并不在<code>*2</code>的读取范围内。</li><li>接下来，所有的命令依次类推即可。</li></ol><p>上面的内容还仅仅只是<code>incr</code>依次的结果，如果我们<code>incr</code>多次呢？这个<code>AOF</code>的文件会变得特别的大，将来<code>Server</code>启动，<code>load</code>数据的时候，会变得的慢。试下一下，如果我执行了<code>100W</code>次的<code>incr k1</code>,其实下次程序启动，直接设置<code>set k1 = 10100000</code>即可。</p><p>对了，在这里要说明下，在程序启动的时候，如果没有开启<code>AOF</code>,此时程序会以<code>RDB</code>的文件内容为准，如果开启了<code>AOF</code>,则会以<code>AOF</code>文件中的内容为准。</p><p>基于上面的原因， <code>Redis</code>在文件达到指定大小和指定增加百分比的时候，对<code>AOF文件</code>会进行<code>rewrite</code>操作。其中可以通过<code>Redis.conf</code>的<code>auto-aof-rewrite-min-size</code>来指定重写文件的最小值，<code>auto-aof-rewrite-percentage</code>来指定当文件达到多大的百分比时进行<code>rewrite</code>。在<code>Redis</code>中，设置的默认大小分别为<code>64MB</code>和<code>100</code>。</p><p><code>rewrite</code>操作，会对文件中的命令进行整合，从而起到消除文件大小的作用，但是一旦Redis发生了rewrite操作之后，此时仅仅保留的就是最终的信息，对于数据的一个变迁的过程，无法再看见了。同时，对于文件的整合，是非常消耗<code>CPU</code>性能的。</p><p>接着上面的命令，我们执行下<code>BGREWRITEAOF</code>指令，再来看下<code>AOF</code>文件的内容：</p><pre><code>*2$6SELECT$10*3$3SET$2k1$12</code></pre><p>此时我们发现，在<code>AOF</code>文件中，已经将<code>k1</code>直接设置成了<code>2</code>。删去了<code>k1</code>的数据变迁过程。</p><h4 id="Redis-4-0及之后的版本"><a href="#Redis-4-0及之后的版本" class="headerlink" title="Redis 4.0及之后的版本"></a>Redis 4.0及之后的版本</h4><p>在<code>Redis 4.0</code>之前的版本，对于<code>RDB</code>和<code>AOF</code>可以同时开启，但是<code>Redis</code>在启动的时候，仅仅只会使用其中的一个。但是在<code>Redis4.0</code>之后的版本中，可以通过<code>redis.conf</code>中的<code>aof-use-rdb-preamble</code>来指定是否将<code>RDB</code>与<code>AOF</code>混合起来一起使用。在<code>Redis4.0</code>之后的版本中，<code>Redis</code>已经默认开启了混合使用的策略。</p><p>那么什么是混合使用呢？混合使用其实就是在<code>rewrite</code>的时候，对于<code>rewrite</code>之前的数据，采用<code>RDB</code>的方式存到文件中，便于后续程序在启动的过程中能够快读的<code>laod</code>数据，而对于<code>rewrite</code>期间，<code>redis</code>产生的写操作，则通过<code>AOF</code>的方式，追加到文件的末尾。大大的提高了程序的效率。</p><p>接下来，还是上面的例子，我们将<code>redis</code>清空，删除所有的持久化文件，将<code>aof-use-rdb-preamble</code>改成yes。再执行上线的操作，查看<code>AOF</code>文件：</p><pre><code>set k1 1incr k1get k1BGREWRITEAOFset k2 10get k2</code></pre><p><img src="https://shengouqiang.cn/img/Redis/RDB_AOF/AOF_RDB_ALL_USE.jpg" alt="工作进程映射关系"></p><p>我们发现，文件的开头已经是一堆乱码了。但是在程序只有，依然是我们的<code>set k2 10</code>这个命令。同时我们发现，在<code>AOF</code>的文件的开头，是<code>REDIS</code>。这个算是<code>RDB</code>文件开头的一个标识。代表的是<code>RDB</code>文件的内容。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文件中，我们学习了<code>Redis</code>的<code>RDB</code>与<code>AOF</code>的存储原理和存储过程。同时对于配置文件中的配置，也起到了说明的作用。供自己以后的参看。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS-NVIDIA显卡驱动380.10.10.10.40.137</title>
      <link href="//BlackMac/NVIDIA_380_10_10_10_40_137_DRIVER/"/>
      <url>//BlackMac/NVIDIA_380_10_10_10_40_137_DRIVER/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS-NVIDIA显卡驱动380-10-10-10-40-137"><a href="#MacOS-NVIDIA显卡驱动380-10-10-10-40-137" class="headerlink" title="MacOS-NVIDIA显卡驱动380.10.10.10.40.137"></a>MacOS-NVIDIA显卡驱动380.10.10.10.40.137</h1><p>前两天手贱，升级了一下自己台式机的黑苹果，果然。出了问题，发现显卡不能使用了。在网上折腾了好久，终于找到了最新版本的<code>N卡</code>对<code>MacOS</code>的驱动，在这里记录一下，同时对于有需要的朋友，可能拿去。</p><p>本人的显卡是<code>1070</code>，<code>MacOS</code>的版本是<code>10.13.6</code>。</p><p>下载地址：</p><pre><code>下载:https://wws.lanzous.com/iNwfidfezah 密码:ev7d</code></pre><p><img src="https://shengouqiang.cn/img/BlackMac/NVIDIA/MacOS_INFO.jpg" alt="MacOS_INFO"></p><p><img src="https://shengouqiang.cn/img/BlackMac/NVIDIA/NVIDIA_INFO.jpg" alt="NVIDIA_INFO"></p>]]></content>
      
      
      <categories>
          
          <category> 黑苹果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
            <tag> NVIDIA </tag>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS--修改NTP</title>
      <link href="//BlackMac/MacFixTimeNTP/"/>
      <url>//BlackMac/MacFixTimeNTP/</url>
      
        <content type="html"><![CDATA[<h1 id="MacOS–修改NTP"><a href="#MacOS–修改NTP" class="headerlink" title="MacOS–修改NTP"></a>MacOS–修改NTP</h1><p>对于<code>MacOS</code>而言，有的时候，我们需要修改<code>NTP</code>的<code>server</code>,最好是将<code>NTP</code>的<code>server</code>改成国内的地址，具体原因，你懂的。</p><p>接下来，我们讲解下如何修改：</p><ol><li>对于<code>MacOS</code>而言，我们如果想要修改<code>NTP</code>的<code>server</code>，在<code>-&gt;系统偏好设置-&gt;日期与时间</code>内，我们仅仅只能查看，但是不能够修改，如果想要修改，系统通过终端，以命令行的方式进行修改。具体路径如下：<ul><li><code>/etc/ntp.conf</code></li><li><code>/private/etc/ntp.conf</code></li></ul></li><li>通过终端，我们修改上面两个内容中的一个即可。</li><li>首先我们看下，原来的<code>server</code>是<code>time.asia.apple.com</code>。对于这个地址，我不是特别的喜欢，因此我改成了以下的国内地址<ul><li><code>ntp1.aliyun.com</code></li><li><code>ntp2.aliyun.com</code></li><li><code>ntp3.aliyun.com</code></li><li><code>ntp4.aliyun.com</code></li><li><code>ntp5.aliyun.com</code></li><li><code>ntp6.aliyun.com</code></li><li><code>ntp7.aliyun.com</code></li></ul></li><li>在这里，我打算用第一个<code>ntp1.aliyun.com</code>。</li><li>接下来是修改环节<ol><li>打开<code>终端.app</code></li><li>输入<code>sudo vim /etc/ntp.conf</code></li><li>系统提示，输入密码，此时我们输入对应登录账号的登录密码，注意，在这里，无论我们写了多少个，在界面都不会显示的。</li><li>如果没有意外，此时只有一行内容<code>server time.asia.apple.com</code>。此时我们将<code>time.asia.apple.com</code> 改成 <code>ntp1.aliyun.com</code>。</li><li>修改完成之后，首先按一下<code>Esc</code>键，然后输入<code>:wq</code>，最后点击回车<code>Enter</code>键。</li></ol></li><li>到这里，我们已经将<code>NTP</code>的<code>server</code>修改完毕，此时我们需要<code>重启</code>我们的系统。</li><li>重启系统后，我们打开<code>-&gt;系统偏好设置-&gt;日期与时间</code>，此时我们发现，我们的<code>server</code>已经改成了<code>ntp1.aliyun.com</code>。</li></ol><p><img src="https://shengouqiang.cn/img/BlackMac/MacFixTimeNTP/NTP_Server.jpg" alt="NTP_Server"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实，对于<code>MacOS</code>的<code>NTP</code>的设置，与<code>Linux</code>的设置十分的类似，会了这个，对于<code>Linux</code>系统的<code>NTP</code>的修改，也是通用的。</p>]]></content>
      
      
      <categories>
          
          <category> 黑苹果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
            <tag> NTP </tag>
            
            <tag> 时间同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑苹果--BCM20702A0型号蓝牙修复</title>
      <link href="//BlackMac/BCM20702A0BuleToothfix/"/>
      <url>//BlackMac/BCM20702A0BuleToothfix/</url>
      
        <content type="html"><![CDATA[<h1 id="黑苹果–BCM20702A0型号蓝牙修复"><a href="#黑苹果–BCM20702A0型号蓝牙修复" class="headerlink" title="黑苹果–BCM20702A0型号蓝牙修复"></a>黑苹果–BCM20702A0型号蓝牙修复</h1><p>在这里，首先要感谢这个网站  <a href="http://bbs.pcbeta.com/viewthread-1117415-1-1.html">X230 蓝牙BCM20702A0原生驱动，修改个ID就OK！</a>  提供的一个解决思路。对于黑苹果而言，修复蓝牙的方式有很多。无疑，这个网站中的方式仅为其中的一种而已。在这里，我主要想给自己留下一份记录，同时也对于像自己一样的新手，起到一个引导的作用。</p><p>通过上面的文章，我们不难发现，这个文章的修复方式主要是改动<code>idProduct</code>即可。在这里，我主要讲解的是如何改动。</p><p>首先，你要确认你的蓝牙的型号是<code>BCM20702A0</code>。</p><h2 id="在Mac系统中进行查看"><a href="#在Mac系统中进行查看" class="headerlink" title="在Mac系统中进行查看"></a>在Mac系统中进行查看</h2><h3 id="查看usb"><a href="#查看usb" class="headerlink" title="查看usb"></a>查看usb</h3><p>首先，我们要在Mac系统中进行检查，检查路径如下：<code>-&gt;关于本机-&gt;概览-&gt;系统报告</code>。点进去后如下图所示:</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/system_report.jpg" alt="系统报告"></p><p>接下来，点击<code>硬件-&gt;USB</code>。点击进去如下图所示:</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/usb_show.jpg" alt="USB"></p><p>我们发现，在系统中，是可以看到有蓝牙设备的存在的。此时我们需要获取到<code>产品ID</code>。如下图所示：</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/sub_buletooth_show.jpg" alt="USB-蓝牙模块"></p><p>在这里，我们的<code>产品ID</code>是<code>0x828d</code>。注意一下，现在的值是一个<code>16进制</code>的，我们真正需要的是一个<code>10进制</code>的。因此，我们需要将<code>0x828d</code>转换成<code>10进制</code>，为<code>33421</code>。</p><p>在这里，我们要注意下，我们的蓝牙是在<code>BRCM20702</code>下面的。我们要记住这个值，在后面的修改中有用。</p><h3 id="查看蓝牙"><a href="#查看蓝牙" class="headerlink" title="查看蓝牙"></a>查看蓝牙</h3><p>在查看了<code>usb</code>之后，我们查看下<code>蓝牙</code>。具体路径如下：<code>硬件-&gt;蓝牙</code>。如下图所示：</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/buletooth_show.jpg" alt="蓝牙"></p><p>在这里，是因为我已经修复成功了。在我刚安装，没有修复之前，右侧显示的是<code>未发现硬件</code>之类的内容。</p><h2 id="利用终端进入路径："><a href="#利用终端进入路径：" class="headerlink" title="利用终端进入路径："></a>利用终端进入路径：</h2><p>接下来，我们打开<code>终端.app</code>。然后执行以下命令：</p><pre><code class="shell">cd /System/Library/Extensions/IOBluetoothFamily.kext/Contents/PlugIns/BroadcomBluetoothHostControllerUSBTransport.kext/Contentsopen .</code></pre><p>然后，系统会自动的弹出一个文件夹，如下图所示：</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/file_show.jpg" alt="访达显示info.plist"></p><p>对于图中的<code>info.plist</code>。我们用系统自带的<code>文本编辑.app</code>打开即可。</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/file_context_show.jpg" alt="info.plist"></p><h2 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>还记得我们之前记下来的<code>BRCM20702</code>。我们通过这个进行查找：</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/find_in_file_show.jpg" alt="内容查找"></p><p>不出意外的话，你只能查到<code>一个</code>匹配项。接下来，我们确认了，我们只需要修改红色的框圈出来的地方即可。</p><p><img src="https://shengouqiang.cn/img/BlackMac/BCM20702A0BuleToothfix/modify_in_file_show.jpg" alt="确定范围"></p><p>看见了吗？我们找到了<code>idProduct</code>的位置了。接下来，就是将其修改为我们前面计算出来的<code>10进制</code>的<code>33421</code>即可。我这里是因为修改过，因此图片展示的是已经修改过的了。</p><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>当我们修改的时候，此时系统会提示我们<code>您不是文件“Info.plist”的所有者，因此没有权限写到该文件</code>。对于这个问题，有两个解决方案：</p><ol><li>利用<code>Kext Wizard</code>进行修改，对于不懂<code>Kext Wizard</code>的，可以自己百度</li><li>利用<code>Sublime Text 3</code>进行修改，可以正常保存。</li></ol><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><p>当我们都执行完毕以后，我们可以重启电脑，检测<code>蓝牙</code>是否已经能够正常使用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于黑苹果的折腾，我也仅仅只是一个小白，还在摸索当中。对于后期如果有别的学习内容，会同步到当前博客中。另外，还是那句话—— <code>黑苹果，且折腾且珍惜</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 黑苹果 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑苹果 </tag>
            
            <tag> 蓝牙修复 </tag>
            
            <tag> 免驱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用双向链表+HashMap实现LRU算法</title>
      <link href="//Algorithm/AlgorithmLearnDay03/"/>
      <url>//Algorithm/AlgorithmLearnDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="利用双向链表-HashMap实现LRU算法"><a href="#利用双向链表-HashMap实现LRU算法" class="headerlink" title="利用双向链表+HashMap实现LRU算法"></a>利用双向链表+HashMap实现LRU算法</h1><p>在上一篇文章中，我们讲解了利用单链表实现<code>LRU</code>算法的功能。在上一篇文章中，我们无论是新增，还是替换，我们的时间复杂度都是<code>O(n)</code>。那么有没有什么办法让我们的时间发杂度是<code>O(1)</code>的呢？其实是有的。</p><p>首先，对于在链表中是否存在当前节点，我们可以通过<code>HashMap</code>来进行实现的。这样，利用<code>hash</code>的特性，可以让我们将查找的时间复杂度控制在<code>O(1)</code>。</p><p>其次我们规定，越靠近<code>head</code>节点的元素，是越不常使用的。而越靠近<code>tail</code>节点的，则是刚刚使用的。因此，如果我们可以随时知道一个链表的<code>head</code>和<code>tail</code>节点的话，同时，对于链表中的任何一个元素，我们可以知道节点的<code>prev</code>和<code>next</code>节点，就能够实现无论是插入，还是获取，都可以实现时间复杂度为<code>O(1)</code>的代码。</p><h2 id="前置变量定义"><a href="#前置变量定义" class="headerlink" title="前置变量定义"></a>前置变量定义</h2><p>OK，废话不多说，在这里，我们要强调几个变量：</p><ol><li>capacity 代表的是<code>LRU</code>中最多的缓存个数</li><li>valueMap 是一个<code>Map&lt;T, Node&lt;T&gt;&gt;</code>类型的数据结构，其中，<code>T</code>代表的是<code>value</code>值，而<code>Node&lt;T&gt;</code>代表的是当前节点在链表中的位置。</li><li>head 代表的是链表的<code>head</code>节点。</li></ol><h2 id="代码展示"><a href="#代码展示" class="headerlink" title="代码展示"></a>代码展示</h2><h3 id="Node节点的定义"><a href="#Node节点的定义" class="headerlink" title="Node节点的定义"></a>Node节点的定义</h3><pre><code class="java">package datastructure.lru;import lombok.Getter;import lombok.Setter;import java.util.Objects;@Getter@Setterpublic class Node&lt;T&gt;&#123;    private Node&lt;T&gt; prev;    private Node&lt;T&gt; next;    private T value;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Node&lt;?&gt; node = (Node&lt;?&gt;) o;        return value.equals(node.value);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(value);    &#125;    @Override    public String toString() &#123;        return &quot;Node&#123;&quot; +                &quot;prev=&quot; + prev +                &quot;, next=&quot; + next +                &quot;, value=&quot; + value +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><h3 id="LRU算法实现"><a href="#LRU算法实现" class="headerlink" title="LRU算法实现"></a>LRU算法实现</h3><pre><code class="java">package datastructure.lru;import java.util.HashMap;import java.util.Map;import java.util.Objects;/** * LRU算法实现 */public class LruAlgorithm&lt;T&gt; &#123;    private Integer capacity;    private Map&lt;T, Node&lt;T&gt;&gt; valueMap;    private Node&lt;T&gt; head;    public LruAlgorithm(Integer capacity) &#123;        this.capacity = capacity;        this.valueMap = new HashMap&lt;&gt;();        this.head = new Node&lt;&gt;();    &#125;    public T getValue(T t) &#123;        if (Objects.isNull(valueMap) || Objects.isNull(valueMap.get(t))) &#123;            return null;        &#125;        changeLocation(t);        showLinkList();        return t;    &#125;    public Node&lt;T&gt; setValue(T t) &#123;        if (Objects.isNull(valueMap.get(t))) &#123;            if (capacity &lt;= valueMap.size()) &#123;                replaceNode(t);            &#125; else &#123;                addNode(t);            &#125;        &#125; else &#123;            changeLocation(t);        &#125;        showLinkList();        return head;    &#125;    public Node&lt;T&gt; lruOperate(T[] array) &#123;        if (Objects.isNull(array) || 0 == array.length) &#123;            return null;        &#125;        for (int i = 0; i &lt; array.length; i++) &#123;            setValue(array[i]);        &#125;        return head;    &#125;    private void addNode(T value) &#123;        Node&lt;T&gt; tmp = new Node&lt;&gt;();        tmp.setValue(value);        if (Objects.isNull(head) || Objects.isNull(head.getNext())) &#123;            head.setNext(tmp);            head.setPrev(tmp);            tmp.setPrev(head);        &#125; else &#123;            head.getPrev().setNext(tmp);            tmp.setPrev(head.getPrev());            head.setPrev(tmp);        &#125;        valueMap.put(value, tmp);    &#125;    private void replaceNode(T value) &#123;        Node&lt;T&gt; tmp = new Node&lt;&gt;();        tmp.setValue(value);        valueMap.remove(value);        Node&lt;T&gt; firstNode = head.getNext();        head.setNext(firstNode.getNext());        firstNode.getNext().setPrev(head);        addNode(value);    &#125;    private void changeLocation(T value) &#123;        Node&lt;T&gt; queryNode = valueMap.get(value);        if (head.getPrev().equals(queryNode)) &#123;            return;        &#125;        valueMap.remove(value);        queryNode.getPrev().setNext(queryNode.getNext());        queryNode.getNext().setPrev(queryNode.getPrev());        addNode(value);    &#125;    public void showLinkList() &#123;        Node&lt;T&gt; tailNode = head.getPrev();        while (!Objects.isNull(tailNode) &amp;&amp; !Objects.isNull(tailNode.getValue())) &#123;            System.out.print(tailNode.getValue() + &quot;\t&quot;);            tailNode = tailNode.getPrev();        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        Integer[] array = &#123;10, 4, 6, 8, 7, 4, 10, 5&#125;;        LruAlgorithm&lt;Integer&gt; lru = new LruAlgorithm&lt;&gt;(5);        System.out.println(&quot;------------------start lru ------------------&quot;);        lru.lruOperate(array);        System.out.println(&quot;------------------end lru ------------------&quot;);        System.out.println(&quot;------------------start get ------------------&quot;);        Integer value = lru.getValue(1);        System.out.println(&quot;value = &quot; + value);        lru.getValue(4);        System.out.println(&quot;------------------end get ------------------&quot;);        System.out.println(&quot;------------------start set ------------------&quot;);        lru.setValue(1);        System.out.println(&quot;----------------------------------------------&quot;);        lru.setValue(10);        System.out.println(&quot;------------------end set ------------------&quot;);    &#125;&#125;</code></pre><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><pre><code>------------------start lru ------------------10    4    10    6    4    10    8    6    4    10    7    8    6    4    10    4    7    8    6    10    10    4    7    8    6    5    10    4    7    8    ------------------end lru ------------------------------------start get ------------------value = null4    5    10    7    8    ------------------end get ------------------------------------start set ------------------1    4    5    10    7    ----------------------------------------------10    1    4    5    7    ------------------end set ------------------</code></pre><h2 id="动画展示"><a href="#动画展示" class="headerlink" title="动画展示"></a>动画展示</h2><p>对于上面代码不是很熟悉的小伙伴，可以先看下下面的视频展示，然后再回顾代码，可以更好的理解。</p><video id="video" controls="controls" controlslist="nodownload"  width="1000" height="480" preload="none" poster="https://shengouqiang.cn/img/video/fengmian1000480.jpg">      <source id="mp4" src="https://shengouqiang.cn/video/Algorithm/LRU/LRU_Hash_Link.mp4" type="video/mp4"></video>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 常用算法证明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法学习 </tag>
            
            <tag> 面试算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="//DesignPattern/StrategyPattern01/"/>
      <url>//DesignPattern/StrategyPattern01/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式-策略模式"><a href="#设计模式-策略模式" class="headerlink" title="设计模式-策略模式"></a>设计模式-策略模式</h1><p>在本文，我们要讲解下策略模式的学习。在百度百科中，对于策略是这样定义的：</p><blockquote><p>策略模式作为一种<a href="https://baike.baidu.com/item/软件设计模式">软件设计模式</a>，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。</p></blockquote><p>其实，在实际的生活中，我们可以在很多的地方用到策略模式。我们可以举一些例子：</p><ol><li>假如你的公司在中国和美国都有子公司，中国子公司招中国员工，美国子公司招收美国员工。每个员工都需要缴纳“个税”。因此，对于美国和中国的个税的计算，我们就可以采用策略模式进行设计。</li><li>假如你有一个超市，这个超市会在不同的节假日进行不同的打折促销活动。例如：在国庆期间可以有满100减20的活动，在劳动节，可以实现打七折的活动，这种情况下，也可以采用策略模式。</li></ol><p>你也许会问，我不用策略模式依然可以实现啊。我可以在我的代码中多几个<code>if else</code>就搞定了，或者对于相应的代码，我可以将原来的代码删除，将新的业务逻辑写进去。</p><p>这么做不是不行，在这里，我们要知道，设计模式的目的，不是在于如果我们不这么做，就不能实现我们的业务。而是在于如果我们这么做，我们可以将我们的系统设计的更好，可以达到更好的健壮性和扩展性，对于后期人员的代码维护和业务扩展，不至于那么的痛苦。说白了，设计模式本就是一个“锦上添花”的东西。但是仅仅就是这个“锦上添花”，可以让我们更加的丰富我们的系统。</p><p>接下来，就是一个代码展示的部分了。当时我在考虑用什么样的例子的时候，直接看到了<code>JDK</code>的<code>java.util.Comparator</code>接口，得到的灵感。</p><p>首先说明：本文为了展示什么是设计模式，没有采用<code>lamdba</code>表达式进行代码优化，而是采用<code>new</code>对象的方式进行实现的。在实际的使用中，我们可以采用<code>lamdba</code>表达式进行实现。</p><p>下面，我们希望可以通过不同的比较规则，来对于<code>Cat</code>进行排序。</p><h2 id="Cat的Domain实现"><a href="#Cat的Domain实现" class="headerlink" title="Cat的Domain实现"></a>Cat的Domain实现</h2><pre><code class="java">package designpatterns.strategy.domain;import lombok.AllArgsConstructor;        import lombok.Data;        import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class Cat &#123;    private String name;    private Double weight;    private Integer age;    private Sex sex;&#125;</code></pre><h2 id="自义定的函数式比较接口"><a href="#自义定的函数式比较接口" class="headerlink" title="自义定的函数式比较接口"></a>自义定的函数式比较接口</h2><pre><code class="java">package designpatterns.strategy.compare;@FunctionalInterfacepublic interface StrategyComparator&lt;T&gt; &#123;    int compare(T t1,T t2);&#125;</code></pre><pre><code class="java">package designpatterns.strategy.domain;import lombok.Getter;@Getterpublic enum Sex &#123;    /**     * 雄性     */    MALE(&quot;1&quot;,&quot;雄性&quot;),    /**     * 雌性     */    FEMALE(&quot;2&quot;,&quot;雌性&quot;);    private String code;    private String desc;    Sex(String code,String desc)&#123;        this.code=code;        this.desc=desc;    &#125;&#125;</code></pre><p>在这里，我们定义了一个函数式接口，这个接口支持泛型，仅有一个抽象函数，目的在于比较两个变量的大小。并且，我们规定，如果<code>t1</code>小于<code>t2</code>，返回<code>-1</code>，<code>t1</code>等于<code>t2</code>，返回<code>0</code>，<code>t1</code>大于<code>t2</code>，返回<code>1</code>。</p><p>接下来，我们采用<code>选择排序</code>的方式进行排序</p><h3 id="选择排序的实现"><a href="#选择排序的实现" class="headerlink" title="选择排序的实现"></a>选择排序的实现</h3><pre><code class="java">package designpatterns.strategy.sort;import designpatterns.strategy.compare.StrategyComparator;@FunctionalInterfacepublic interface Sort&lt;T&gt; &#123;    void sort(T[] arrray,StrategyComparator&lt;T&gt; comparator);&#125;</code></pre><pre><code class="java">package designpatterns.strategy.sort.impl;import designpatterns.strategy.compare.StrategyComparator;import designpatterns.strategy.sort.Sort;public class SelectSort&lt;T&gt; implements Sort&lt;T&gt; &#123;    @Override    public void sort(T[] arrray, StrategyComparator&lt;T&gt; comparator) &#123;        for (int i = 0; i &lt; arrray.length - 1; i++) &#123;            int minPos = i;            for (int j = i + 1; j &lt; arrray.length; j++) &#123;                minPos = comparator.compare(arrray[j], arrray[minPos]) == -1 ? j : minPos;            &#125;            swap(arrray, i, minPos);        &#125;    &#125;    private void swap(T[] array, int i, int j) &#123;        T tmp = array[i];        array[i] = array[j];        array[j] = tmp;    &#125;&#125;</code></pre><p>这里不多说，就是一个简单的选择排序实现。</p><p>接下来，是重头戏，首先，我们先通过年龄对<code>Cat</code>进行排序。</p><h2 id="通过Age-对Cat进行排序"><a href="#通过Age-对Cat进行排序" class="headerlink" title="通过Age 对Cat进行排序"></a>通过<code>Age</code> 对<code>Cat</code>进行排序</h2><pre><code class="JAVA">package designpatterns.strategy.compare.impl;import designpatterns.strategy.compare.StrategyComparator;import designpatterns.strategy.domain.Cat;public class CatComparatorByAge implements StrategyComparator&lt;Cat&gt; &#123;    @Override    public int compare(Cat t1, Cat t2) &#123;        return t1.getAge() &lt; t2.getAge() ? -1 :  t1.getAge()  &gt; t2.getAge()  ?  1 : 0;    &#125;&#125;</code></pre><p>然后我们看下测试类：</p><pre><code class="java">package designpatterns.strategy.test;import designpatterns.strategy.compare.impl.CatComparatorByAge;import designpatterns.strategy.compare.impl.CatComparatorByWeight;import designpatterns.strategy.domain.Cat;import designpatterns.strategy.domain.Sex;import designpatterns.strategy.sort.Sort;import designpatterns.strategy.sort.impl.SelectSort;import org.junit.Test;public class StrategyTest &#123;    @Test    public void catSort() &#123;        Cat[] catArray = &#123;                new Cat(&quot;zhao&quot;, 18.0D, 10, Sex.MALE),                new Cat(&quot;zhao&quot;, 12.0D, 2, Sex.MALE),                new Cat(&quot;zhao&quot;, 28.0D, 1, Sex.MALE),                new Cat(&quot;zhao&quot;, 8.0D, 8, Sex.MALE),                new Cat(&quot;zhao&quot;, 38.0D, 9, Sex.MALE),                new Cat(&quot;zhao&quot;, 5.0D, 5, Sex.MALE),                new Cat(&quot;zhao&quot;, 2.1D, 3, Sex.MALE),                new Cat(&quot;zhao&quot;, 6.6D, 4, Sex.MALE),                new Cat(&quot;zhao&quot;, 48.0D, 15, Sex.MALE),                new Cat(&quot;zhao&quot;, 0.1D, 7, Sex.MALE)        &#125;;        Sort&lt;Cat&gt; sort = new SelectSort&lt;&gt;();        sort.sort(catArray, new CatComparatorByAge());        //sort.sort(catArray,new CatComparatorByWeight());        for (Cat cat : catArray) &#123;            System.out.println(cat);        &#125;    &#125;&#125;</code></pre><p>实验结果为:</p><pre><code>Cat(name=zhao, weight=28.0, age=1, sex=MALE)Cat(name=zhao, weight=12.0, age=2, sex=MALE)Cat(name=zhao, weight=2.1, age=3, sex=MALE)Cat(name=zhao, weight=6.6, age=4, sex=MALE)Cat(name=zhao, weight=5.0, age=5, sex=MALE)Cat(name=zhao, weight=0.1, age=7, sex=MALE)Cat(name=zhao, weight=8.0, age=8, sex=MALE)Cat(name=zhao, weight=38.0, age=9, sex=MALE)Cat(name=zhao, weight=18.0, age=10, sex=MALE)Cat(name=zhao, weight=48.0, age=15, sex=MALE)</code></pre><h2 id="通过Weight对Cat进行排序"><a href="#通过Weight对Cat进行排序" class="headerlink" title="通过Weight对Cat进行排序"></a>通过<code>Weight</code>对<code>Cat</code>进行排序</h2><pre><code class="java">package designpatterns.strategy.compare.impl;import designpatterns.strategy.compare.StrategyComparator;import designpatterns.strategy.domain.Cat;public class CatComparatorByWeight implements StrategyComparator&lt;Cat&gt; &#123;    @Override    public int compare(Cat t1, Cat t2) &#123;        return t1.getWeight() &lt; t2.getWeight() ? -1 :  t1.getWeight()  &gt; t2.getWeight()  ?  1 : 0;    &#125;&#125;</code></pre><p>然后我们看下测试类：</p><pre><code class="java">package designpatterns.strategy.test;import designpatterns.strategy.compare.impl.CatComparatorByAge;import designpatterns.strategy.compare.impl.CatComparatorByWeight;import designpatterns.strategy.domain.Cat;import designpatterns.strategy.domain.Sex;import designpatterns.strategy.sort.Sort;import designpatterns.strategy.sort.impl.SelectSort;import org.junit.Test;public class StrategyTest &#123;    @Test    public void catSort() &#123;        Cat[] catArray = &#123;                new Cat(&quot;zhao&quot;, 18.0D, 10, Sex.MALE),                new Cat(&quot;zhao&quot;, 12.0D, 2, Sex.MALE),                new Cat(&quot;zhao&quot;, 28.0D, 1, Sex.MALE),                new Cat(&quot;zhao&quot;, 8.0D, 8, Sex.MALE),                new Cat(&quot;zhao&quot;, 38.0D, 9, Sex.MALE),                new Cat(&quot;zhao&quot;, 5.0D, 5, Sex.MALE),                new Cat(&quot;zhao&quot;, 2.1D, 3, Sex.MALE),                new Cat(&quot;zhao&quot;, 6.6D, 4, Sex.MALE),                new Cat(&quot;zhao&quot;, 48.0D, 15, Sex.MALE),                new Cat(&quot;zhao&quot;, 0.1D, 7, Sex.MALE)        &#125;;        Sort&lt;Cat&gt; sort = new SelectSort&lt;&gt;();        //sort.sort(catArray, new CatComparatorByAge());        sort.sort(catArray,new CatComparatorByWeight());        for (Cat cat : catArray) &#123;            System.out.println(cat);        &#125;    &#125;&#125;</code></pre><p>实验结果为:</p><pre><code>Cat(name=zhao, weight=0.1, age=7, sex=MALE)Cat(name=zhao, weight=2.1, age=3, sex=MALE)Cat(name=zhao, weight=5.0, age=5, sex=MALE)Cat(name=zhao, weight=6.6, age=4, sex=MALE)Cat(name=zhao, weight=8.0, age=8, sex=MALE)Cat(name=zhao, weight=12.0, age=2, sex=MALE)Cat(name=zhao, weight=18.0, age=10, sex=MALE)Cat(name=zhao, weight=28.0, age=1, sex=MALE)Cat(name=zhao, weight=38.0, age=9, sex=MALE)Cat(name=zhao, weight=48.0, age=15, sex=MALE)</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，我们总结下，对于策略模式而言，我们可以通过策略模式，在不改变原有代码的情况下<span style="color:red;">(这里的原有代码指的是非客户端代码)</span>。我们可以通过继承接口的方式，来实现一个新的模式。从而达到<code>开闭原则</code>。并且，以后不管有多少种策略，我们只需要不停的实现这个新的接口，来新写一个策略具体实现即可。大致上的一个调用关系如下：</p><p><img src="https://shengouqiang.cn/img/DesignPattern/StrategyPattern01/StrategyCallingRelationship.jpg" alt="UML类图之接口描述"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用单链表实现LRU算法</title>
      <link href="//Algorithm/AlgorithmLearnDay02/"/>
      <url>//Algorithm/AlgorithmLearnDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="利用单链表实现LRU算法"><a href="#利用单链表实现LRU算法" class="headerlink" title="利用单链表实现LRU算法"></a>利用单链表实现LRU算法</h1><p>首先，我们先看下对于<code>Node</code>的定义：</p><pre><code class="java">package datastructure.linklist.node;import lombok.Data;/** * 单链表节点 * @author BiggerShen * @date 2020/3/25 */@Datapublic class SingletonNode&lt;T&gt; &#123;    private T data;    private SingletonNode&lt;T&gt; next;&#125;</code></pre><p>接下来，我们通过</p><ol><li>随机生成一堆数字，代表要读取的页码</li><li>实现LRU算法</li></ol><pre><code class="java">package datastructure.linklist.operate;import datastructure.linklist.node.SingletonNode;import java.util.ArrayList;import java.util.List;import java.util.Objects;import java.util.Random;/** * using singleton link list to achive a LRU algorithm * * @author BiggerShen * @date 2020/3/25 */public class LRUBySingletonLinkList &#123;    /**     * Randomly generate a list connection with listSize,     * and minNum is the mininum value of the list and must be greater than zero,     * and maxNum is the maxnum value of the list and must be greater than zero     *     * @param listSize the size of the list connection     * @param minNum   the mininum value of the list connection     * @param maxNum   the maxnum value of the list connection     * @return     */    public static List&lt;Integer&gt; randomIntegerList(Integer listSize, Integer minNum, Integer maxNum) &#123;        if (listSize &lt;= 0) &#123;            throw new RuntimeException(&quot;the size of the list connection must be greater than zero&quot;);        &#125;        if (minNum &lt; 0) &#123;            throw new RuntimeException(&quot;the mininum of the list connection must be greater than zero&quot;);        &#125;        if (maxNum &lt; 0) &#123;            throw new RuntimeException(&quot;the maxnum of the list connection must be greater than zero&quot;);        &#125;        if (maxNum &lt; minNum) &#123;            throw new RuntimeException(&quot;the maxNum must be greater than minNum&quot;);        &#125;        int sub = maxNum - minNum;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;(realListCapacity(listSize));        for (int i = 0; i &lt; listSize; i++) &#123;            result.add(new Random().nextInt(sub + 1) + minNum);        &#125;        return result;    &#125;    /**     * Returns a power of two size for the given target capacity.     *     * @param originCapacity     * @return     */    public static Integer realListCapacity(Integer originCapacity) &#123;        int n = originCapacity - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : n + 1;    &#125;    /**     * achive the LRU algorithm     *     * @param readList    random List     * @param LRUCacheNum LRU CacheNum     * @return     */    public static SingletonNode&lt;Integer&gt; getLinkListByLRU(List&lt;Integer&gt; readList, Integer LRUCacheNum) &#123;        SingletonNode&lt;Integer&gt; head = new SingletonNode&lt;&gt;();        readList.forEach(i -&gt; &#123;            if (checkValueIsContainedByLinkList(head, i)) &#123;                swapTheValueToHead(head, i);            &#125; else &#123;                if (getLinkListSize(head) &gt;= LRUCacheNum) &#123;                    deleteLastNode(head);                    swapTheValueToHead(head, i);                &#125; else &#123;                    swapTheValueToHead(head, i);                &#125;            &#125;            showList(head);        &#125;);        return head;    &#125;    /**     * get the size of the link connection     *     * @param head     * @return     */    private static Integer getLinkListSize(SingletonNode&lt;Integer&gt; head) &#123;        SingletonNode&lt;Integer&gt; tmp = head;        int size = 0;        while (!Objects.isNull(tmp)) &#123;            size++;            tmp = tmp.getNext();        &#125;        return size;    &#125;    /**     * Determines whether this value exists in the current collection     *     * @return     */    private static Boolean checkValueIsContainedByLinkList(SingletonNode&lt;Integer&gt; head, Integer value) &#123;        SingletonNode&lt;Integer&gt; tmp = head;        while (!Objects.isNull(tmp)) &#123;            if (Objects.equals(tmp.getData(), value)) &#123;                return true;            &#125;            tmp = tmp.getNext();        &#125;        return false;    &#125;    /**     * delete the last one of the list value     *     * @param head     */    private static void deleteLastNode(SingletonNode&lt;Integer&gt; head) &#123;        SingletonNode&lt;Integer&gt; tmp = head;        SingletonNode&lt;Integer&gt; tmpPrev = null;        while (!Objects.isNull(tmp.getNext())) &#123;            tmpPrev = tmp;            tmp = tmp.getNext();        &#125;        tmpPrev.setNext(null);    &#125;    /**     * change the target value to the head     *     * @param head     * @param value     */    private static void swapTheValueToHead(SingletonNode&lt;Integer&gt; head, Integer value) &#123;        SingletonNode&lt;Integer&gt; tmpValue = new SingletonNode&lt;&gt;();        tmpValue.setData(value);        SingletonNode&lt;Integer&gt; tmp = head;        tmpValue.setNext(tmp.getNext());        tmp.setNext(tmpValue);        tmp = tmpValue.getNext();        SingletonNode&lt;Integer&gt; tmpPrev = tmpValue;        while (!Objects.isNull(tmp)) &#123;            if (Objects.equals(tmp.getData(), value)) &#123;                tmpPrev.setNext(tmp.getNext());                return;            &#125;            tmpPrev = tmp;            tmp = tmp.getNext();        &#125;    &#125;    /**     * print the link list     *     * @param head     */    private static void showList(SingletonNode&lt;Integer&gt; head) &#123;        SingletonNode&lt;Integer&gt; tmp = head;        while (!Objects.isNull(tmp)) &#123;            if (Objects.isNull(tmp.getData())) &#123;                tmp = tmp.getNext();                continue;            &#125;            System.out.print(tmp.getData() + &quot;\t&quot;);            tmp = tmp.getNext();        &#125;        System.out.println();    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; randomReadList = randomIntegerList(20, 1, 10);        System.out.println(randomReadList);        SingletonNode&lt;Integer&gt; head = getLinkListByLRU(randomReadList, 4);    &#125;&#125;</code></pre><p>接下来，我们看下运行结果：</p><pre><code>[1, 2, 4, 4, 6, 2, 4, 4, 9, 1, 10, 6, 4, 1, 4, 1, 3, 5, 6, 10]1    2    1    4    2    1    4    2    1    6    4    2    2    6    4    4    2    6    4    2    6    9    4    2    1    9    4    10    1    9    6    10    1    4    6    10    1    4    6    4    1    6    1    4    6    3    1    4    5    3    1    6    5    3    10    6    5    </code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 常用算法证明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法学习 </tag>
            
            <tag> 面试算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式–单例模式</title>
      <link href="//DesignPattern/SingletonPattern01/"/>
      <url>//DesignPattern/SingletonPattern01/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式–单例模式"><a href="#设计模式–单例模式" class="headerlink" title="设计模式–单例模式"></a>设计模式–单例模式</h1><p>在写这篇文章之前，想了好久。一直在想要不要写这么一篇文章出来。为什么呢？主要是这个模式在我的后续的学习当中真的十分的重要。但同样的，这个模式现在又是一个被玩坏了的模式。因为只要你去面试，就一定会被问道。但是呢？问的又不是特别的深(大厂可能问的深，请原谅我这个渣渣，哈哈~~)。思来想去，觉得还是要写一下，在这里，我不会说明单例模式的一个发展的过程。仅仅只贴出最终的一个结果。并且简单说明下，在反射、序列号、克隆的情况下，对于单例模式的破坏，以及如何的修复。</p><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>首先，我们先贴上代码</p><pre><code class="java">package designpatterns.singleton;import java.io.Serializable;import java.util.Objects;/** * 懒汉模式 * * 防止： *  1.并发 *  2.反射(防君子，不妨小人) *  3.克隆 * * @author shengouqiang * @date 2020/3/19 */public class LazySingleton implements Serializable,Cloneable&#123;    private static int loadCount = 0;    private static volatile LazySingleton INSTANCES;    private LazySingleton()&#123;        synchronized (HungarySingleton.class)&#123;            if(loadCount &lt; 1)&#123;                loadCount++;            &#125;else&#123;                throw new RuntimeException(&quot;HungarySingleton 已被加载过，请直接调用getInstances处理&quot;);            &#125;        &#125;    &#125;    private Object readResolve()&#123;        return getInstances();    &#125;    public static LazySingleton getInstances()&#123;        if(Objects.isNull(INSTANCES))&#123;            synchronized (LazySingleton.class)&#123;                if(Objects.isNull(INSTANCES))&#123;                    INSTANCES = new LazySingleton();                &#125;            &#125;        &#125;        return INSTANCES;    &#125;    @Override    protected Object clone()&#123;        return getInstances();    &#125;&#125;</code></pre><p>在上面的代码中，我们这个代码中的次要部分，这些部分，主要是用来防止序列号、反射、和克隆的破坏，实际上，真正的代码是：</p><pre><code class="java">package designpatterns.singleton;import java.util.Objects;/** * 懒汉模式 * * 防止： *  1.并发 *  2.反射(防君子，不妨小人) *  3.克隆 * * @author shengouqiang * @date 2020/3/19 */public class LazySingleton&#123;    private static volatile LazySingleton INSTANCES;    private LazySingleton()&#123;    &#125;    public static LazySingleton getInstances()&#123;        if(Objects.isNull(INSTANCES))&#123;            synchronized (LazySingleton.class)&#123;                if(Objects.isNull(INSTANCES))&#123;                    INSTANCES = new LazySingleton();                &#125;            &#125;        &#125;        return INSTANCES;    &#125;&#125;</code></pre><p>OK，上面的这个就是懒汉模式下的单例最核心的代码。在这里，我会主要讲解懒汉式，至于其他的比较简单。</p><p><code>懒汉</code>，顾名思义，就是在真正我们要用到的时候才会去做这件事情，有点类似于现在的<code>拖延症</code>。它是在真正要用到单例实例的时候才会进行初始化操作。降低了内存的开销<span style="color:red;">(说句实话，真心觉得没啥用，纯粹是为了应付面试的一个优点)</span>。在这里，我们要注意的是<code>DCL</code>。这里的<code>DCL</code>是从一篇文章中学到的一个关键字，<code>DCL</code>的真实含义是<code>Double Check + volatile</code>。也就是说，在我们写懒汉模式下，我们要注意的一个步骤。</p><h3 id="为什么要使用Double-Check"><a href="#为什么要使用Double-Check" class="headerlink" title="为什么要使用Double Check"></a>为什么要使用Double Check</h3><p>在这里，我们要说明为什么要使用<code>Double Check</code>。这是因为，对于单例模式，我们要保证的是在我们的系统中，只能有一个实例。因此，在高并发的情况下，可能会出现多个实例的问题，不仅影响到内存的使用率，更有可能因为我们的业务代码的问题，导致一些隐藏的<code>bug</code>，很难被修复。</p><p>在这里，我们要进行逐步优化的优化</p><h4 id="无判断的getInstances"><a href="#无判断的getInstances" class="headerlink" title="无判断的getInstances"></a>无判断的getInstances</h4><pre><code class="java">    public static LazySingleton getInstances()&#123;              return INSTANCES = new LazySingleton();    &#125;</code></pre><p>我们可以发现，在这种情况下，如果有两个线程，都需要调用<code>getInstances</code>方法，则每次返回，都返回的是一个新的值。因此这种情况下，是肯定不行的。</p><p>那么接下来，我们家一层if判断，看下结果：</p><h4 id="只有一层if判断的getInstances"><a href="#只有一层if判断的getInstances" class="headerlink" title="只有一层if判断的getInstances"></a>只有一层if判断的getInstances</h4><pre><code class="java">    public static LazySingleton getInstances()&#123;        if(Objects.isNull(INSTANCES))&#123;            INSTANCES = new LazySingleton();        &#125;        return INSTANCES;    &#125;</code></pre><p>这种情况下，虽然可以保证在单线程的情况下，能够保证是单例模式的。但是在高并发下，依然会存在问题。我们可以通过下面的视频来进行讲解。</p><video id="video" controls="controls" controlslist="nodownload"  width="1000" height="480" preload="none" poster="https://shengouqiang.cn/img/video/fengmian1000480.jpg">      <source id="mp4" src="https://shengouqiang.cn/video/DesignPattern/SingletonPattern/singletonOneIf.mp4" type="video/mp4"></video><p>既然这样，涉及到高并发的问题，那么我们可以采用锁的方式</p><h4 id="单if-synchronized-方法"><a href="#单if-synchronized-方法" class="headerlink" title="单if+synchronized 方法"></a>单if+synchronized 方法</h4><pre><code class="java">    public static LazySingleton getInstances()&#123;        if(Objects.isNull(INSTANCES))&#123;            synchronized (LazySingleton.class)&#123;                INSTANCES = new LazySingleton();            &#125;        &#125;        return INSTANCES;    &#125;</code></pre><p>在这里，也有人会问，那为什么不直接将<code>synchronized</code>放入到<code>getInstances</code>方法上呢？首先这么做，也是可以结果多线程的并发问题，但是无论在什么时候，我们调用一次<code>getInstances</code>方法的时候，都要进行一次<code>加锁、释放锁</code>的操作。并且如果后续程序中出现<code>synchronized</code>的方法时候，还会造成阻塞的问题。</p><p>那么，如果是像上面的代码，仅仅只是锁代码块，会解决并发的问题吗？其实是解决不了的。在这里，我们还是通过一个动画的形式，进行讲解。</p><video id="video" controls="controls" controlslist="nodownload"  width="1000" height="480" preload="none" poster="https://shengouqiang.cn/img/video/fengmian1000480.jpg">      <source id="mp4" src="https://shengouqiang.cn/video/DesignPattern/SingletonPattern/SingletonOneIfSynchronized.mp4" type="video/mp4"></video><p>既然如此，我们在<code>synchronized</code>内再进行一次<code>if</code>判断，就可以实现并发情况下的单例模式：</p><h4 id="双if-synchronized-方法"><a href="#双if-synchronized-方法" class="headerlink" title="双if+synchronized 方法"></a>双if+synchronized 方法</h4><pre><code class="java">    public static LazySingleton getInstances()&#123;        if(Objects.isNull(INSTANCES))&#123;            synchronized (LazySingleton.class)&#123;                if(Objects.isNull(INSTANCES))&#123;                    INSTANCES = new LazySingleton();                &#125;            &#125;        &#125;        return INSTANCES;    &#125;</code></pre><p>通过上面的代码，我们可以实现，在并发的模式下，依然可以保证我们的<code>INSTANCES</code>是单例的。接下来，我们依然通过视频进行讲解。</p><video id="video" controls="controls" controlslist="nodownload"  width="1000" height="480" preload="none" poster="https://shengouqiang.cn/img/video/fengmian1000480.jpg">      <source id="mp4" src="https://shengouqiang.cn/video/DesignPattern/SingletonPattern/singletonTwoIfSynchronized.mp4" type="video/mp4"></video><p>至此，我们讲解了关于单例模式中<code>DCL</code>的中<code>DC</code>。接下来，我们讲解下<code>DCL</code>中的<code>L</code>。</p><h3 id="为什么要使用-volatile"><a href="#为什么要使用-volatile" class="headerlink" title="为什么要使用 volatile"></a>为什么要使用 volatile</h3><p>大致的讲，就是为了实现变量在多个线程之间的可见性，以及防止指令重排。在这里，我不会过多的进行讲解。我会在之后的文章中，单独用一篇文章进行讲解的。</p><h3 id="因序列化导致的单例失败"><a href="#因序列化导致的单例失败" class="headerlink" title="因序列化导致的单例失败"></a>因序列化导致的单例失败</h3><p>在之前的<code>懒汉式</code>单例模式的完成代码内，我们发现，有一部分代码是</p><pre><code class="java">    private Object readResolve()&#123;        return getInstances();    &#125;</code></pre><p>在这里，我们发现这段代码在<code>LazySingleton</code>中并没有被调用，那么为什么还要添加这段代码呢？这是因为，这段代码是为了方式在反序列化的时候，给<code>ObjectInputStream</code>进行调用的。</p><p>为什么要这么说呢？我们知道，当我们在将对象<code>序列化、反序列化</code>的时候，都是通过<code>ObjectInputStream/ObjectOutputStream</code>操作的。那么当我们反序列化的时候，会调用<code>readObject</code>方法。而反序列化一个对象在<code>ObjectStreamConstants</code>中的定义是<code>TC_OBJECT</code>，也就是<code>0x73</code>。此时会调用<code>readOrdinaryObject</code>方法。而在<code>readOrdinaryObject</code>方法中，会通过<code>reflect</code>，来检测当前的类中是否存在<code>readResolve</code>方法。如果存在，则直接返回我们重新的<code>readResolve</code>方法的返回值。</p><p>下面是这段源代码，如果有想要研究的同学，可以参考这段源代码：</p><pre><code class="java">        if (obj != null &amp;&amp;            handles.lookupException(passHandle) == null &amp;&amp;            desc.hasReadResolveMethod())        &#123;            Object rep = desc.invokeReadResolve(obj);            if (unshared &amp;&amp; rep.getClass().isArray()) &#123;                rep = cloneArray(rep);            &#125;            if (rep != obj) &#123;                handles.setObject(passHandle, obj = rep);            &#125;        &#125;</code></pre><p>因此，对于防止反序列化来破坏单例模式的方法，我们可以在我们的单例模式代码中，添加<code>readReslove</code>方法即可。</p><h3 id="因反射导致的序列化失败"><a href="#因反射导致的序列化失败" class="headerlink" title="因反射导致的序列化失败"></a>因反射导致的序列化失败</h3><p>对于反射破坏单例模式的问题，我这里仅仅只给出一个基本的方案。因此<code>reflect</code>实在是太强大了。无论怎么防止，程序员们都能够进行破坏。因此，在这里，我仅仅只是给出一个最简单的方式。也就是在程序中添加一个内置的计数器，每次在调用构造函数的时候，进行判断计数器是否大于1，如果大于1，则代表当前系统中已经存在当前实例。如果小于1，则可以通过构造函数进行获取。</p><p>正式因为反射模式的强大。因此，才说这种方式是一种<code>“防君子，不防小人”</code>的办法了。</p><h3 id="因克隆导致的序列化失败"><a href="#因克隆导致的序列化失败" class="headerlink" title="因克隆导致的序列化失败"></a>因克隆导致的序列化失败</h3><p>对于克隆破坏的单例模式，我们仅仅只需要实现<code>Cloneable</code>接口。然后直接调用<code>getInstances</code>方法返回即可。也就是下面的代码：</p><pre><code class="java">    @Override    protected Object clone()&#123;        return getInstances();    &#125;</code></pre><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>首先，我们先贴上代码</p><pre><code class="java">package designpatterns.singleton;import java.io.Serializable;/** * 饿汉模式 * * 防止： *  1.并发 *  2.反射(防君子，不妨小人) *  3.克隆 * * @author shengouqiang * @date 2020/3/19 */public class HungarySingleton implements Serializable,Cloneable &#123;    private static int loadCount = 0;    private HungarySingleton()&#123;        synchronized (HungarySingleton.class)&#123;            if(loadCount &lt; 1)&#123;                loadCount++;            &#125;else&#123;                throw new RuntimeException(&quot;HungarySingleton 已被加载过，请直接调用getInstances处理&quot;);            &#125;        &#125;    &#125;    private Object readResolve()&#123;        return getInstances();    &#125;    private static class  HungarySingletonHolder &#123;        private static final HungarySingleton INSTANCES = new HungarySingleton();        private HungarySingletonHolder()&#123;        &#125;    &#125;    public static HungarySingleton getInstances() &#123;        return HungarySingletonHolder.INSTANCES;    &#125;    @Override    protected Object clone()&#123;        return getInstances();    &#125;&#125;</code></pre><p>对于<code>饿汉</code>模式而言，他的单例是通过<code>JVM</code>对于一个class仅加载一次来进行保证的。至于具体的内部细节，我会在后期的<code>jvm</code>章节进行讲解。我们在这里，只需要知道，当<code>jvm</code>的<code>ClassLoader</code>加载一个<code>class</code>后，会自动的初始化静态变量。虽然这么说不是十分的严谨，但是对于理解<code>饿汉</code>模式已经足够了。因此，在<code>懒汉</code>和<code>饿汉</code>模式中，相比较而言，<code>饿汉</code>模式是比较简单的。也是比较推荐的一种。</p><p>而这里之所以采用匿名内部类，是因为应付有些面试的时候，说<code>饿汉</code>模式的情况下，我都不需要使用这个单例，但是你还是加载到内存里面的一种<code>吹毛求疵</code>的问题。</p><p>至于<code>反射</code>、<code>序列化</code>和<code>克隆</code>的讲解，和<code>懒汉模式相同</code>，在这里不再过多的赘述了。</p><h2 id="Effective-Java中用enum实现"><a href="#Effective-Java中用enum实现" class="headerlink" title="Effective Java中用enum实现"></a>Effective Java中用enum实现</h2><p>首先，我们先贴上代码</p><pre><code class="java">package designpatterns.singleton;import java.io.Serializable;/** * 枚举模式 * * @author shengouqiang * @date 2020/3/19 */public enum EnumSingleton&#123;    INSTANCES;    public static EnumSingleton getInstances()&#123;        return INSTANCES;    &#125;&#125;</code></pre><p>对于这种写法，是<code>Effective Java</code>的作者推荐的一种写法。对于这种写法，因为<code>enum</code>的原因，天生的提供了<code>反射</code>、<code>序列化</code>、<code>克隆</code>的手法来放着程序创建多个实例。</p><p>但是这种写法比较的让人迷惑，因为我们想要的是一个单例模式，是一个类，而这样做，把我们的单例变成了一个枚举，就感觉别扭。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习--HashMap详解(put操作)</title>
      <link href="//Java/JDK/HashMap/JDKHashMapLearnDay02/"/>
      <url>//Java/JDK/HashMap/JDKHashMapLearnDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="Java学习–HashMap详解-put操作"><a href="#Java学习–HashMap详解-put操作" class="headerlink" title="Java学习–HashMap详解(put操作)"></a>Java学习–HashMap详解(put操作)</h1><p>在上一篇文章中，我们讲解了关于<code>HashMap</code>的构造函数，如有不了解的，可以查看<a href="/Java/JDK/HashMap/JDKHashMapLearnDay02">Java学习–HashMap详解(构造函数)</a>。在本节内容中，我们主要讲解下关于<code>HashMap</code>的<code>put</code>操作。</p><p>首先我们先看下源码：</p><h2 id="put操作源码"><a href="#put操作源码" class="headerlink" title="put操作源码"></a>put操作源码</h2><pre><code class="java">    /**     * Associates the specified value with the specified key in this map.     * If the map previously contained a mapping for the key, the old     * value is replaced.     *     * @param key key with which the specified value is to be associated     * @param value value to be associated with the specified key     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)     */    public V put(K key, V value) &#123;        return putVal(hash(key), key, value, false, true);    &#125;</code></pre><p>通过上面的代码，我们发现其实没有什么好看的。主要是要看它调用的<code>putVal</code>方法和<code>hash</code>方法。关于注释，我们都能看懂，如果看不懂的，请直接进行<a href="https://translate.google.com/">谷歌翻译</a>。</p><p>首先，我们先来看下<code>hash</code>方法</p><h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><pre><code class="java">    /**     * Computes key.hashCode() and spreads (XORs) higher bits of hash     * to lower.  Because the table uses power-of-two masking, sets of     * hashes that vary only in bits above the current mask will     * always collide. (Among known examples are sets of Float keys     * holding consecutive whole numbers in small tables.)  So we     * apply a transform that spreads the impact of higher bits     * downward. There is a tradeoff between speed, utility, and     * quality of bit-spreading. Because many common sets of hashes     * are already reasonably distributed (so don&#39;t benefit from     * spreading), and because we use trees to handle large sets of     * collisions in bins, we just XOR some shifted bits in the     * cheapest possible way to reduce systematic lossage, as well as     * to incorporate impact of the highest bits that would otherwise     * never be used in index calculations because of table bounds.     */    static final int hash(Object key) &#123;        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    &#125;</code></pre><p>乍一看，感觉很简单。没有什么特别的地方。但是实际上，这个里面我们要掌握的东西还是有的。我们学习源码的过程，不仅仅只是作为一个<code>Reader</code>进行读一遍就可以了。我们要做的，更多的是要学习他们为什么要这么做？这么做有什么好处？能够运用到现在的工作中？如果以后自己设计系统，能不能想到这样的处理方式？这个才是我们学习源码的目的。</p><p>不知不觉，又讲了一堆的废话。我们还是回归正题，看下为什么<code>HashMap</code>中要自定义一个<code>hash</code>方法，而不是采用操作系统自带的<code>hash</code>方法，来获取<code>Key</code>的<code>hashcode</code>。</p><p>通过上面的注释，我们发现，<code>HashMap</code>之所以这样做，是采用一种最简单的方式来让我们的值在<code>Array</code>中更加均匀的分布的。主要的做法是</p><ol><li>如果<code>key</code>为<code>null</code>,则放在<code>第0位</code></li><li>如果<code>key</code>不为<code>null</code>,则调用系统的<code>hashCode</code>方法，获取<code>hash</code>值</li><li>将当前获取的<code>hash</code>值<code>右移16</code>位，然后与当前<code>hashcode</code>进行<code>异或</code>操作</li></ol><p>在这里，这个<code>hash</code>函数，其实就是一个扰动函数，为什么这么说呢？因为如果在这里我们直接以<code>hashCode</code>作为我们的散列特征的情况下，那么就会有一个问题，假如我们的<code>Array</code>的大小是<code>16</code>的话，那么真正能够起到的作用的，其实也就是<code>hashCode</code>的低位，而高位直接被屏蔽掉<span style="color:red;">(为什么会这样，在下面讲解index的时候会说)</span>。如果我们有一批数据，正好这些数据的<code>hashCode</code>的低位是相似的或者是很相同的，而高位的差别很大，在采用这样的方式进行获取<code>index</code>的时候，此时会发生极大的<code>hash碰撞</code>，极大的降低了<code>HashMap</code>的一个性能。因此，我们采用将一个<code>hashCode</code>的<code>高16位</code>与<code>低16位</code>进行<code>异或</code>的方式，使得到的一个最终的<code>hash</code>值更加随机，相当于间接的保留了部分<code>hashCode的高16位</code>的一个特征。可以极大的避免上述的问题，起到了干扰的作用。</p><p>这是因为这样的情况，可以保证<code>HashMap</code>的一个均匀分布的结果。</p><h2 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h2><pre><code class="java">    /**     * Implements Map.put and related methods     *     * @param hash hash for key     * @param key the key     * @param value the value to put     * @param onlyIfAbsent if true, don&#39;t change existing value     * @param evict if false, the table is in creation mode.     * @return previous value, or null if none     */    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;    &#125;</code></pre><p>上面的代码就是在<code>JDK1.8</code>中的<code>HashMap</code>中的<code>put</code>的真实操作。在这里，我们主要从三个方面进行讲解</p><ol><li><code>index</code>的确定</li><li>为什么<code>Array</code>的容量是2<sup>n</sup>（作用一）。</li><li><code>resize</code><ol><li><code>resize</code>的原理</li><li>为什么<code>Array</code>的容量是2<sup>n</sup>（作用二）。</li><li><code>resize</code>何时会发生</li></ol></li><li>当发生<code>hash碰撞</code>时的处理操作<ol><li>链表操作</li><li>链表转树</li><li>树转链表</li><li>树操作</li></ol></li></ol><p>其中关于树的部分，我会单独拉出一篇文章进行讲解，在这里不做过多的阐述。我们这篇文章主要是从1、2、3.1这三个部分进行讲解。</p><h3 id="index的确定"><a href="#index的确定" class="headerlink" title="index的确定"></a>index的确定</h3><p>首先，我们看下关于<code>index</code>的一个确定的操作。这个操作和之前第二部分的<code>hash</code>方法的原理有关。同时，也可以让你更加的理解，为什么<code>HashMap</code>要用自己的<code>hash</code>方法。</p><p>在上述的源码中，真正确定<code>index</code>的，只有一句话<code>(n - 1) &amp; hash</code>。注意，这里的<code>hash</code>就是第二部分我们计算出的真实的<code>hash</code>值。而n这是获取<code>Array</code>的长度，如果<code>Array</code>为<code>null</code>，则会先进行<code>resize</code>操作，初始化<code>Array</code>。然后获取<code>Array</code>的长度。</p><p>初看这段代码，我们会发现，就是一个<span style="color:red;">与(&amp;)</span>操作。获取<code>index</code>就可以了。如果是这样的话，那么我们有几个问题?</p><ol><li>既然我们获取到数组的长度为<code>n</code>了，那么为什么还要进行<code>n-1</code>操作呢？这不是始终要空出一个<code>index</code>，降低了使用效率吗？</li></ol><p>我们首先来解答第二个疑问，为什么要进行<code>n-1</code>操作。其实，这个就是要说的关于为什么<code>Array</code>的容量必须要为2<sup>n</sup>的一个原因。这里面主要涉及到了二级制的一个操作。下面我们举个例子，说明下：</p><p>因为在之前，我们已经确定了，<code>HashMap</code>的<code>Array</code>的<code>size</code>大小一定是2<sup>n</sup>。此时我们假设我们的数组的大小是<code>16</code>。而<code>16</code>的二进制是<code>0001 0000</code>。此时，当进行<code>n-1</code>时，此时变成<code>15</code>，对应的二进制为<code>0000 1111</code>。此时我们发现，当我们与<code>hash</code>进行<span style="color:red;">与(&amp;)</span>操作，也就是在仅仅保留<code>hashcode</code>的<code>最后四位</code>2进制数，转成10进制，便是当前元素要存在数组中的下标。因此，在这里，我们先解释一部分为什么<code>Array</code>的数组长度是2<sup>n</sup>。通过也解释了<span style="color:red;">与(&amp;)</span>的作用。这这样做的目的，主要的根本原因还是因为，计算机操作2进制是最快的。这样写，是能够更好的提升性能的。</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>原本打算，将<code>resize</code>单独抽出来，当做一篇文章进行讲解的。但是后来想了想，还是决定放在<code>put</code>操作进行讲解。因为在<code>resize</code>主要是在<code>put</code>中进行的。接下来，我们看下<code>resize</code>的源码原理。</p><p>废话不多说，我们先看下<code>resize</code>的源码</p><pre><code class="java">    /**     * Initializes or doubles table size.  If null, allocates in     * accord with initial capacity target held in field threshold.     * Otherwise, because we are using power-of-two expansion, the     * elements from each bin must either stay at same index, or move     * with a power of two offset in the new table.     *     * @return the table     */    final Node&lt;K,V&gt;[] resize() &#123;        Node&lt;K,V&gt;[] oldTab = table;        int oldCap = (oldTab == null) ? 0 : oldTab.length;//获取原始Array大小        int oldThr = threshold;   //旧的阈值        int newCap, newThr = 0;        //扩容处理        if (oldCap &gt; 0) &#123;  //如果Array已经超过了最大值，则将阈值设置为Int类型最大值，且数组不再扩容            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;                threshold = Integer.MAX_VALUE;                return oldTab;            &#125;            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)  //如果扩容后数组小于最大值，且原始Array大于16，                                                           //则将新的阈值扩大一倍                newThr = oldThr &lt;&lt; 1; // double threshold        &#125;        //这里对应的调用 public HashMap(int initialCapacity) 构造函数，此时经过数据洗涤，        //oldThr=threshold大于等于initialCapacity的2的N次方。        //这里主要是进行Map的初始化。设置Array的容量        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;        else &#123;               // zero initial threshold signifies using defaults            //这里对应的调用 public HashMap() 构造函数            //此时 oldCap 与 oldThr 均为0。            //这里主要是进行Map的初始化。设置Array的容量            newCap = DEFAULT_INITIAL_CAPACITY;            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);        &#125;        //这里主要针对以下情况        //    1.如果是初始化 public HashMap(int initialCapacity) ，这是newThr为 newCap * loadFactor        if (newThr == 0) &#123;            float ft = (float)newCap * loadFactor;            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        &#125;        //设置阈值        threshold = newThr;        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        //创建一个2倍原大小的Array        table = newTab;        //这里的if指的是扩容的情景        if (oldTab != null) &#123;            for (int j = 0; j &lt; oldCap; ++j) &#123;                Node&lt;K,V&gt; e;                if ((e = oldTab[j]) != null) &#123;                    oldTab[j] = null;                    //获取index=j的元素，此时如果array[j]既不为树，也不是链表，则直接将array[j]的元素移动到                    //新的位置                    if (e.next == null)                        newTab[e.hash &amp; (newCap - 1)] = e;                    //对于树进行操作                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    else &#123; // preserve order                        //链表的操作                        Node&lt;K,V&gt; loHead = null, loTail = null; //当index为偶数时的节点处理                        Node&lt;K,V&gt; hiHead = null, hiTail = null; //当index为奇数时的节点处理                        Node&lt;K,V&gt; next;                        do &#123;                            next = e.next;                            if ((e.hash &amp; oldCap) == 0) &#123;                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            &#125;                            else &#123;                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            &#125;                        &#125; while ((e = next) != null);                        if (loTail != null) &#123;                            loTail.next = null;                            newTab[j] = loHead;                        &#125;                        if (hiTail != null) &#123;                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        &#125;                    &#125;                &#125;            &#125;        &#125;        return newTab;    &#125;</code></pre><p>没错，上面的这些就是<code>resize</code>的源码。</p><p>要解释上面的代码，还需要我们对于二进制有一定的基础支持。接下来，我们通过列举的方式，来进行讲解。</p><ol><li>如果当前<code>Array</code>的长度已经达到最大值，则不再进行扩容，直接返回，以后再<code>put</code>，也不再扩容，最坏的情况是不停的<code>hash碰撞</code>。</li><li>如果是在执行<code>public HashMap(int initialCapacity</code>与<code>public HashMap()</code>后直接执行<code>put</code>操作，此时会直接执行<code>resize</code>方法，目的不是为了扩容，而是为了进行<code>Array</code>的初始化。</li><li>如果进入到<code>if (oldTab != null)</code>判断里面后，则进行的是扩容操作，在这里，主要是分成了三种情况：<ul><li>如果当前<code>Node</code>仅仅只是一个节点，既不是链表，也不是红黑树，则扩容后的位置有两种情况：<ul><li>如果当前的 <code>e.hash &amp; oldCap - 1</code>为<code>0</code>，则扩容后依然放在<code>0</code>号位置，或<code>oldCap</code>的位置</li><li>如果当前的 <code>e.hash &amp; oldCap - 1</code>不为<code>0</code>，为j，则扩容后的位置是<code>j + oldCap</code>。</li></ul></li><li>如果当前节点为红黑树，则直接对红黑树进行操作。<span style="color:red;">(这里不再进行多余的讲解，在后面有单独的文章讲解红黑树)</span>。</li><li>如果当前节点为链表，则依然判断<code>e.hash &amp; oldCap</code>是否为<code>0</code>，如果是，则存放在<code>index=j</code>的节点，如果不是，则存放在<code>j+oldCap</code>的节点。</li></ul></li></ol><p>之所以这样，是因为在扩容后比扩容前，<code>Array</code>的数组扩大了一倍，假如之前是<code>16</code>，则<code>16-1</code>的二进制是<code>0000 1111</code>。扩容后，<code>Array</code>为<code>32</code>，则<code>32-1</code>的二进制是<code>0001 1111</code>。多出来的那个<code>1</code>。正好是<code>oldCap</code>的值。因此，这也就是第二种情况下，为什么<code>Array</code>的容量是2<sup>n</sup>。</p><h3 id="哈希碰撞的解决-链表相关"><a href="#哈希碰撞的解决-链表相关" class="headerlink" title="哈希碰撞的解决(链表相关)"></a>哈希碰撞的解决(链表相关)</h3><p>接下来，我们主要讲解下，<code>putVal</code>的操作。</p><p>我们大致说下处理的过程，首先是通过上面的讲解，确定<code>index</code>的位置：</p><ol><li>如果<code>Array[index]</code>为null，则直接将当前节点放入到<code>Array[index]</code>中。</li><li>如果<code>Array[index]</code>不为null,且type为<code>TreeNode</code>，则直接进行红黑树操作。</li><li>如果当前节点是链表结构，则判断当前<code>key</code>是否存在在<code>HashMap</code>中，如果存在，将新值替换掉旧值。</li><li>如果当前节点是链表结构，如果<code>HashMap</code>中不存在当前<code>Key</code>，则将当前<code>Value</code>放到链表的尾结点，若长度+1满足<code>TREEIFY_THRESHOLD</code>，则直接将链表转为红黑树。</li><li>判断当前<code>HashMap</code>中，新增/修改<code>value</code>值的操作的次数。</li><li>判断当前<code>HashMap</code>是否超过阈值，如果操作，则进行扩容操作</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们主要讲解了关于<code>HashMap</code>的<code>put</code>操作，以及<code>resize</code>操作。同时，也从代码的层面上讲解了关于为什么<code>Array</code>的容量是2<sup>n</sup>。同时，对于一个<code>value</code>值是如何确定<code>index</code>的，以及为什么要有<code>扰动函数</code>的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习--HashMap详解(构造函数)</title>
      <link href="//Java/JDK/HashMap/JDKHashMapLearnDay01/"/>
      <url>//Java/JDK/HashMap/JDKHashMapLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java学习–HashMap详解-构造函数"><a href="#Java学习–HashMap详解-构造函数" class="headerlink" title="Java学习–HashMap详解(构造函数)"></a>Java学习–HashMap详解(构造函数)</h1><p>在<code>JDK</code>的使用过程当中，我们经常要用到的莫过于集合类型了。而在集合类型当中，我们更加注重的是<code>Map</code>这个集合。因此，在接下来的一段时间内，我主要讲解Map中的经典实现(<code>HashMap</code>)的源码分析、出现并发的情况、以及与<code>ConcurrentHashMap</code>的区别。因为本文章不知道读的人的水平如何，因此，我尽量采用通俗易懂+图文结合的方式，来讲解<code>HashMap</code>的源码，在这个系列的最后，我们我们会列出来关于不同的<code>JDK</code>的版本对于<code>HashMap</code>的一个改动。</p><p>本次我们主要讲解的<code>HashMap</code>是在<code>JDK1.8</code>版本的。</p><p><img src="https://shengouqiang.cn/img/Java/JDK/DAY01/java-version.jpg" alt="Java版本信息"></p><p>接下来，我们在这篇文章主要讲解的是<code>HashMap</code>的构造函数。</p><p>在<code>HashMap</code>中，<code>HashMap</code>一共有四个构造函数，接下来，我们逐一进行讲解。</p><h2 id="负载因子-loadFactor"><a href="#负载因子-loadFactor" class="headerlink" title="负载因子(loadFactor)"></a>负载因子(loadFactor)</h2><p>首先，在讲解无参构造函数之前，我们先来讲解下为什么在<code>JDK</code>的官方源码中，将<code>HashMap</code>的负载因子设置为<code>0.75</code>。</p><p>首先，我们知道，在计算机的运行过程中，我们主要注重的是两个问题，一个是希望我们的程序尽可能的运行的快。另一个，我们希望我们程序在运行的过程中，尽可能的少消耗我们的内存。这个就是计算机中评判一个程序经常用到的两个维度，<code>时间复杂度</code>和<code>空间复杂度</code>。在实际的程序运行过程中，我们不可能同时将这两个标准都优化到极致，因此在很多的程序，对于这两个标准，会根据实际的业务需求，采用以下三种方案进行开发：</p><ul><li>牺牲程序的时间复杂度，尽可能的降低程序的空间复杂度</li><li>牺牲程序的空间复杂度，尽可能的降低程序的时间复杂度</li><li>综合考虑程序的时间复杂度和空间复杂度，在这两者中，选择一个折中平衡点</li></ul><p>而在<code>JDK</code>的<code>HashMap</code>中，就是采用了第三种方案，经过了无数的证明与总结，人们发现，当负载因子为<code>0.75</code>的时候，此时程序的效率最高。因此，在<code>JDK</code>的源码中，将<code>HashMap</code>的默认负载因子设置成了<code>0.75</code>。</p><p>上面我们讲解了这么多，又是<code>负载因子</code>，又是<code>时间复杂度</code>，又是<code>空间复杂度</code>的。那么在<code>HashMap</code>中，这些含义到时是干什么用的呢？其实，我们都知道，对于<code>HashMap</code>而言，他就是一个集合。那么对于集合，一定要提供两个功能 –&gt; <code>“读取”</code>和<code>“存储”</code>。 既然要存储和读取，那么我们关心的其实就是两个问题:</p><ul><li>是否足够快</li><li>是否省内存</li></ul><p>对于<code>JDK</code>而言，在保证效率的同时，势必要进行内存的无休止消耗。因此在两者之间做了一个权衡，也就是所谓的<code>0.75</code>的存在了。而这个数值的存在，也是在大量的试验下的出的一个最优解。</p><h2 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h2><pre><code class="java">    /**     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity     * (16) and the default load factor (0.75).     */    public HashMap() &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted    &#125;</code></pre><p>我们首先来看下我们的最最常用的无参构造函数。该函数仅仅只是设置了程序的默认负载因子，也就是上文提到的<code>0.75</code>。并没有去进行<code>Array</code>的初始化操作。</p><h2 id="仅设置初始容量的构造函数"><a href="#仅设置初始容量的构造函数" class="headerlink" title="仅设置初始容量的构造函数"></a>仅设置初始容量的构造函数</h2><pre><code class="java">    /**     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial     * capacity and the default load factor (0.75).     *     * @param  initialCapacity the initial capacity.     * @throws IllegalArgumentException if the initial capacity is negative.     */    public HashMap(int initialCapacity) &#123;        this(initialCapacity, DEFAULT_LOAD_FACTOR);    &#125;</code></pre><p>在这里，我们发现，它调用了另外的一个构造函数，至于在这个构造函数值的操作，不要着急，我们在下个构造函数中进行操作。我们发现，当我们使用这个构造函数的时候，我们可以指定默认的<code>Array</code>的大小，只不过这个大小会进行清洗，让它变成最接近于2<sup>n</sup>，且该值要大于等于我们设置的默认<code>Array</code>的大小，至于是怎么进行操作的，在此先卖个关子，在下面我们会进行着重讲解。同时，我们发现，在默认的情况下，此时默认的负载因子为<code>0.75</code>。</p><h2 id="设置初始容量和负载因子的构造函数"><a href="#设置初始容量和负载因子的构造函数" class="headerlink" title="设置初始容量和负载因子的构造函数"></a>设置初始容量和负载因子的构造函数</h2><pre><code class="java">    /**     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial     * capacity and load factor.     *     * @param  initialCapacity the initial capacity     * @param  loadFactor      the load factor     * @throws IllegalArgumentException if the initial capacity is negative     *         or the load factor is nonpositive     */    public HashMap(int initialCapacity, float loadFactor) &#123;        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        this.threshold = tableSizeFor(initialCapacity);    &#125;</code></pre><p>接下来，是我们最最重要的一个构造函数了。这个构造函数我们可以同时指定<code>Array</code>的大小和负载因子的比例。只不过，在这里要强调一点的是，默认情况下，我们可以改变<code>Array</code>的大小，但是对于负载因子，除了特殊的情况外，我们一般用默认值即可。</p><p>接下在，我们看下上面的代码，我们发现，<code>Array</code>的最大的大小为<code>2&lt;&lt;30</code>(<code>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>)。要解释为什么是2<sup>30</sup>呢？通过代码我们可以发现：</p><ul><li>因为int是4个字节，代表了32位，又因为第一位代表的是<code>+/-</code>。所以，只能是2<sup>30</sup>了。</li><li>同时，为什么要使用<code>int</code>，而不是使用<code>byte、short、long</code>等类型呢？其实，这个是为了系统的性能考虑，做的一个折中的处理。</li></ul><p>接下来，就是最重要的一步。对于我们传入的初始<code>Array</code>大小<code>initialCapacity</code>，此时会传入<code>tableSizeFor</code>方法中，并且将返回的结果返回给<code>threshold</code>。通过这里，我们发现，<code>HashMap</code>并没有使用我们直接传入的初始容量，而是在进行一系列的运算后，才最终确定我们最终的<code>Array</code>的大小的。</p><h3 id="tableSizeFor-方法"><a href="#tableSizeFor-方法" class="headerlink" title="tableSizeFor 方法"></a>tableSizeFor 方法</h3><p>接下来，我们看下<code>tableSizeFor</code>这个方法的源码。</p><pre><code class="java">    static final int tableSizeFor(int cap) &#123;        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    &#125;</code></pre><p>在讲解上面的代码之前，我们要知道<code>&gt;&gt;&gt;</code>方法的含义</p><h4 id="gt-gt-gt-含义"><a href="#gt-gt-gt-含义" class="headerlink" title="&gt;&gt;&gt; 含义"></a>&gt;&gt;&gt; 含义</h4><p><code>&gt;&gt;&gt;表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0</code></p><p>接下来，我们说下，<code>n | n -1</code>的含义。在这里<code>|</code>是<code>或</code>的含义。我们举个例子:</p><pre><code>1001 | 0101 = 1101 </code></pre><p>接下来，我们看下，在<code>HashMap</code>中，是如果将一个数洗成一个2<sup>n</sup>的。</p><p>此时，我们假设<code>cap</code>为<code>7944525</code>。此时对应的二进制为<code>0111 1001 0011 1001 0100 1101</code>。接下来，我们手动进行计算：</p><pre><code>n = 0111 1001 0011 1001 0100 1101            最原始值n &gt;&gt;&gt; 1 = 0011 1100 1001 1100 1010 0110此时我们计算 n | n &gt;&gt;&gt; 1 的结果为：n | n &gt;&gt;&gt; 1 = 0111 1101 1011 1101 1100 1111此时我们的n 也就变成了 0111 1101 1011 1101 1100 1111接下来，我们计算 n &gt;&gt;&gt; 2此时 n &gt;&gt;&gt; 2 的结果为: 0001 1111 0110 1111 0111 0011此时 n | n &gt;&gt;&gt; 2 的结果为：0111 1111 1111 1111 1111 1111接下来，以此类推，我们通过每次的运算结果与 最原始值 进行观察，我们发现，这样做的目的，是为了让 最原始值中的1的后X位于1进行或，就可以得到结果：最后，我们用我们得出的结论与上面的结果进行验证：n = 0111 1001 0011 1001 0100 1101n | n &gt;&gt;&gt; 1 = 0111 1101 1011 1101 1100 1111n | n &gt;&gt;&gt; 2 = 0111 1111 1111 1111 1111 1111n | n &gt;&gt;&gt; 4 = 0111 1111 1111 1111 1111 1111n | n &gt;&gt;&gt; 8 = 0111 1111 1111 1111 1111 1111n | n &gt;&gt;&gt;16 = 0111 1111 1111 1111 1111 1111</code></pre><p>此时，我们得到 <code>n+1 = 8388608</code>。也就是2<sup>23</sup>。</p><p>接下来，我们以<code>cap=14669</code>进行举例，我们直接以上面的结论进行计算：</p><pre><code>n = 0011 1001 0100 1101n | n &gt;&gt;&gt; 1 = 0011 1101 1110 1111n | n &gt;&gt;&gt; 2 = 0011 1111 1111 1111n | n &gt;&gt;&gt; 4 = 0011 1111 1111 1111n | n &gt;&gt;&gt; 8 = 0011 1111 1111 1111n | n &gt;&gt;&gt;16 = 0011 1111 1111 1111</code></pre><p>此时<code>n+1=16384</code>。也就是2<sup>14</sup>。通过上面的两个例子，我们发现，当<code>HashMap</code>拿到一个值后，首先对值进行<code>减1</code>操作，然后将值进行清洗，让2进制的值，从又开始遇到的<code>第一个1</code>开始，后面都清洗成<code>1</code>。最后在将<code>减去的1加回去</code>，变成2<sup>n</sup>。</p><p><code>HashMap</code>正是通过这样的做法，保证了我们的<code>Array</code>的数组大小为2<sup>n</sup>。至于为什么一定要是2<sup>n</sup>，这个在后续的文章中会进行讲解的。</p><h2 id="以Map进行初始化的构造函数"><a href="#以Map进行初始化的构造函数" class="headerlink" title="以Map进行初始化的构造函数"></a>以Map进行初始化的构造函数</h2><pre><code class="java">    /**     * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the     * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with     * default load factor (0.75) and an initial capacity sufficient to     * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.     *     * @param   m the map whose mappings are to be placed in this map     * @throws  NullPointerException if the specified map is null     */    public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    &#125;</code></pre><p>对于这个构造函数，在实际的工作中，我们用到的不多，在<code>putMapEntries</code>中，主要是进行了<code>resize()</code>操作与<code>putVal()</code>操作，这个会在后续的文章中进行讲解。至于代码中其他的部分，十分的简单，都是利用了本文所讲解的内容，在这里不再进行额外的赘述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于<code>HashMap</code>的构造函数，我们知道了以下几点信息</p><ul><li><code>HashMap</code>提供了四种构造函数，至于他们之前的原理，请参考上面的文章</li><li>对于负载因子为什么是<code>0.75</code>,在上文中进行了讲解。</li><li>对于<code>HashMap</code>中<code>Array</code>的最大容量为<code>1&lt;&lt;30</code>，我们也进行了讲解</li><li>对于<code>HashMap</code>中，是如果将一个随意的初始容量洗成2<sup>n</sup>，在上面的文章中进行了讲解。</li></ul><p>学无止境，只有不断的学习，才能配得上更好的自己。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql--隔离级别</title>
      <link href="//mysql/MySqlLearnDay01/"/>
      <url>//mysql/MySqlLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql–隔离级别"><a href="#MySql–隔离级别" class="headerlink" title="MySql–隔离级别"></a>MySql–隔离级别</h1><p>在我们日常开发的过程中，我们经常要用到<code>Oracle</code>和<code>MySql</code>数据库。但是目前也仅仅只是在用的阶段而已。对于数据库的学习，现在想达到知其然，知其所以然的地步。在这里，我们以这篇文章作为开头，进行研究。</p><p>在讲解数据库的隔离级别前，我们需要了解下关于数据库的各种问题：</p><ol><li>脏读</li><li>不可重复读</li><li>幻读</li></ol><p>正是对应要解决这三种问题，数据库给出了对应的解决方案，就是数据库的隔离级别：</p><ol><li>读未提交</li><li>读已提交</li><li>可重复度</li><li>串行化</li></ol><h2 id="脏读与读未提交"><a href="#脏读与读未提交" class="headerlink" title="脏读与读未提交"></a>脏读与读未提交</h2><p>我们首先说下什么是脏读：</p><blockquote><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</p></blockquote><p>要验证<code>脏读</code>与<code>读未提交</code>这个特性。我们首先需要两个session去连接相同的数据库。并且将这两个<code>session</code>的隔离级别设置为<code>READ UNCOMMITTED</code>。为了方便接下来的讨论，我们将两个session分别命名为<code>session1</code>和<code>session2</code>。</p><p>接下来，我们看下<code>session1</code>的执行<code>sql</code>：</p><pre><code class="sql">SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;select @@tx_isolation;</code></pre><p>同理，我们将<code>session2</code>也进行上面的设置。此时<code>session1</code>和<code>session2</code>的隔离级别都是<code>读未提交</code>。</p><p>接下来，我们创建一个<code>test</code>表。表中仅有一个字段：<code>id</code>。</p><pre><code class="sql">create table test(    id int);</code></pre><p>此时我们查询下表：</p><pre><code class="sql">select * from test;</code></pre><p>执行结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest01.jpg" alt="查询test表"></p><p>接下来，我们在<code>session1</code>中执行如下的<code>SQL</code>语句</p><pre><code class="sql">insert into test (id)value (1);</code></pre><p>执行结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/testinsert01.jpg" alt="test表执行insert语句"></p><p>此时，我们在<code>session2</code>中执行如下<code>SQL</code>语句：</p><pre><code class="sql">select * from test;</code></pre><p>执行结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest02.jpg" alt="test表执行select语句"></p><p>此时我们发现，在<code>session2</code>中，可以查到<code>session1</code>中插入但是还没有<code>commit</code>的<code>SQL</code>语句。这样的情况，就是<code>脏读</code>的情况。而这个也正是<code>读未提交</code>隔离级别所带来的问题。有了上面的演示，此时我们可以很好的理解什么是<code>脏读</code>了。</p><p>那么为了避免这个问题，我们需要将我们的数据库隔离级别提高，将数据库的隔离级别设置为：<code>读已提交</code>。但是<code>读已提交</code>还是有会新的问题，那就是<code>不可重复读</code>。</p><h2 id="不可重复读与读已提交"><a href="#不可重复读与读已提交" class="headerlink" title="不可重复读与读已提交"></a>不可重复读与读已提交</h2><h3 id="脏读问题是否解决"><a href="#脏读问题是否解决" class="headerlink" title="脏读问题是否解决"></a>脏读问题是否解决</h3><p>既然我们将隔离级别从<code>读未提交</code>升级到<code>读已提交</code>。此时，我们看下是否已经解决了<code>脏读</code>的问题。</p><p>还是上面的例子，此时我们在<code>session2</code>中开启事务，然后查询<code>test</code>表，结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest05.jpg" alt="test表执行select语句"></p><p>此时在<code>session1</code>中插入一条记录：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/testinsert02.jpg" alt="test表执行insert语句"></p><p>此时<code>session2</code>再次查询的结果为：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest06.jpg" alt="test表执行select语句"></p><p>通过上面的例子，我们发现，<code>读已提交</code>已经克服了<code>脏读</code>的问题。</p><h3 id="什么是不可重复读问题"><a href="#什么是不可重复读问题" class="headerlink" title="什么是不可重复读问题"></a>什么是不可重复读问题</h3><p>我们首先说下什么是不可重复读：</p><blockquote><p>在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据并修改数据。那么，在第一个事务的两次读数据之间。由于另一个事务的修改，那么第一个事务两次读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复</p></blockquote><p>接下来，我们还是进行演示，什么是<code>不可重复读</code>。</p><p>跟上面的例子一下，我们将我们的<code>session1</code>和<code>session2</code>的隔离级别改为<code>READ COMMITTED</code>。执行<code>SQL</code>如下：</p><pre><code class="sql">SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></pre><p>我们先在<code>session2</code>中，先开启事务，然后查询一次<code>test</code>表:</p><pre><code class="sql">select * from test;</code></pre><p>此时，我们的查询结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest03.jpg" alt="test表执行select语句"></p><p>接下来，我们在<code>session1</code>中将<code>test</code>表中的<code>id</code>改为2，然后提交事务：</p><pre><code class="sql">update  test set id=2 ;</code></pre><p>然后，我们在<code>session2</code>中重新进行查询,注意，此时还没有提交事务</p><pre><code class="sql">select * from test;</code></pre><p>此时，我们的查询结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest04.jpg" alt="test表执行select语句"></p><p>果然，我们发现，在<code>session2</code>这个事务执行的过程中，因为有<code>session</code>1将<code>tes</code>t表的<code>id</code>改为了2，此时在<code>session2</code>这同一个事务中，会出现两次查询结果不一致的情况，也就是第一次查询的结果为1，第二次查询的结果为2。这个就是<code>不可重复读</code>。为了解决不可重复读的问题，接下来，我们讨论下<code>可重复读</code>这个隔离级别。</p><p>这里补充一下，<code>Oracle</code>默认的数据库隔离级别就是<code>读已提交</code>。</p><h2 id="幻读与可重复读"><a href="#幻读与可重复读" class="headerlink" title="幻读与可重复读"></a>幻读与可重复读</h2><h3 id="可重复读是否解决了不可重复读问题"><a href="#可重复读是否解决了不可重复读问题" class="headerlink" title="可重复读是否解决了不可重复读问题"></a>可重复读是否解决了不可重复读问题</h3><p>既然我们将隔离级别从<code>读已提交</code>升级到<code>可重复读</code>。此时，我们看下是否已经解决了<code>不可重复读</code>的问题。</p><p>还是上面的例子，此时我们在<code>session2</code>中开启事务，然后查询<code>test</code>表，结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest07.jpg" alt="test表执行select语句"></p><p>此时在<code>session1</code>中更新记录,并提交：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/testupdate01.jpg" alt="test表执行update语句"></p><p>此时<code>session2</code>再次查询的结果为：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest08.jpg" alt="test表执行select语句"></p><p>通过上面的例子，我们发现，<code>可重复读</code>已经克服了<code>不可重复读</code>的问题。</p><h3 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h3><p>我们首先说下什么是幻读：</p><blockquote><p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样</p></blockquote><p>注意，这里要说明一下，之前的<code>脏读</code>与<code>不可重复读</code>都是针对一条记录而言的。但是幻读一般是针对一批数据而言的。在这里，我们举个栗子，假如公司中工资大于5000的有10人，此时session2查询的记录就是10。但是在<code>session2</code>查询完之后，此时<code>session1</code>向表中插入一条工资大于5000的记录，此时<code>session2</code>再查询就是11人了。这个就是幻读。</p><p>接下来，我们还是以<code>session2</code>为例，查询所有的<code>test</code>记录，但是此时提交事务</p><pre><code class="sql">select * from test;</code></pre><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest09.jpg" alt="test表执行select语句"></p><p>此时在<code>session1</code>中插入一条<code>id=1</code>的记录，并且提交事务</p><pre><code class="sql">insert into test (id)value (1);</code></pre><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/testinsert03.jpg" alt="test表执行insert语句"></p><p>此时我们再次在<code>session2</code>中进行查询</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest10.jpg" alt="test表执行select语句"></p><p>此时我们发现两次结果就处于不一致的状态，多了一个<code>id=1</code>的记录。这个就是<code>幻读</code>。解决<code>幻读</code>的办法就是使用<code>串行化</code>隔离级别。</p><p>这里补充一下，<code>MySql</code>默认的数据库隔离级别就是<code>可重复读</code>。</p><h2 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h2><p>我们首先说下什么是串行化：</p><blockquote><p>这是数据库最高的隔离级别，这种级别下，事务“串行化顺序执行”，也就是一个一个排队执行</p></blockquote><p>这种级别下，<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>都可以被避免，但是执行效率奇差，性能开销也最大，所以基本没人会用。</p><h3 id="串行化是否解决了幻读的问题"><a href="#串行化是否解决了幻读的问题" class="headerlink" title="串行化是否解决了幻读的问题"></a>串行化是否解决了幻读的问题</h3><p>此时我们先在<code>session2</code>中查询表<code>test</code>，得到的结果如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/querytest11.jpg" alt="test表执行select语句"></p><p>此时我们再在<code>session1</code>中执行插入语句，插入一条<code>id=3</code>的记录</p><pre><code class="sql">insert into test (id)value (3);</code></pre><p>此时我们发现，<code>MySql</code>报错了，内容如下：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/testinsert04.jpg" alt="test表执行insert语句"></p><p>这是说明，当前执行<code>insert</code>语句没有获取到锁。这也说明了上面<code>MySql</code>中对于<code>串行化</code>的定义。此时也就解决了<code>幻读</code>的问题。</p><h1 id="数据库第一类更新丢失"><a href="#数据库第一类更新丢失" class="headerlink" title="数据库第一类更新丢失"></a>数据库第一类更新丢失</h1><p>第一类更新丢失是指，由于某个事务的回滚操作，参与回滚的旧数据将其他事务的数据更新覆盖了。比如如下两个事务，事务一先开启查询账户有1000元，然后准备存款100元，使其账户变为1100，此时事务尚未结束，其后，事务二发生了转账，并提交了事务，使账户金额变为900，而事务一并不知情，最后事务一没有提交，而是回滚了事务，将账户金额重新设置为1000。但其实，账户已经被转走了100元，这种回滚导致了更新丢失。</p><p><code>SQL92</code>没有定义这种现象，标准定义的所有隔离界别都不允许第一类丢失更新发生。基本上数据库的使用者不需要关心此类问题。</p><h1 id="数据库第二类更新丢失"><a href="#数据库第二类更新丢失" class="headerlink" title="数据库第二类更新丢失"></a>数据库第二类更新丢失</h1><p>第二类数据丢失的问题是关于多个事务同时更新一行数据导致的问题，如下表所示，事务一和事务二都更新一行数据，他们事务开始的时候都查询到账户有1000元，然后都往账户添加了100元，最后大家都提交了各自的事务，结果却是错误的。</p><p>解决办法就是<code>悲观锁(for update)</code>、<code>乐观锁(通过where指定)</code>、将隔离级别改成<code>串行化</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的讲解，我们知道了数据库的隔离级别与对应的问题，已经数据库的第一、二类更新丢失的问题。在实际的开发中，<code>读未提交</code>级别的风险性特别的高，在生产上基本不会使用。<code>串行化</code>级别的并发性会特别的低，很容易资源的浪费，造成系统的瓶颈，在生产上基本也不会使用。而<code>读已提交</code>是<code>Oracle</code>的默认隔离级别，<code>可重复读</code>是<code>MySql</code>的默认隔离级别。这两种隔离级别是使用最多的两种。在本文，我们仅仅只是讲解了每个隔离级别和对应的问题。至于具体的<code>MySql</code>在内部是如何实现的，我们并没有进行讲解。在接下来的文章，我会主要讲解<code>MySql</code>在内部是如何实现各种隔离级别的。</p><p>我们采用一张图的方式，来说明下每个隔离级别的能力与对应的问题：</p><p><img src="https://shengouqiang.cn/img/SQL/isolation/day01/isolation.jpg" alt="隔离级别总结图"></p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
          <category> 理论学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql学习 </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK学习--String</title>
      <link href="//Java/JDK/String/JavaLearnDay02/"/>
      <url>//Java/JDK/String/JavaLearnDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK学习–String"><a href="#JDK学习–String" class="headerlink" title="JDK学习–String"></a>JDK学习–String</h1><p>在我们第一天开始学习<code>Java</code>的时候，我们就开始使用字符串了。说起来，<code>String</code>类可以说成是<code>Java</code>中最最重要的类了。正因为如此，我们才需要对<code>String</code>应该有一些深刻的认识，从而能够让我们更好的使用他们。</p><p>首先这个类位于<code>java.util</code>包下。并且这个类是一个<code>final</code>类。这也就意味着对于这个类，我们对于他仅仅只是能使用，如果想要修改和继承，那是不可能的了。其次，在<code>String</code>类的内部，同样也有一个用<code>final</code>修饰的字符数组。因此一旦我们给一个字符串赋值了以后，就不可以再对这个字符串进行修改了。</p><h2 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h2><p>在我们讲解<code>String</code>创建之前，我们首先需要知道一个关于<code>String</code>的技术–<code>String Pool</code>(以下简称<code>String池</code>)。<code>String</code>池存在于方法区中，初始为空，并且为各个进程所共享。<code>String池</code>中存放的是当我们运行程序时，所创建的字符串常量，并且这些常量是不可以重复的，并且这个<code>String池</code>为<code>String</code>类私有的维护。</p><p>还有一点就是<code>String</code>的<code>intern</code>方法。这个方法时一个<code>native</code>方法,同时这个方法的作用首先将字符串常量放入到常量池中，然后再堆中自动的创建一个<code>intern</code>字符串对象(拘留字符串对象)。此时这个对象的地址会默认的指向常量池的这个字符串。注意，刚才说的这些，都是<code>Java</code>自动执行的。不需要我们去进行操作。之所以讲解这些，是为了更好的去理解<code>Java</code>对于字符串的创建。</p><h3 id="使用字面量进行创建一个String变量"><a href="#使用字面量进行创建一个String变量" class="headerlink" title="使用字面量进行创建一个String变量"></a>使用字面量进行创建一个String变量</h3><pre><code class="java">String S1 = &quot;ABC&quot;;String S2 = &quot;ABC&quot;;String S3 = &quot;A&quot; + &quot;BC&quot;;String S4 = &quot;A&quot;;String S5 = &quot;BC&quot;;String S6 = S4 + S5;</code></pre><p><img src="https://shengouqiang.cn/img/Java/LearnDay02/StringLearn01.jpg" alt="String-字面量创建过程"></p><p>在<code>Java</code>编译器遇到上面的这句话时，首先会将<code>&quot;ABC&quot;</code>放入到常量池中，形成<code>.class</code>文件。而在JVM解释字节码、执行程序的时候，首先会在<code>String</code>池中创建常量<code>&quot;ABC&quot;</code>(图中的①)，然后在堆中自动的创建一个对象(在这里我们将这个堆中自动创建的对象称之为<code>$_CON_STR3</code>)(图中的②)。并且这个对象对应<code>String池</code>中常量<code>&quot;ABC&quot;</code>的地址，此时当我们创建一个<code>String</code>类型的引用变量<code>S1</code>的时候(图中的③)，此时直接指向了堆中的这个对象<code>$_CON_STR3</code>，而这个对象对应的又是<code>String</code>池中常量<code>&quot;ABC&quot;</code>的地址，因此<code>S1</code>也就相当于指向了常量<code>&quot;ABC&quot;</code>的地址。此时当<code>JVM</code>再执行这句话的时候，此时会发现<code>String池</code>中已经存在了<code>&quot;ABC&quot;</code>这个常量，同样的也存在了这个对象。因此，<code>JVM</code>会直接创建这个<code>String池</code>的引用变量<code>S2</code>会直接的指向内存中的对象<code>$_CON_STR3</code>(图中的④)。因此对于<code>S1==S2</code>这个结果，应该是<code>true</code>。</p><p>接下来，当<code>Java</code>编译源代码的时候，发现在<code>&quot;+&quot;</code>号的左右两侧均是字符串常量的时候，此时在编译期间会自动的将两个字符串进行合并，形成<code>&quot;ABC&quot;</code>常量，以提高程序的执行效率。同样的，在<code>JVM</code>执行时，发现已经在<code>String池</code>中存在常量<code>&quot;ABC&quot;</code>,因此，<code>S3</code>与<code>S2</code>的执行操作相同。均是指向已经存在的对象<code>$_CON_STR3</code>(图中的⑨)</p><p>同样的，在执行第四行代码时，发现了还存在字符串常量<code>&quot;A&quot;</code>，此时<code>Java</code>首先回去<code>String池</code>中进行检测，是否已经含有字符串常量<code>&quot;A&quot;</code>，如果存在直接调用；如果不存在，则在<code>String</code>中首先放入字符串常量<code>&quot;A&quot;</code>(图中的⑤),然后再内存中自动的进行创建一个<code>intern</code>字符串对象<code>$_CON_STR1</code>(图中的⑥)，然后创建了一个<code>String</code>类型的引用变量，用来存放<code>$_CON_STR1</code>的地址(图中的⑩)。接下来，⑦、⑧、⑪与⑤、⑥、⑩的执行操作相同，在这里不再赘述。</p><p>接下来是最最重要的。在执行<code>S6</code>这行代码的时候，首先<code>Java</code>会再内存中创建一个<code>StringBuffer</code>对象<code>$_STRINGBUFFER_S1</code>，并且使用<code>S4</code>指向的<code>intern</code>字符串对象进行初始化(图中的⑫)。并且通过调用<code>append</code>方法(图中的⑬)，以<code>S5</code>执行的<code>intern</code>字符串对象作为参数，让两个字符串拼接起来。然后通过调用<code>toString</code>函数(图中的⑭)，在堆中再次生成一个<code>String</code>对象<code>$_CON_STR4</code>(图中的⑮)。然后会创建一个<code>String</code>类型的变量<code>S6</code>，用来存储<code>$_CON_STR4</code>的地址。</p><h3 id="通过关键字来创建一个对象"><a href="#通过关键字来创建一个对象" class="headerlink" title="通过关键字来创建一个对象"></a>通过关键字来创建一个对象</h3><pre><code class="java">String S1 = new String(&quot;ABC&quot;);String S2 = new String(&quot;ABC&quot;);String S3 = &quot;ABC&quot;;String S4 = new String(S3);String S5 = new String(&quot;AB&quot;);String S6 = new String(&quot;C&quot;);String S7 = S5 + S6;String S8 = S5 + &quot;C&quot;;</code></pre><p>同样的，我们还是用一张图进行讲解：</p><p><img src="https://shengouqiang.cn/img/Java/LearnDay02/StringLearn02.jpg" alt="String-String对象创建过程"></p><p>在这里，我们需要知道的一点就是，当我们使用<code>new</code>关键字来创建一个<code>String</code>对象的时候，此时一定会在堆中创建一个对象。因此，当程序执行第一行代码的时候，此时程序首先会在<code>String池</code>中查看时候有没有常量<code>&quot;ABC&quot;</code>，如果没有，则在<code>String池</code>中添加常量<code>&quot;ABC&quot;</code>(图中的①)，然后会在堆中自动的创建一个<code>intern</code>字符串对象<code>$_CON_STR1</code>(图中的②)，然后我们使用<code>new</code>关键字来创建一个<code>String</code>对象(图中的③)，并且以<code>$_CON_STR1</code>为参数，最后创建一个<code>String</code>类型的引用变量<code>S1</code>(图中的④)用以保存这个通过关键字<code>new</code>创建来的对象。</p><p>当程序执行第二行代码的时候，他的执行步骤与很相似。<code>Java</code>首先还是会在<code>String池</code>中检测时候包含常量<code>&quot;ABC&quot;</code>，当<code>Java</code>方向包含的时候，会去内存中找到这个常量对应的<code>intern</code>字符串对象<code>$_CON_STR1</code>，然后再堆中以<code>$_CON_STR1</code>对象作为参数，创建一个<code>String</code>类型的对象(图中的⑤)，然后创建一个<code>String</code>类型的引用变量<code>S2</code>(图中的⑥)，用<code>S2</code>来存储新创建出来的这个<code>String</code>对象。</p><p>同样的，当<code>Java</code>在执行第三行代码的时候，此时与第一种情况及其类似。此时方向了<code>String池</code>中的常量<code>&quot;ABC&quot;</code>,并且找到了<code>intern</code>字符串对象，此时<code>Java</code>仅仅只是创建了一个<code>String</code>类型的引用变量(图中的⑦)，用来保存这个<code>intern</code>字符串对象。</p><p>至于第四、五、六行代码的过程与第一、二行及其的相似，再次不再赘述。</p><p>当执行第七行代码的时候，此时<code>Java</code>首先会在堆中创建一个<code>StringBuffer</code>的对象(图中的⑱)，并且以<code>S5</code>作为参数进行初始化，然后通过调用<code>StringBuffer</code>类的<code>append</code>方法(图中的⑲)，以<code>S6</code>为参数进行字符串的合并，然后通过调用该类的<code>toString</code>方法，将这个<code>StringBuffer</code>对象转换成一个<code>String</code>对象<code>$_CON_STR4</code>(图中的⑳)，然后<code>Java</code>创建一个<code>String</code>类型的引用变量<code>S7</code>，用来存储这个<code>String</code>对象。</p><p>至于第八行代码，此时与第七行及其的相似，再次也不再赘述。</p><h2 id="String类的一些常用的函数"><a href="#String类的一些常用的函数" class="headerlink" title="String类的一些常用的函数"></a>String类的一些常用的函数</h2><h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>这个函数的目的是为了消除在<code>Unicode</code>编码中小于<code>32</code>的字符。然后返回给我们修改后的字符串。这个函数的原理是:如果调用的字符串中的第一个字符和最后一个字符都大于<code>32</code>，则直接返回这个字符串的引用。但是如果这个字符串中的所有的字符都不大于<code>32</code>,则直接<code>new</code>一个新的空的<code>String</code>对象返回给我们。如果这个字符串的前面或者是后面有小于等于<code>32</code>的编码字符，则<code>new</code>一个新的空的字符串，然后将这个原来字符串两端的小于等于<code>32</code>的编码字符删除后的新字符串赋值给这个新的空字符串，最终返回给我们。</p><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p><code>intern()</code>是<code>String</code>类的一个<code>public</code>方法，这个方法的作用是首先拿调用这个函数的字符串和<code>String池</code>中的字符串相比较，如果<code>String池</code>中含有这个字符串，那么就返回这个字符串的地址，如果没有这个字符串，那么就将这个字符串放入到<code>String池</code>中，然后将这个字符串的地址返回回去。它遵循的规则是:假若存在两个字符串<code>s</code>、<code>t</code>，当且仅当<code>s.equals(t)==true</code>时，<code>s.intern()==t.intern()</code>才为<code>true</code>。</p><h3 id="concat-String-str"><a href="#concat-String-str" class="headerlink" title="concat(String str)"></a>concat(String str)</h3><p><code>concat()</code>是<code>String</code>类的一个<code>public</code>方法，这个方法是具有参数的。这个方法的目的是将两个字符串拼接在一起。和<code>&quot;+&quot;</code>在功能上很类似，但是原理上却大不相同。因为，当<code>str</code>的长度为<code>0</code>的时候，此时直接返回这个字符串。但是如果这个<code>str</code>的长度不为<code>0</code>的时候，此时<code>JAVA</code>就会创建一个新的字符串。将这两个字符串拼接在一起，返回回来。</p><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>这个函数在<code>Java</code>中有两个重载的方法：<code>split(String regex,int limit)</code>和<code>split(String regex)</code>;这个函数的作用就是按照我们自己定义的正则表达式，将一个字符串拆分成许多子字符串，并且放在一个<code>String</code>类型的数组中返回给我们，如果这个字符串不满足这个正则表达式，那么直接就返回给我们一个空的<code>String</code>数组。</p><p><code>split(String regex,int limit)</code>这个方法的两个参数分别代表的是正则表达式和我们可以使用正则表达式匹配的次数。这里需要注意的是，我们能够匹配的次数与<code>limit</code>有关:</p><ol><li>当<code>limit&gt;0</code>的时候，此时我们能够匹配的次数仅仅为<code>limit-1</code>次，并且此时返回的数组的长度不会大于<code>limit</code>。</li><li>当<code>limit&lt;0</code>的时候，此时<code>split</code>尽可能多的此时被使用，并且返回的数组的长度没有任何的限制。</li><li>当<code>limit=0</code>的时候，此时<code>split</code>尽可能多的此时被使用，并且返回的数组的长度没有任何的限制,并且结尾的空字符串将会被舍弃。</li></ol><p>接下来，我们还有通过一张图进行演示：</p><p><img src="https://shengouqiang.cn/img/Java/LearnDay02/StringLearn03.jpg" alt="String-split方法"></p><p><code>split(String regex)</code>这个方法是上面那个方法的特例，此时他的效果和<code>split(String regex,0)</code>的效果是一致的。</p><p>此时有一个特别需要注意的就是，如果我们要拆分的字幕就是这个字符串的最开始的部分，那么返回来的数组的第一项就是一个值为空的字符串。还有，如果<code>regex</code>的值为<code>&quot;|&quot;</code>，那么他和<code>&quot;&quot;</code>的效果是等同的。他的效果是逐个字符进行拆分。</p><h3 id="replace与replaceAll"><a href="#replace与replaceAll" class="headerlink" title="replace与replaceAll"></a>replace与replaceAll</h3><p>相同点：</p><p>这两个函数均在<code>java.util.String</code>中。并且这两个函数相同的目的都是为了去替换在字符串中出现的所有的我们想要替换的字符或者是字符串。</p><p>对于这两个方法，他们对于原字符串的遍历都是从头开始的。例如：如果在原字符串中出现<code>&quot;aaa&quot;</code>子字符串时，我们想要将<code>&quot;aa&quot;</code>替换成<code>&quot;b&quot;</code>的时候，此时系统会自动替换成<code>&quot;ba&quot;</code>，而不会是<code>&quot;ab&quot;</code>。对于字符的替换，也是这样。</p><p>不同点：</p><p>1.对于<code>replace</code>这个函数，在<code>String</code>这个类中，对这个函数进行了重载.<br>1.1 <code>String replce(char oldChar,char newChar)</code>通过字面意思，我们不难理解，它是利用字符来进行替换的。它的目的就是从头开始查这个字符串是否出现<code>oldChar</code>这个字符，如果出现，那么就替换成<code>newChar</code>这个字符。</p><p>它的运行机制是：首先是遍历这个字符串的每个字符，如果没有发现有<code>oldChar</code>这个字符，那么就返回当前这个字符串的一个引用回去。但是一旦在遍历的过程中，找到了<code>oldChar</code>这个字符，那么此时就会创建一个新的字符串，是原字符串的副本，然后再这个副本上进行替换操作，最后将这个新的字符串的引用返回给调用方。</p><p>1.2 <code>String replace(CharSequence target,CharSequence replacement)</code>这个方法和上面的方法唯一不同的是，这个方法替换的不是单个的字符，而是一个字符串。机制和上面的差不多。在此不再重述。</p><p>2.对于<code>replaceAll</code>这个函数，在<code>String</code>这个类中，仅仅只有一个。 <code>String replaceAll(String regex,String replacement)</code>这个函数的俩个参数分别是要查找的字符串和要被替换的字符串。</p><p>但是这个类和<code>replace</code>确实有很大的区别。因为<code>replace</code>不管是两个函数中的哪个，都是进行简简单单的替换而已。但是<code>replaceAll</code>的替换却是基于正则表达式的(具体参见度娘)。他的替换很有学问。需要参照正则表达式来进行替换，否则会出错的。并且这个正则表达式是针对于这两个参数的。例如：<code>&quot;.&quot;</code>这个在正则表达式里面代表的是除了换行符以外的任意符号。因此：</p><pre><code class="java">public static void main(String[] args)&#123;    String str=&quot;java.util.String&quot;;    String temp=str.replaceAll(&quot;.&quot;,&quot;/&quot;);    System.out.println(temp);&#125;</code></pre><p>对于这个函数，输出的结果正如上面所讲，他的结果是<code>&quot;////////////////&quot;</code>，而不是<code>&quot;java/util/String&quot;</code>。这仅仅是一个例子，对于这个函数的使用，首先是要了解正则表达式和转义字符<code>(&#39;\&#39;)</code>这两个概念。</p><p>对于上面的那段代码，如果使用的是<code>replace</code>函数而不是<code>replaceAll</code>函数，那么结果就是<code>&quot;java/util/String&quot;</code>。</p><p>还有一个函数，<code>replaceFirst</code>这个函数，这个函数就是<code>replaceAll</code>这个函数的一个阉割版本，他的作用见名知义，就是通过正则表达式替换第一个符合条件的函数而已。而<code>replaceAll</code>替换的是所有的。上面的代码如果用<code>replaceFirst</code>这个函数，那么结果就是<code>&quot;/ava.util.String&quot;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> JDK学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：从1+1000000的O(1)的时间复杂度</title>
      <link href="//Algorithm/AlgorithmLearnDay01/"/>
      <url>//Algorithm/AlgorithmLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="从1-1000000的O-1-的时间复杂度"><a href="#从1-1000000的O-1-的时间复杂度" class="headerlink" title="从1+1000000的O(1)的时间复杂度"></a>从1+1000000的O(1)的时间复杂度</h1><pre><code class="java">package com.gouqiang.other;import org.junit.Test;/** * @author shengouqiang * @date 2019/11/27 */public class TestTwo &#123;    @Test    public void testOne()&#123;        addToResult(1000000L);        addToResult(1000001L);    &#125;    /**     * 判断请求数是否为单数     * @param requestNumber     * @return     */    private boolean checkNumberIsSingular(long requestNumber)&#123;        if(0== requestNumber%2)&#123;            return false;        &#125;        return true;    &#125;    /**     * 计算求和     * @param reqNumber     */    private void addToResult(long reqNumber)&#123;        if(checkNumberIsSingular(reqNumber))&#123;            System.out.println(reqNumber*(reqNumber/2+1));            return;        &#125;        System.out.println((reqNumber+1)*(reqNumber/2));    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code class="java">500000500000500001500001</code></pre><p>这里主要利用了数学中的<code>等差数列求和公式</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法学习 </category>
          
          <category> 常用算法证明 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法学习 </tag>
            
            <tag> 面试算法总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EffectiveJava--第一条：用静态工厂方法代替构造器</title>
      <link href="//EffectiveJava/EffectiveJavaLearnDay01/"/>
      <url>//EffectiveJava/EffectiveJavaLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="EffectiveJava–第一条：用静态工厂方法代替构造器"><a href="#EffectiveJava–第一条：用静态工厂方法代替构造器" class="headerlink" title="EffectiveJava–第一条：用静态工厂方法代替构造器"></a>EffectiveJava–第一条：用静态工厂方法代替构造器</h1><p>在我们日常的开发当中，我们经常会接触到各种各样的<code>POJO</code>。并且在我们使用的过程中，我们每当需要使用这个对象的时候，第一时间想到的就是<code>new</code>一个出来。其实，除了<code>new</code>,我们还可以采用其他的方法，来获取这个<code>POJO</code>对象，那就是-<code>静态工厂方法</code>。</p><p><span style="color:red;">注意：在这里，我们要注意一点，不是说我们的构造方法不能用。而是说，在一些情况下，我们采用静态工厂方法会比直接采用构造器的方式，让我们的代码更加的简洁，更加容易让人理解。</span></p><p>那么你可能会问，什么是<code>静态工厂方法</code>呢？其实，在我们日常的使用中，我们已经在经常的使用了。例如，我们有一个<code>boolean</code>类型的变量，希望可以获取到这个变量的一个包装类，那么对于你而言，你可能第一时间想到的是<code>Boolean.valueOf(boolean b)</code>这个方法，通过这个方法，我们就可以获得一个对应的<code>Boolean</code>类型的变量了。</p><p>但是，你是否想过，<code>JDK</code>的库工程师们，在<code>valueOf</code>这个方法中，到底做了什么？是怎么把一个<code>boolean</code>变成<code>Boolean</code>类型的？接下来，我们看下<code>JDK</code>的库源码：</p><pre><code class="java">public static Boolean valueOf(boolean b) &#123;        return (b ? TRUE : FALSE);    &#125;</code></pre><p>看到这里，你可能明白点了什么，但是你可能会继续问？那为什么不在<code>valueOf</code>方法的内部给我们<code>new</code>一个出来呢？要解答这个问题，我们可以接着看<code>TRUE</code>和<code>FALSE</code>的源码。</p><pre><code class="java">public static final Boolean TRUE = new Boolean(true);public static final Boolean FALSE = new Boolean(false);</code></pre><p>看到这里，我们发现，在<code>class</code>加载的时候，就一个创建了两个对象<code>TRUE</code>和<code>FALSE</code>。而我们每次通过<code>valueOf</code>获取对应包装类的时候，其实都是获取的这两个对象。这么做的好处之一是可以节省内存，同时降低内存中重复类的数量。那么我们在日常开发中，采用<code>静态工厂方法</code>有哪些利弊呢？</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><h3 id="优点一：有名称"><a href="#优点一：有名称" class="headerlink" title="优点一：有名称"></a>优点一：有名称</h3><p>说到这里，你可能觉得，这个很简单。的确，<code>Boolean.valueOf(boolean b)</code>的确是我们经常采用的一种方式，来产生<code>Boolean</code>包装类的方法。那么你有没有想过，我们为什么要采用<code>valueOf</code>的方式，而不是采用<code>new Boolean(true)</code>的方式呢？的确，对于懂的人而言，都知道无论这两种方式中的那一种，都可以给我们返回一个对应值的包装类型。但是如果我们单单从方法名称上看，<code>new Boolean(true)</code>我们仅仅只是创建了一个对象，那么在<code>Boolean</code>中的构造函数里面有什么隐藏的含义，你其实是不确定的。但是通过<code>Boolean.valueOf(boolean b)</code>我们可以知道，这个方法的目的就是把我们的基本类型转换成一个包装类型。起到了<code>见名知意</code>的作用。</p><h3 id="优点二：不必再每次调用他们的时候都创建一个新对象"><a href="#优点二：不必再每次调用他们的时候都创建一个新对象" class="headerlink" title="优点二：不必再每次调用他们的时候都创建一个新对象"></a>优点二：不必再每次调用他们的时候都创建一个新对象</h3><p>还是以<code>Boolean</code>这个类为例，我们都知道，当我们通过<code>new Boolean(true)</code>的时候，每次都会创建一个对象出来的。但是通过上面的<code>valueOf</code>方法。我们发现，在源码中使用了一个三目运算符。对于运算的结果，仅仅只是返回了两个常量。无论我们调用多少次，其实每次返回的都是同一个对象。</p><h3 id="优点三：他们可以返回原返回类型的任何子类型对象"><a href="#优点三：他们可以返回原返回类型的任何子类型对象" class="headerlink" title="优点三：他们可以返回原返回类型的任何子类型对象"></a>优点三：他们可以返回原返回类型的任何子类型对象</h3><p>对于这个优势，其实我们可以看下<code>JDK1.8</code>中的源码关于<code>Collections</code>这个类的部分方法。在这里，我们先贴出相关的源码，在进行分析：</p><pre><code class="java">public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) &#123;    return new UnmodifiableSet&lt;&gt;(s);&#125;static class UnmodifiableSet&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;                                implements Set&lt;E&gt;, Serializable &#123;    private static final long serialVersionUID = -9215047833775013803L;    UnmodifiableSet(Set&lt;? extends E&gt; s)     &#123;super(s);&#125;    public boolean equals(Object o) &#123;return o == this || c.equals(o);&#125;    public int hashCode()           &#123;return c.hashCode();&#125;&#125;</code></pre><p>在这里，我们先不来讨论这个方法是用来干什么的。我们仅仅只是通过方法的入参、返回值和方法内代码进行分析。首先我们发现，对于方法的入参和返回值都是一个关于<code>Set</code>的泛型。而在代码的内部，我们对于方法的处理，采用的是一个<code>UnmodifiableSet</code>类。</p><p>而通过这个类的源码我们可以知道，这个类是<code>Set</code>的一个子类而已。并且这个类是包级私有的。因此，对于我们而言，我们调用<code>unmodifiableSet</code>的方法时，并不需要了解<code>UnmodifiableSet</code>这个类，甚至都不需要这个类的存在。这也正是<code>静态工厂方法</code>的一个优点所在，它可以在方法的内部，对于数据进行包装、处理，并且可以抽象在子类的里面。而我们接收的时候，依然可以采用父类进行接收，这样不仅在降低代码复杂度的同时，同时我们还可以将细节隐藏，伴随着，我们的Doc文档也会整洁很多。</p><h3 id="优点四：所返回的对象的类可以随着每次调用而发生变化，这都取决于静态工厂方法的参数值"><a href="#优点四：所返回的对象的类可以随着每次调用而发生变化，这都取决于静态工厂方法的参数值" class="headerlink" title="优点四：所返回的对象的类可以随着每次调用而发生变化，这都取决于静态工厂方法的参数值"></a>优点四：所返回的对象的类可以随着每次调用而发生变化，这都取决于静态工厂方法的参数值</h3><p>这个依然可以通过<code>valueOf</code>方法进行讲解。在我们的入参是<code>true</code>的时候，此时返回的是<code>Boolean.TRUE</code>；当我们的入参是<code>false</code>的时候，此时返回的是<code>Boolean.FALSE</code>。</p><h3 id="优点五：方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。"><a href="#优点五：方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。" class="headerlink" title="优点五：方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。"></a>优点五：方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。</h3><p>在这里，可能很多人理解起来都十分的困难。但是如果举个例子，会很好的理解。假如我们程序有个这样的场景。需要保存我们的数据。而数据的保存在不同的阶段可以有不同的保存形式。例如，最开始的时候，我们直接采用<code>IO</code>流的形式，将数据保存在文件上。后来随着数据的越来越多和检索的需求，此时我们需要将数据保存在数据库中。在这里，我们发现，我们的程序仅仅只是保存数据的方式不同。但是其他都是相同的。在这里，我们可以把数据保存这个方法抽象出来。而文件形式、数据库形式的不同的实现，可以实现这个抽象的方法就可以了。其实，<code>优点五</code>讲的就是这个例子。而书中所讲的<code>服务提供者框架</code>也是在说这个问题。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="缺点一：类如果不含公有的或者受保护的构造器，就不能被子类化。"><a href="#缺点一：类如果不含公有的或者受保护的构造器，就不能被子类化。" class="headerlink" title="缺点一：类如果不含公有的或者受保护的构造器，就不能被子类化。"></a>缺点一：类如果不含公有的或者受保护的构造器，就不能被子类化。</h3><p>通过字面意思，我们就可以知道，对于一个类而言，如果没有公有的或者受保护的构造器，就不能被子类化。</p><h3 id="缺点二：程序员很难发现他们。"><a href="#缺点二：程序员很难发现他们。" class="headerlink" title="缺点二：程序员很难发现他们。"></a>缺点二：程序员很难发现他们。</h3><p>对于这个很好理解。因为当我们在使用的时候，都是使用的是我们最常使用的<code>API</code>。对于这个类的其他的方法，只有在我们需要的时候，或者我们去读<code>API</code>的时候，才会发现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，如果只是单纯的读《Effective Java》这本书的话，真的是一头雾水，写的太晦涩了。以<code>用静态工厂方法代替构造器</code>这个为例，我们其实真的需要掌握的就是–<span style="color:red;">尽可能的让我们的代码更加的易读，减轻读代码的压力。当一个构造函数有多重含义的时候，此时我们通过静态工厂方法来代替构造器能更好的让别人理解。</span></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> EffectiveJava </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> 代码优化 </tag>
            
            <tag> Java进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK学习--ThreadLocal</title>
      <link href="//Java/JDK/Thread/JavaLearnDay01/"/>
      <url>//Java/JDK/Thread/JavaLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK学习–ThreadLocal"><a href="#JDK学习–ThreadLocal" class="headerlink" title="JDK学习–ThreadLocal"></a>JDK学习–ThreadLocal</h1><p>对于<code>ThreadLocal</code>而言，我想做过后台Java开发的都不会太陌生。对于线程间的隔离，最简单的方法就是采用<code>ThreadLocal</code>的模式。那么，什么是<code>ThreadLocal</code>呢？官网给出的答案是：</p><blockquote><p>ThreadLocal类提供了线程局部 (thread-local) 变量。这些变量与普通变量不同，每个线程都可以通过其 get 或 set方法来访问自己的独立初始化的变量副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p></blockquote><p>说白了，<code>ThreadLocal</code>就是为我们的每个线程提供了一个变量。并且这个变量仅仅只能当前线程访问，保证了线程间变量的隔离性，防止出现并发的一种解决方案。</p><p>那么接下来，我们来研究一下，为什么<code>ThreadLocal</code>可以做到线程间隔离，并且，它的内部优势如何实现的呢？</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先，我们看下<code>ThreadLocal</code>的UML类图：</p><p><img src="https://shengouqiang.cn/img/Java/LearnDay01/ThreadLocalUML.jpg" alt="ThreadLocal-UML类图"></p><p>通过类图，我们发现，<code>ThreadLocal</code>的内部，主要是通过一个内部类<code>ThreadLocalMap</code>来实现的。而<code>ThreadLocalMap</code>内部，由定义了一个<code>Entry</code>内部类。同时，在途中我们发现了<code>InheritableThreadLocal</code>。对于这连个类的不同，我们会在下面的文章中逐一进行讲解。下面，我们先来说一下<code>ThreadLocal</code>这个类。</p><h2 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h2><p>这次讲解的方式和之前的有所不同。因为我不会一上来就贴上所有的源码。这回采用的是，我用到了哪部分源码，就贴哪部分源码。这样的讲解，会有更大的针对性和可读性。</p><h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><p>对于<code>ThreadLocal</code>而言，如果我们想要用到，那么我们就需要在我们的线程中去创建一个<code>ThreadLocal</code>。对于ThreadLocal，我们的创建方式主要是已下两种：</p><pre><code class="java">    @Test    public void initOneTest()&#123;        ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();        System.out.println(&quot;initOneTest result is :&quot; + threadLocal.get());    &#125;    @Test    public void initTwoTest()&#123;        ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(String::new);        System.out.println(&quot;initTwoTest result is :&quot; + threadLocal.get());    &#125;</code></pre><p>此时，我们程序的执行结果如下：</p><pre><code>initOneTest result is :nullinitTwoTest result is :</code></pre><p>既然我们的<code>ThreadLocal</code>有两种创建方式，那么这两种方式有什么不同吗？接下来，我们对比下这两种方式</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="java">    /**     * Creates a thread local variable.     * @see #withInitial(java.util.function.Supplier)     */    public ThreadLocal() &#123;    &#125;</code></pre><p>我们看到，对于构造函数而言，<code>JDK</code>的库工程师们并没有帮我们去做任何的事情，就是提供了一个默认的构造函数来供我们调用。同时，对于<code>ThreadLocal</code>内部的成员变量<code>threadLocalHashCode</code>、<code>nextHashCode</code>、<code>HASH_INCREMENT</code>，提供了一个默认的值。</p><h4 id="withInitial-方法"><a href="#withInitial-方法" class="headerlink" title="withInitial 方法"></a>withInitial 方法</h4><pre><code class="java">    /**     * Creates a thread local variable. The initial value of the variable is     * determined by invoking the &#123;@code get&#125; method on the &#123;@code Supplier&#125;.     *     * @param &lt;S&gt; the type of the thread local&#39;s value     * @param supplier the supplier to be used to determine the initial value     * @return a new thread local variable     * @throws NullPointerException if the specified supplier is null     * @since 1.8     */    public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) &#123;        return new SuppliedThreadLocal&lt;&gt;(supplier);    &#125;</code></pre><p>我们看到，对于<code>withInital</code>方法，<code>ThreadLocal</code>的内部是采用的调用了一个静态内部类<code>SuppliedThreadLocal</code>来实现的。而这个静态类的源码如下：</p><pre><code class="java">/**    * An extension of ThreadLocal that obtains its initial value from    * the specified &#123;@code Supplier&#125;.    */static final class SuppliedThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;    private final Supplier&lt;? extends T&gt; supplier;    SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;        this.supplier = Objects.requireNonNull(supplier);    &#125;    @Override    protected T initialValue() &#123;        return supplier.get();    &#125;&#125;</code></pre><p>通过代码我们可以知道，对于<code>SuppliedThreadLocal</code>的构造方法，它接收的是一个<code>Supplier</code>的泛型接口，这个接口是<code>Java8</code>提供的一个函数式接口，因此在这里，我们可以采用<code>lamdba</code>表达式的形式，将我们的参数传递近来，例如上文的<code>String::new</code>。至于具体的，请参考相应的文章。</p><p>在这里接口，我们看见，它仅仅只是一个判空的操作和赋值的操作。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>对于<code>get</code>方法，<code>ThreadLocal</code>的源码如下：</p><pre><code class="java">  /**     * Returns the value in the current thread&#39;s copy of this     * thread-local variable.  If the variable has no value for the     * current thread, it is first initialized to the value returned     * by an invocation of the &#123;@link #initialValue&#125; method.     *     * @return the current thread&#39;s value of this thread-local     */    public T get() &#123;        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) &#123;            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) &#123;                @SuppressWarnings(&quot;unchecked&quot;)                T result = (T)e.value;                return result;            &#125;        &#125;        return setInitialValue();    &#125;</code></pre><p>对于官方给定的解释，返回的是以当前线程为<code>Key</code>，然后获取到这个线程下的变量的值，如果在当前线程不存在，则先进行初始化，然后再返回对应的值。</p><p>接下来，我们解读下代码，首先通过<code>Thread.currentThread()</code>获取到当前线程。然后通过<code>getMap</code>的方法来获取到对应的<code>ThreadLocalMap</code>中的值。而<code>getMap</code>的方法如下：</p><pre><code class="java">    /**     * Get the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param  t the current thread     * @return the map     */    ThreadLocalMap getMap(Thread t) &#123;        return t.threadLocals;    &#125;</code></pre><p>通过这段代码，我们发现，对于每个线程，都有一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>又是<code>ThreadLoal</code>的静态内部类。因此在<code>Thread</code>中，每个线程都会存在一个<code>ThreadLocal.ThreadLocalMap</code>的成员变量。因此，这个就证实了，<code>ThreadLocal</code>是线程间私有的，不存在<code>并发</code>的问题的。同时，我们发现，对于ThreadLocal而言，它的内部存储都是采用一个<code>ThreadLocalMap</code>的方式进行存储的。因此，对于整个<code>ThreadLocal</code>而言，最最重要的就是<code>ThreadLocalMap</code>。</p><p>如果当前线程的<code>ThreadLocalMap</code>不为<code>null</code>,则我们获取到<code>map</code>后，会通过<code>ThreadLocalMap.Entry e = map.getEntry(this);</code>的方式去获取<code>Entry</code>。可能到这里，读者会别叫晕，一会是<code>ThreadLocalMap</code>,一会又是<code>ThreadLocal.ThreadLocalMap.Entry</code>的。不要急，在解释完这个方法后，我们会讲解下<code>ThreadLocalMap</code>这个类的。</p><p>在获取到<code>Entry</code>后，我们判断当前<code>Entry</code>是否为<code>null</code>，如果不为<code>null</code>，此时我们回去对应的<code>value</code>,将<code>value</code>返回即可。</p><p>最后，如果我们发现<code>ThreadLocalMap</code>为<code>null</code>，或者<code>Entry</code>为null，此时会执行<code>setInitialValue</code>方法。这个方法的源码如下：</p><pre><code class="java">    /**     * Variant of set() to establish initialValue. Used instead     * of set() in case user has overridden the set() method.     *     * @return the initial value     */    private T setInitialValue() &#123;        T value = initialValue();        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);        return value;    &#125;</code></pre><p>在这个方法中，我们首先会通过<code>initialValue</code>获取到<code>value</code>。而这个方法的源码又分为两部分，如果我们是通过<code>new ThreadLocal&lt;&gt;()</code>方式创建的，此时调用的源码如下：</p><pre><code class="java">    protected T initialValue() &#123;        return null;    &#125;</code></pre><p>而如果我们是通过<code>ThreadLoacl.withInitial</code>方法创建的，那么此时调用的就是</p><pre><code class="java">@Overrideprotected T initialValue() &#123;    return supplier.get();&#125;</code></pre><p>而这里面的<code>supplier</code>就是我们上面将的第二种初始化的时候，传进来的<code>lamdba</code>表达式。</p><p>同样的，我们继续获取当前线程。然后再次调用<code>getMap</code>方法，如果我们发现<code>map</code>存在，则只需要将<code>value</code>添加到<code>map</code>中即可。如果<code>map</code>不存在，则调用<code>createMap</code>方法。</p><pre><code class="java">    /**     * Create the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param t the current thread     * @param firstValue value for the initial entry of the map     */    void createMap(Thread t, T firstValue) &#123;        t.threadLocals = new ThreadLocalMap(this, firstValue);    &#125;</code></pre><p>而创建<code>Map</code>的过程，就是对线程的<code>threadLocals</code>进行赋值，而创建值的过程就是调用<code>ThreadLocalMap</code>的一个构造方法。</p><pre><code class="java">    void createMap(Thread t, T firstValue) &#123;        t.threadLocals = new ThreadLocalMap(this, firstValue);    &#125;</code></pre><p>整个<code>get</code>方法的调用流程图如下：</p><p><img src="https://shengouqiang.cn/img/Java/LearnDay01/ThreadLocalGet.jpg" alt="ThreadLocal-GET方法"></p><h3 id="ThreadLocalMap内部类"><a href="#ThreadLocalMap内部类" class="headerlink" title="ThreadLocalMap内部类"></a>ThreadLocalMap内部类</h3><p>在刚刚进行讲解的时候，我们发现，其实在<code>ThreadLocal</code>的内部，其实是用<code>ThreadLocalMap</code>进行存储的。因此为了理解<code>ThreadLocal</code>，<code>ThreadLocalMap</code>就显得十分的重要。那么既然要好好的理解<code>ThreadLocalMap</code>，那么我们首先要看看他的源码：</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>根据之前的时候，我们首先要看下<code>ThreadLocalMap</code>的构造方法：</p><pre><code class="java">/**    * Construct a new map initially containing (firstKey, firstValue).    * ThreadLocalMaps are constructed lazily, so we only create    * one when we have at least one entry to put in it.    */ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;    table = new Entry[INITIAL_CAPACITY];    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);    table[i] = new Entry(firstKey, firstValue);    size = 1;    setThreshold(INITIAL_CAPACITY);&#125;/**    * Construct a new map including all Inheritable ThreadLocals    * from given parent map. Called only by createInheritedMap.    *    * @param parentMap the map associated with parent thread.    */private ThreadLocalMap(ThreadLocalMap parentMap) &#123;    Entry[] parentTable = parentMap.table;    int len = parentTable.length;    setThreshold(len);    table = new Entry[len];    for (int j = 0; j &lt; len; j++) &#123;        Entry e = parentTable[j];        if (e != null) &#123;            @SuppressWarnings(&quot;unchecked&quot;)            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();            if (key != null) &#123;                Object value = key.childValue(e.value);                Entry c = new Entry(key, value);                int h = key.threadLocalHashCode &amp; (len - 1);                while (table[h] != null)                    h = nextIndex(h, len);                table[h] = c;                size++;            &#125;        &#125;    &#125;&#125;</code></pre><p>我们先来看看第一个构造函数，通过上面的注释，我们可以知道，<code>ThreadLocalMap</code>是进行延迟构建的。也就是说它并不会在创建一个线程的时候，就会初始化<code>ThreadLocalMap</code>。而是在我们第一次需要从里面拿值的话，才会进行调用的。因为<code>ThreadLocalMap</code>并没有提供默认的构造函数，因此想要调用的时候，必须要有一个默认的值。</p><p>通过代码我们可以知道，程序首先会创建一个<code>Entry</code>数组，而<code>Entry</code>的定义是什么呢？</p><pre><code class="java">/*** The entries in this hash map extend WeakReference, using* its main ref field as the key (which is always a* ThreadLocal object).  Note that null keys (i.e. entry.get()* == null) mean that the key is no longer referenced, so the* entry can be expunged from table.  Such entries are referred to* as &quot;stale entries&quot; in the code that follows.*/static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        super(k);        value = v;    &#125;&#125;</code></pre><p>因为在<code>ThreadLocalMap</code>中，每一个线程和对应的私有的变量，都是一对一对的。采用的是<code>K-V</code>模式。因此，我们可以将这样的映射关系封装成一个<code>Entry</code>。这里采用的是<code>JDK</code>中<code>Map</code>的思想，因为<code>ThreadLocalMap</code>本身也是一种<code>Map</code>数据结构，通过<code>hash</code>去进行结算的。并且，对于<code>Key</code>的采用，是对<code>ThreadLocal</code>采用的一种弱引用的方式进行引用的。因此，我们发现，真正的将线程与变量之间连接起来的，是通过<code>Entry</code>进行封装的。而<code>Entry</code>又是存储在<code>ThreadLocal</code>中的。因此，<code>Entry</code>仅仅只是一个<code>POJO</code>,它仅仅给我们提供了一个构造函数而已。</p><p>接下来，我们继续分析第一个构造函数的代码，首先是创建了一个<code>Entry</code>的数组，并且数组默认的大小是<code>16</code>。这个大小与<code>HashMap</code>的默认容量是一致的。接下来，我们根据<code>ThreadLocal</code>这个<code>Key</code>的<code>hash code</code>与<code>INITIAL_CAPACITY - 1</code>进行与运算，之所以这样，是因为默认情况下，数组的大小是<code>INITIAL_CAPACITY</code>，又因为数组是从0开始的，因此数组的下标范围是<code>[0,INITIAL_CAPACITY-1]</code>。而我们通过代码可以发现，在<code>ThreadLocal</code>中有一个神奇的数字<code>0x61c88647</code>。这个数字的目的是为了实现让多个<code>ThreadLocal</code>中可以实现让<code>hash code</code>均匀的分布在<code>2的n次方</code>中，同时，如果发生了碰撞，此时还可以利用了<code>开放定址法</code>来解决碰撞的问题。</p><p>在上面的代码中，当我们获取到数组下边后，通过创建一个<code>Entry</code>来放到数组中，同时设置数组的使用度<code>size</code>为<code>1</code>。同时设置<code>Map</code>的阈值为<code>16*2/3</code>为<code>10</code>。当数组中的使用度<code>size</code>大于10的时候，将进行扩容。</p><p>接下来，我们看下第二个构造函数。第二个构造函数的目的是当我们已经有一个<code>ThreadLocalMap</code>的时候，来创建另外一个<code>ThreadLocalMap</code>时进行调用。这个构造函数的调用仅会被<code>InheritableThreadLocal</code>调用。此时我们会在讲解<code>InheritableThreadLocal</code>时进行讲解。</p><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><p>当<code>ThreadLocalMap</code>中的<code>Entry数组</code>超过阈值之后，此时会对<code>Entry数组</code>进行扩容，扩容的代码如下：</p><pre><code class="java">/*** Double the capacity of the table.*/private void resize() &#123;    Entry[] oldTab = table;    int oldLen = oldTab.length;    int newLen = oldLen * 2;    Entry[] newTab = new Entry[newLen];    int count = 0;    for (int j = 0; j &lt; oldLen; ++j) &#123;        Entry e = oldTab[j];        if (e != null) &#123;            ThreadLocal&lt;?&gt; k = e.get();            if (k == null) &#123;                e.value = null; // Help the GC            &#125; else &#123;                int h = k.threadLocalHashCode &amp; (newLen - 1);                while (newTab[h] != null)                    h = nextIndex(h, newLen);                newTab[h] = e;                count++;            &#125;        &#125;    &#125;    setThreshold(newLen);    size = count;    table = newTab;&#125;</code></pre><p>我们来看下，<code>JDK</code>的库工程师是如何对数组进行高效扩容的。首先会去创建一个有原来两倍大小的新<code>Entry</code>数组，然后遍历老数组，获取老数组中每个数组的元素。如果元素不为空，则判断当前元素的<code>ThreadLocal</code>是否还在被引用，如果没有，则直接将<code>value</code>设置为null，帮助<code>GC</code>清理。否则的话，将会根据<code>int h = k.threadLocalHashCode &amp; (newLen - 1);</code>的值，同时根据<code>线性开放定址法</code>来元素应该在数组中的真正下标，然后将元素放入到数组中。最后设置新的数组的阈值和使用度<code>size</code>。</p><h4 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h4><p>在上面，我们讲解了<code>resize</code>方法，其实，<code>resize</code>方法是被<code>rehash</code>方法调用的。我们发现在<code>set</code>方法中，有如下的源码：</p><pre><code class="java">if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)    rehash();</code></pre><p>我们发现，如果在<code>set</code>方法触发了某些条件后，将会执行<code>rehash</code>方法。至于具体的条件的原因，会在接下来的<code>set</code>方法讲解的时候进行说明。</p><p>既然知道了是从何处进行调用的，那么我们就来看下<code>rehash</code>的源码：</p><pre><code class="java">    /**    * Re-pack and/or re-size the table. First scan the entire    * table removing stale entries. If this doesn&#39;t sufficiently    * shrink the size of the table, double the table size.    */private void rehash() &#123;    expungeStaleEntries();    // Use lower threshold for doubling to avoid hysteresis    if (size &gt;= threshold - threshold / 4)        resize();&#125;</code></pre><p>通过源码，我们可以发现，此时回去调用<code>expungeStaleEntries</code>方法。在调用后，如果<code>size</code>依然大于<code>threshold - threshold / 4</code>。此时会执行<code>resize</code>方法。因此，在这个方法中，<code>expungeStaleEntries</code>是重点。</p><pre><code class="java">    /**    * Expunge all stale entries in the table.    */    private void expungeStaleEntries() &#123;        Entry[] tab = table;        int len = tab.length;        for (int j = 0; j &lt; len; j++) &#123;            Entry e = tab[j];            if (e != null &amp;&amp; e.get() == null)                expungeStaleEntry(j);        &#125;    &#125;</code></pre><p>通过这个代码的注释，我们发现，这个方法的目的是为了实现将<code>Entry</code>数组中无效信息清除掉。具体是怎么做的呢？其实很简单，就是遍历数组中的每个元素，如果发现当前<code>Entry</code>有值，但是没有任何引用，则直接调用<code>expungeStaleEntry</code>方法。</p><pre><code class="java">/*** Expunge a stale entry by rehashing any possibly colliding entries* lying between staleSlot and the next null slot.  This also expunges* any other stale entries encountered before the trailing null.  See* Knuth, Section 6.4** @param staleSlot index of slot known to have null key* @return the index of the next null slot after staleSlot* (all between staleSlot and this slot will have been checked* for expunging).*/private int expungeStaleEntry(int staleSlot) &#123;    Entry[] tab = table;    int len = tab.length;    // expunge entry at staleSlot    tab[staleSlot].value = null;    tab[staleSlot] = null;    size--;    // Rehash until we encounter null    Entry e;    int i;    for (i = nextIndex(staleSlot, len);            (e = tab[i]) != null;            i = nextIndex(i, len)) &#123;        ThreadLocal&lt;?&gt; k = e.get();        if (k == null) &#123;            e.value = null;            tab[i] = null;            size--;        &#125; else &#123;            int h = k.threadLocalHashCode &amp; (len - 1);            if (h != i) &#123;                tab[i] = null;                // Unlike Knuth 6.4 Algorithm R, we must scan until                // null because multiple entries could have been stale.                while (tab[h] != null)                    h = nextIndex(h, len);                tab[h] = e;            &#125;        &#125;    &#125;    return i;&#125;</code></pre><p>这段代码有点绕，接下来，我们通过一张图的方式来进行讲解，在接下来的解释中，我们会用到<code>线性嗅探的开放定址法</code>。</p><p>加入我们下载有9个线程，他们的<code>threadLocalHashCode</code>分别问<code>[47,7,29,11,9,84,54,20,30]</code>。我们的<code>Entry数组</code>的大小为16。</p><p>接下来，我们看下，他们默认的在数组中的位置：</p><p><img src="https://shengouqiang.cn/img/Java/LearnDay01/EntryPicture01.jpg" alt="Entry数组初始位置"></p><p>我们假设在<code>index</code>为<code>4</code>的时候，此时的<code>ThreadLocal</code>为<code>null</code>,则触发<code>expungeStaleEntry</code>操作。此时我们会将<code>tab[4]</code>的<code>value</code>设置为<code>null</code>。同时，<code>tab[4]=null</code>。然后我们从<code>index=5</code>的时候开始算，此时<code>i=5</code>。</p><ol><li>判断<code>tab[5]</code>为否为<code>null</code>。如果为<code>null</code>,结束流程，否则执行下一步</li><li>判断<code>tab[5]</code>是否存在<code>ThreadLocal</code>。如果不存在，则将<code>tab[5]</code>的<code>value</code>设置为<code>null</code>，同时<code>tab[5]=null</code>、<code>size</code>减一；如果存在这行下一步</li><li>如果存在<code>ThreadLocal</code>，则判断当前值应当在数组中的位置是否是当前位置，如果不是，也就是发生过<code>线性嗅探</code>，则将当前节点这是为<code>null</code>。然后从应该存在的位置从新进行<code>线性嗅探</code>。</li></ol><p>因此，对于<code>i=5</code>而言，首先会将<code>tab[5]=null</code>,然后从<code>index=4</code>处开始<code>线性嗅探</code>，此时发现<code>table[5]</code>为<code>null</code>,然后将<code>20</code>重新插入到<code>tab[5]</code>中。接下来以此类推。最终的结果是：</p><p><img src="https://shengouqiang.cn/img/Java/LearnDay01/EntryPicture02.jpg" alt="Entry数组初始位置"></p><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>在上面，我们讲解了<code>ThreadLocal</code>的<code>get</code>方法。接下来，我们讲解下<code>ThreadLocal</code>的set方法。</p><pre><code class="java">/*** Sets the current thread&#39;s copy of this thread-local variable* to the specified value.  Most subclasses will have no need to* override this method, relying solely on the &#123;@link #initialValue&#125;* method to set the values of thread-locals.** @param value the value to be stored in the current thread&#39;s copy of*        this thread-local.*/public void set(T value) &#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);&#125;</code></pre><p>对于<code>set</code>方法十分的简单，就是查询一下，当前map是否存在如果如在，直接执行put方法。如果不存在，则执行上面讲解的<code>createMap</code>方法。这里有一点要注意一下，如果我们在创建了<code>ThreadLocal</code>后先执行了<code>set</code>方法，则在<code>get</code>的时候，就直接过去，不会在执行<code>get</code>里面的<code>setInitialValue</code>方法了。</p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><p>对于<code>remove</code>方法，则十分的简单</p><pre><code class="java">/*** Removes the current thread&#39;s value for this thread-local* variable.  If this thread-local variable is subsequently* &#123;@linkplain #get read&#125; by the current thread, its value will be* reinitialized by invoking its &#123;@link #initialValue&#125; method,* unless its value is &#123;@linkplain #set set&#125; by the current thread* in the interim.  This may result in multiple invocations of the* &#123;@code initialValue&#125; method in the current thread.** @since 1.5*/public void remove() &#123;    ThreadLocalMap m = getMap(Thread.currentThread());    if (m != null)        m.remove(this);&#125;</code></pre><p>对于<code>remove</code>方法，则直接调用<code>map</code>的<code>remove</code>方法。删除当前的<code>Entry</code>即可。</p><h2 id="InheritableThreadLocal类"><a href="#InheritableThreadLocal类" class="headerlink" title="InheritableThreadLocal类"></a>InheritableThreadLocal类</h2><p>在上面的代码中，我们讲解了<code>ThreadLocal</code>。其实在<code>JDK</code>中，还有一个类似<code>ThreadLocal</code>的存在，那就是<code>InheritableThreadLocal</code>。它与<code>ThreadLocal</code>不同的是，<code>ThreadLocal</code>仅仅只在当前线程有效，在子线程中是无效的。而<code>InheritableThreadLocal</code>是可以继承当前父线程中的<code>InheritableThreadLocal</code>的值。</p><p><code>ThreadLocal</code>与<code>InheritableThreadLocal</code>的使用方式都是相同的。在接下来的讲解中，我们会进行举例说明。</p><p>在讲解<code>InheritableThreadLocal</code>的时候，我不会采用全量的方式进行讲解，只有发现与<code>ThreadLocal</code>不同的地方，才会进行重点讲解。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>InheritableThreadLocal</code>的初始化方法与<code>ThreadLocal</code>是有很大的不同的。因为对于<code>ThreadLocal</code>而言，它的变量定义是在<code>Thread</code>中，而初始化是通过<code>ThreadLocal</code>的构造函数，或者是<code>SuppliedThreadLocal</code>的构造函数完成的。</p><p>而<code>InheritableThreadLocal</code>的定义依然是在<code>Thread</code>中的，因此他与<code>ThreadLocal</code>是一样的，都是线程私有的。但是他的初始化方法，除了<code>InheritableThreadLocal</code>构造方法。更更重要的是在<code>Thread</code>的<code>init</code>方法进行初始化的。接下来，我们看下代码：</p><pre><code class="java">if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)    this.inheritableThreadLocals =        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</code></pre><p>这段代码是<code>init</code>方法中的部分代码，其中，我们不管<code>inheritThreadLocals</code>变量，因为他默认是<code>true</code>。我们主要关心的是<code>&amp;&amp;</code>之后的判断，在这里，他会判断当前线程的父线程的<code>inheritableThreadLocals</code>是否为<code>null</code>，如果不为<code>null</code>，则会调用<code>ThreadLocal</code>的<code>createInheritedMap</code>方法。而<br><code>createInheritedMap</code>的源码如下：</p><pre><code class="java">/*** Factory method to create map of inherited thread locals.* Designed to be called only from Thread constructor.** @param  parentMap the map associated with parent thread* @return a map containing the parent&#39;s inheritable bindings*/static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;    return new ThreadLocalMap(parentMap);&#125;</code></pre><p>此时我们发现，它调用的是<code>ThreadLocal</code>的第二个构造函数，也就是我们在上面没有进行讲解的那个构造函数。为了方便理解，我们再贴一下第二个构造函数的源码：</p><pre><code class="java">/*** Construct a new map including all Inheritable ThreadLocals* from given parent map. Called only by createInheritedMap.** @param parentMap the map associated with parent thread.*/private ThreadLocalMap(ThreadLocalMap parentMap) &#123;    Entry[] parentTable = parentMap.table;    int len = parentTable.length;    setThreshold(len);    table = new Entry[len];    for (int j = 0; j &lt; len; j++) &#123;        Entry e = parentTable[j];        if (e != null) &#123;            @SuppressWarnings(&quot;unchecked&quot;)            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();            if (key != null) &#123;                Object value = key.childValue(e.value);                Entry c = new Entry(key, value);                int h = key.threadLocalHashCode &amp; (len - 1);                while (table[h] != null)                    h = nextIndex(h, len);                table[h] = c;                size++;            &#125;        &#125;    &#125;&#125;</code></pre><p>在这个方法中，就是通过获取父线程的<code>parentMap.table</code>的值，然后添加到子线程中去，如果发生了碰撞，则通过<code>线性嗅探的开放定址法</code>来确定最终的<code>index</code>，然后添加到子线程的<code>map</code>中去。在这里，我们要注意一个方法<code>childValue</code>。</p><pre><code class="java">/*** Computes the child&#39;s initial value for this inheritable thread-local* variable as a function of the parent&#39;s value at the time the child* thread is created.  This method is called from within the parent* thread before the child is started.* &lt;p&gt;* This method merely returns its input argument, and should be overridden* if a different behavior is desired.** @param parentValue the parent thread&#39;s value* @return the child thread&#39;s initial value*/protected T childValue(T parentValue) &#123;    return parentValue;&#125;</code></pre><p>我们发现，这个方法仅仅只是保留的方法。如果需要，我们可以通过集成来实现自己的逻辑。同时，需要注意一下，如果往<code>InheritableThreadLocal</code>放的是一个引用类型，例如<code>Map</code>等。此时会出现父类和子类公用一个<code>Map</code>的问题。如果有这方面的需要，我们需要去集成这个类，重写<code>childValue</code>方法。</p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><pre><code class="java">import java.util.HashMap;import java.util.Map;public class ThreadLocalTest &#123;    private static final ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();    private static final InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;();    static void getThreadLocal()&#123;        System.out.println(Thread.currentThread().getName() + &quot;---&gt;threadLocal---&gt;&quot;+threadLocal.get());        System.out.println(Thread.currentThread().getName() + &quot;---&gt;inheritableThreadLocal---&gt;&quot;+inheritableThreadLocal.get());    &#125;    public static void main(String[] args) throws InterruptedException &#123;        threadLocal.set(&quot;shen1&quot;);        inheritableThreadLocal.set(&quot;gou1&quot;);        getThreadLocal();        Thread thread = new Thread1();        thread.setName(&quot;thread1&quot;);        thread.start();        Thread.sleep(6000);        getThreadLocal();    &#125;    static class Thread1 extends Thread&#123;        @Override        public void run() &#123;            super.run();            getThreadLocal();            threadLocal.set(&quot;shen2&quot;);            inheritableThreadLocal.set(&quot;gou2&quot;);            Thread thread = new Thread2();            thread.setName(&quot;thread2&quot;);            thread.start();            getThreadLocal();        &#125;    &#125;    static class Thread2 extends Thread&#123;        @Override        public void run() &#123;            super.run();            getThreadLocal();            threadLocal.set(&quot;shen3&quot;);            inheritableThreadLocal.set(&quot;gou3&quot;);            getThreadLocal();        &#125;    &#125;&#125;</code></pre><p>程序结果运行如下：</p><pre><code>main---&gt;threadLocal---&gt;shen1main---&gt;inheritableThreadLocal---&gt;gou1thread1---&gt;threadLocal---&gt;nullthread1---&gt;inheritableThreadLocal---&gt;gou1thread1---&gt;threadLocal---&gt;shen2thread1---&gt;inheritableThreadLocal---&gt;gou2thread2---&gt;threadLocal---&gt;nullthread2---&gt;inheritableThreadLocal---&gt;gou2thread2---&gt;threadLocal---&gt;shen3thread2---&gt;inheritableThreadLocal---&gt;gou3main---&gt;threadLocal---&gt;shen1main---&gt;inheritableThreadLocal---&gt;gou1</code></pre><h2 id="模拟ThreadLocal内存泄漏的案例"><a href="#模拟ThreadLocal内存泄漏的案例" class="headerlink" title="模拟ThreadLocal内存泄漏的案例"></a>模拟ThreadLocal内存泄漏的案例</h2><p>在上面的文章中，我们发现，<code>ThreadLocal</code>其实是<code>弱引用</code>。并且网上总是说，如果使用不当，会造成内存泄露的问题。因此我们现在测试一下：</p><pre><code class="java">package com.gouqiang.shen.threadlocal;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class TestOne &#123;    /**     * 校验内存泄露     */    public static void testThreadLocalMemoryLeak()&#123;        ExecutorService service = Executors.newSingleThreadExecutor();        ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            if(i == 0)&#123;                service.execute(new Runnable() &#123;                    @Override                    public void run() &#123;                        System.out.println(&quot;Thread id is &quot; + Thread.currentThread().getId());                        threadLocal.set(&quot;variable&quot;);                    &#125;                &#125;);            &#125; else if(i &gt; 0)&#123;                service.execute(new Runnable() &#123;                    @Override                    public void run() &#123;                        if(&quot;variable&quot;.equals(threadLocal.get()))&#123;                            System.out.println(&quot;Thread id &quot; + Thread.currentThread().getId() + &quot; got it !&quot;);                        &#125;                    &#125;                &#125;);            &#125;        &#125;        service.shutdown();    &#125;    public static void main(String[] args) &#123;        testThreadLocalMemoryLeak();    &#125;&#125;</code></pre><p>运行结果如下</p><pre><code>Thread id is 12Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !Thread id 12 got it !</code></pre><p>我们发现，在不使用线程池的前提下，即使不调用remove方法，线程的”变量副本”也会被gc回收，即不会造成内存泄漏的情况。但是如果使用线程池的情况下，因为线程使用完毕，不是被销毁，而是被还给线程池，当我们下次使用的时候，就会获取上次线程池的值。因此，就会发生内存泄露的问题。如果我们放的是一个<code>Map</code>，而不是一个<code>String</code>的话，随着<code>put</code>的次数越来越多，<code>Map</code>中的内容越来越大。极有可能会导致内存溢出的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>花了两天的时间，总结了下<code>ThreadLocal</code>的底层源码，对于<code>Hash</code>的理解也更加的深刻。同时对于为什么<code>ThreadLocal</code>是线程私有化的也有了更加深刻的理解。在以后的开发与使用中，会有更大的收益。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> 锁问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java--ReentrantLock</title>
      <link href="//JavaLock/JavaLockDay03/"/>
      <url>//JavaLock/JavaLockDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="Java–ReentrantLock"><a href="#Java–ReentrantLock" class="headerlink" title="Java–ReentrantLock"></a>Java–ReentrantLock</h1><p>在<code>JDK</code>的代码中，我们用于实现<code>同步方法</code>的常用的来说，有三种</p><ol><li><code>synchronize</code></li><li><code>ReentrantLock</code></li><li><code>countDownLatch</code></li></ol><p>其中，我们已经在上一篇文章中讲解了<a href="/JavaLock/JavaLockDay02/">synchronize</a>，现在，我们讲解下<code>ReentrantLock</code>。</p><p>在<code>ReentrantLock</code>中，我们的锁既可以是<code>公平锁</code>,也可以是<code>非公平锁</code>。至于具体是哪一种，是根据我们在初始化<code>ReentrantLock</code>时，通过构造函数的请求参数来设置的。另外，提一句，<code>synchronize</code>只能是非公平锁。 </p><pre><code class="java">    public ReentrantLock() &#123;        sync = new NonfairSync();    &#125;    public ReentrantLock(boolean fair) &#123;        sync = fair ? new FairSync() : new NonfairSync();    &#125;</code></pre><p>通过上面的代码，我们可以发现，如果我们调用无参的构造函数<code>ReentrantLock()</code>，则默认的是<code>非公平锁</code>；而如果我们调用的是有参的构造函数<code>ReentrantLock(boolean fair)</code>,则取决于我们传入的参数，如果是<code>false</code>，则采用的是<code>非公平锁</code>，而如果是<code>true</code>，则采用的是<code>公平锁</code>。</p><p>那么，对于<code>公平锁</code>和<code>非公平锁</code>，<code>ReentrantLock</code>是怎么实现的呢？</p><p>我们通过上面的代码可以看出，如果我们采用<code>ReentrantLock()</code>和<code>ReentrantLock(false)</code>的时候，此时获取的是<code>非公平锁</code>。此时，我们使用的是<code>NonfairSync</code>这个静态内部类产生的对象，那么<code>ReentrantLock</code>是怎么实现非公平锁的呢？</p><p>在我们真正的讲解<code>ReentrantLock</code>的非公平锁，其实，我们就是在讲<code>NonFairSync</code>这个类。既然，我们想要讲解这个类，那么就面临着我们要知道这个类的一个类图：</p><p><img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay03/NonFairSync.jpg" alt="ReentrantLockNonFairLock"></p><p>接下来，问主要看下这个类。</p><h2 id="NonFairSync实现非公平锁-加锁"><a href="#NonFairSync实现非公平锁-加锁" class="headerlink" title="NonFairSync实现非公平锁(加锁)"></a>NonFairSync实现非公平锁(加锁)</h2><p>首先，我们看下<code>NonfairSync</code>的源码：</p><pre><code class="java">static final class NonfairSync extends Sync &#123;    private static final long serialVersionUID = 7316153563782823691L;    /**        * Performs lock.  Try immediate barge, backing up to normal        * acquire on failure.        */    final void lock() &#123;        if (compareAndSetState(0, 1))            setExclusiveOwnerThread(Thread.currentThread());        else            acquire(1);    &#125;    protected final boolean tryAcquire(int acquires) &#123;        return nonfairTryAcquire(acquires);    &#125;&#125;public abstract class AbstractQueuedSynchronizer    extends AbstractOwnableSynchronizer    implements java.io.Serializable &#123;     public final void acquire(int arg) &#123;        if (!tryAcquire(arg) &amp;&amp;            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))            selfInterrupt();    &#125;    private Node addWaiter(Node mode) &#123;        Node node = new Node(Thread.currentThread(), mode);        // Try the fast path of enq; backup to full enq on failure        Node pred = tail;        if (pred != null) &#123;            node.prev = pred;            if (compareAndSetTail(pred, node)) &#123;                pred.next = node;                return node;            &#125;        &#125;        enq(node);        return node;    &#125;&#125;</code></pre><p>在上面，我们已经罗列出了所有的主要的源码的信息。接下来，我们一点一点的进行分析。</p><h3 id="lock方法"><a href="#lock方法" class="headerlink" title="lock方法"></a>lock方法</h3><p>首先，我们查看<code>NonFairSync</code>的<code>lock</code>方法，我们发现，其实对于<code>lock</code>方法而言，很简单。就是如果当前线程需要锁，则首先通过<code>CAS</code>自旋的方式，去获取锁，如果锁不存在，那么就去执行<code>acquire</code>方法。</p><h3 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h3><p>然而，在<code>acquire</code>方法中，我们看到，主要的业务逻辑在<code>if</code>的判断中。在这里，我们发现，<code>JDK</code>的库工程师们采用了<code>模板方法</code>的设计模式，将整个加锁的过程，已经固化了，只是在不同的地方，需要实现者自己去实现而已。因此，<code>tryAcquire</code>方法就是由<code>NonFairSync</code>自己去实现的。而<code>NonFairSync</code>中的<code>tryAcquire</code>方法，仅仅只是调用底层的<code>nonfairTryAcquire</code>方法而已。而在<code>nonfairTryAcquire</code>方法中，我们发现一个神奇的事情，那就是这个方法中对于获取锁，它仍然通过了一次<code>CAS</code>自旋的方式去获取锁。如果没有获取到，才会执行下面的步骤。</p><p>那在这里就有一个问题了，因为我们在之前的<code>lock</code>方法中，已经通过<code>CAS</code>自旋的方式去尝试获取锁而失败了，那么为什么我们还要在<code>nonfairTryAcquire</code>中再执行一次呢？其实，这里面有一个效率的问题。在这里，是一个典型的通过增加一些冗余代码的方式，来提高执行效率的问题。</p><p>OK，到这里，我们开始重新的讲解一下<code>acquire</code>这个方法。在这个方法中，我们发现：他的主要部分是放在了<code>if</code>语句的里面。在<code>if</code>语句中，采用的是短路的原则，来进行一步一步的设置。接下俩，我们讲解下：</p><h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>我们首先执行的是<code>tryAcquire</code>方法。通过名字可以知道，这个代码的含义是”获取锁”。只有我们获取失败的时候，才会执行后续的流程。</p><ol><li><code>tryAcquire</code>方法调用的是<code>nonfairTryAcquire</code>方法。</li><li>在<code>nonfairTryAcquire</code>中，我们首先会拿到当前线程，通过新创建一个<code>Node</code>的方式，将当前线程信息存放到<code>Node</code>信息中。此时我们会判断当前线程是否已经获取到锁。<ul><li>如果没有获取到锁，则通过一次<code>CAS</code>自旋来获取锁，如果获取成功，此时我们继续下当前线程的信息，以便后续重入锁的时候使用。</li><li>如果我们获取锁失败，此时我们查看当前线程是否已经获取到锁，如果发现已经获取，则直接通过重入锁来获取当前锁。并且将<code>state</code>加<code>1</code>。在这里，<code>state</code>表示的是锁的重入次数。</li><li>如果上述两种情况，我们都没有获取到锁，则直接返回<code>false</code>,表示获取锁失败。</li></ul></li></ol><h3 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h3><p>这个方法的调用前提是在<code>tryAcquire</code>获取锁失败的时候进行调用的。这个方法的主要目的是为了将未获取到锁的线程，通过<code>Node</code>的方式来添加到<code>队列</code>中。到此，我们需要介绍一下<code>AbstractQueuedSynchronizer</code>也就是<code>AQS</code>和他用户存储阻塞线程的<code>队列</code>的数据结构。</p><h4 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h4><p><code>AbstractQueuedSynchronizer</code>，我们俗称<code>AQS</code>。这个类是实现<code>ReentrantLock</code>锁的重要类。这个类采用的是设计模式中的<code>模板方法</code>。他帮我们默认了提供了一套关于锁的解决方法。但是对于内部的一些实现，是需要子类去自己实现的,例如<code>tryAcquire</code>方法。同时，我们的<code>NonFairSync</code>也是继承了这个类。在这个类中，存在了两个成员变量<code>head</code>和<code>tail</code>。这两个变量，一个是指定了<code>队列</code>的头节点，一个指定了<code>队列</code>的尾节点。注意的是，这个<code>队列</code>采用的是<code>懒加载</code>模式。默认情况下，<code>head</code>和<code>tail</code>的值为<code>null</code>。如果举例，我们可以这样表示：</p><p><img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay03/AQSStructor.jpg" alt="ReentrantLockNonFairLock"></p><p>对于<code>AbstractQueuedSynchronizer</code>的介绍，我们会在后续的文章中进行讲解的。</p><h4 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a><code>队列</code>的存储结构</h4><p>在<code>AbstractQueuedSynchronizer</code>中，我们所有的未获取到锁的线程都会添加到一个<code>队列</code>当中。而这个队列，采用的是一个数据结构中典型的<code>无头的双向链表</code>的数据模型。对于<code>列表</code>中的每一个节点<code>Node</code>，主要是由</p><ul><li><code>waitStatus</code><span style="color:red;"> - </span>当前节点的状态，其中有<ul><li><code>SIGNAL</code><span style="color:red;"> - </span>值为<code>-1</code>，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行</li><li><code>CANCELLED</code><span style="color:red;"> - </span>值为<code>1</code>，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化</li><li><code>CONDITION</code><span style="color:red;"> - </span>值为<code>-2</code>，与Condition相关，该标识的结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁</li><li><code>PROPAGATE</code><span style="color:red;"> - </span>值为<code>-3</code>，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态</li><li><code>0</code><span style="color:red;"> - </span>值为<code>0</code>，代表初始化状态</li></ul></li><li><code>prev</code><span style="color:red;"> - </span>当前节点的前置节点</li><li><code>next</code><span style="color:red;"> - </span>当前节点的后置节点</li><li><code>thread</code><span style="color:red;"> - </span>当前节点对应的线程</li></ul><p>当前，<code>Node</code>节点还存在一些其他的变量，在这里，我们主要关注的就是上面的这几个。对于<code>AQS</code>而言，我们创建的队列正是通过<code>Node</code>节点组成的一个<code>FIFO</code>的队列。他的格式如下</p><p><img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay03/AQSFIFOQUEUE.jpg" alt="AQS的FIFO队列"></p><hr><p>OK，有了上面的前提，我们再看看<code>addWaiter</code>这段代码。同样的，这段代码中，<code>JDK</code>的库工程师们依然采用了通过冗余代码来提高效率的方式来提升性能，因此，我们只需要看<code>enq</code>这个方法即可。其中，源码如下：</p><pre><code class="java">    private Node enq(final Node node) &#123;        for (;;) &#123;            Node t = tail;            if (t == null) &#123; // Must initialize                if (compareAndSetHead(new Node()))                    tail = head;            &#125; else &#123;                node.prev = t;                if (compareAndSetTail(t, node)) &#123;                    t.next = node;                    return t;                &#125;            &#125;        &#125;    &#125;</code></pre><p>在这段代码中，我们依然是通过一个死循环的方式来执行的。首先我们会判断<code>tail</code>这个指针。如果我们发现<code>tail</code>指针为<code>null</code>，那么此时这个队列中根本就不存在。这个也是之前我们讲解的，<code>AQS</code>的<code>队列</code>采用的<code>懒加载</code>的模式进行初始化的(也就是说，并不是事先初始化，而是在我们使用的时候进行初始化)。因此，在<code>for</code>循环中的第一个<code>if</code>中，就是为了来初始化<code>队列</code>的操作。在初始化完成操作之后，会将<code>head</code>和<code>tail</code>都指向这个新创建的<code>Node</code>节点。注意，这个节点不存在任何的<code>thread</code>信息。它仅仅指向的是一个<code>阻塞队列</code>。</p><p>在这里，我们会想到，会不会存在并发的问题呢？其实，是不存在。因为就算是有多个线程进入了<code>for</code>循环内，此时多个线程都获取到了<code>tail</code>为<code>null</code>的情况，此时都回去执行<code>compareAndSetHead</code>方法。但是在<code>compareAndSetHead</code>中，采用了<code>CAS</code>自旋锁的方式进行设置，因此，只可能有一个线程成功，其他的线程都是不会成功的。这样也就解决了<code>并发</code>的问题。</p><p>当执行完第一个<code>if</code>语句后，或者是当前的<code>队列</code>不为空时，此时会执行<code>else</code>里面的语句。此时，我们会当前节点<code>node</code>的<code>prev</code>指向队列的前一个节点，然后通过<code>CAS</code>自旋的方式，将当前节点添加到队列的后面。然后将前面一个节点<code>next</code>指向当前节点。最后返回插入节点的<code>prev</code>节点。</p><h3 id="acquireQueued方法"><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h3><p>你有可能会问，到目前为止，我们都是将线程添加到了阻塞队列中，但是并没有去获取锁啊。别急，<code>acquireQueued</code>方法就是对于锁<code>队列</code>的操作过程。同时，也是<code>lock</code>方法的重点方法，我们会以最简便的方式，来进行讲解。</p><p>方法的源码如下：</p><pre><code class="java">   final boolean acquireQueued(final Node node, int arg) &#123;        boolean failed = true;        try &#123;            boolean interrupted = false;            for (;;) &#123;                final Node p = node.predecessor();                if (p == head &amp;&amp; tryAcquire(arg)) &#123;                    setHead(node);                    p.next = null; // help GC                    failed = false;                    return interrupted;                &#125;                if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                    parkAndCheckInterrupt())                    interrupted = true;            &#125;        &#125; finally &#123;            if (failed)                cancelAcquire(node);        &#125;    &#125;     private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;        int ws = pred.waitStatus;        if (ws == Node.SIGNAL)            /*             * This node has already set status asking a release             * to signal it, so it can safely park.             */            return true;        if (ws &gt; 0) &#123;            /*             * Predecessor was cancelled. Skip over predecessors and             * indicate retry.             */            do &#123;                node.prev = pred = pred.prev;            &#125; while (pred.waitStatus &gt; 0);            pred.next = node;        &#125; else &#123;            /*             * waitStatus must be 0 or PROPAGATE.  Indicate that we             * need a signal, but don&#39;t park yet.  Caller will need to             * retry to make sure it cannot acquire before parking.             */            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);        &#125;        return false;    &#125;    private final boolean parkAndCheckInterrupt() &#123;        LockSupport.park(this);        return Thread.interrupted();    &#125;       </code></pre><p>首先，我们发现这里仍然是一个<code>死循环</code>的方式。然后再<code>for</code>循环中进行了两次判断。</p><p>对于第一个<code>if</code>语句，我们首先获取当前节点<code>prev</code>节点是不是一个<code>head</code>节点，如果不是<code>head</code>节点，则跳出当前的<code>if</code>判断。那么，这里就有一个问题，我们为什么非要看当前节点是不是在<code>head</code>之后的第一个呢？是因为</p><ol><li><code>head</code>节点是不存在获取权限判断的。<code>head</code>节点存在的目的，是为了形成一个队列</li><li>我们始终认为，<code>head</code>节点后面的第一个节点是目前正在获取锁的节点，对于之后的节点，都需要前置的节点已经获取锁才可以。</li><li>对于当前获取锁的节点，我们需要保证我们的后续节点的<code>waitState</code>一定是<code>SIGNAL</code>。</li></ol><p>所以，在这里，我们解释了为什么判断当前的节点的<code>prev</code>一定是<code>head</code>的原因。接下来，就是如果当前的<code>node</code>是<code>head</code>的后置节点，我们就要去获取锁，如果获取锁失败，则会执行第二个<code>if</code>语句。如果获取成功</p><ol><li>将当前的node节点设置为<code>head</code>节点。</li><li>将之前的head节点弃用,从<code>GCRoots</code>下摘掉，帮助<code>GC</code>进行清理</li><li>将<code>failed</code>改成false，表示我们已经获取到锁。防止在<code>finally</code>中执行<code>cancelAcquire</code>操作。</li><li>通过返回一个<code>false</code></li></ol><p>你有可能会问，我们已经拿到锁了，为什么还要返回<code>false</code>呢？其实，这个方法的返回值表示的并不是我们有没有拿到锁，而是我们在获取锁的过程中，是否发生了<code>interrupt</code>操作。正是因为我们拿到了锁，所以，才是返回<code>false</code>。</p><p>接下来，我们看下关于第二个<code>if</code>操作。第二个<code>if</code>操作，主要对于如果我们获取锁失败，或者当前节点不是<code>head</code>的后继节点的情况，这样的情况，笼统的讲，就是将自己变成<code>waiting</code>状态。具体如下：</p><ol><li>程序首先执行<code>shouldParkAfterFailedAcquire</code>方法，通过这个方法，我们可以猜到，这个方法的目的就是当我们获取锁失败的时候，应该去阻塞我们的线程。在这里<code>Park</code>和我们的<code>wait</code>是很像的。通过方法的源码我们可以知道：<ul><li>如果当前节点的<code>prev</code>节点是<code>SIGNAL</code>状态，则是允许我们将当前节点阻塞的。因为只有是<code>SIGNAL</code>状态的节点，才会被<code>head</code>进行唤醒，并且获取锁。</li><li>如果我们的<code>prev</code>节点是<code>CANCELLED</code>状态，那么证明这些节点是在等待的过程中，已经取消的了，是不需要在获取锁的。我们会一直往前找，直到找到第一个节点的状态是<code>SIGNAL</code>的节点为止，然后将当前节点挂在这个节点的后面。</li><li>如果我们的节点是一个初始化的节点，那么需要将前置节点的<code>waitState</code>设置为<code>SIGNAL</code>状态。</li></ul></li><li>对于上面的第<code>2</code>、<code>3</code>点，是需要重新执行<code>for</code>循环的。因为我们之前的<code>队列</code>是存在问题。因此需要重新执行。之后当队列不存在问题，此时，我们会执行<code>parkAndCheckInterrupt</code>方法。通过方法的源码可以知道，它其实是调用<code>LockSupport.park</code>的方法，将线程进行阻塞。</li></ol><h3 id="cancelAcquire方法"><a href="#cancelAcquire方法" class="headerlink" title="cancelAcquire方法"></a>cancelAcquire方法</h3><p>如果程序在执行的过程中，发生了异常，此时会执行<code>finally</code>的方法。正常来讲，<code>finally</code>方法是方法结束后必须执行的方法，那么在这里，我们为什么要说是在发生异常后执行的呢？因为如果程序正常退出<code>for</code>循环，<code>failed</code>一定是<code>false</code>。只有当程序发生异常，此时<code>failed</code>才会为<code>true</code>。接下来，我们看下<code>cancelAcquire</code>方法的源码：</p><pre><code class="java">    private void cancelAcquire(Node node) &#123;        // Ignore if node doesn&#39;t exist        if (node == null)            return;        node.thread = null;        // Skip cancelled predecessors        Node pred = node.prev;        while (pred.waitStatus &gt; 0)            node.prev = pred = pred.prev;        // predNext is the apparent node to unsplice. CASes below will        // fail if not, in which case, we lost race vs another cancel        // or signal, so no further action is necessary.        Node predNext = pred.next;        // Can use unconditional write instead of CAS here.        // After this atomic step, other Nodes can skip past us.        // Before, we are free of interference from other threads.        node.waitStatus = Node.CANCELLED;        // If we are the tail, remove ourselves.        if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;            compareAndSetNext(pred, predNext, null);        &#125; else &#123;            // If successor needs signal, try to set pred&#39;s next-link            // so it will get one. Otherwise wake it up to propagate.            int ws;            if (pred != head &amp;&amp;                ((ws = pred.waitStatus) == Node.SIGNAL ||                 (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;                pred.thread != null) &#123;                Node next = node.next;                if (next != null &amp;&amp; next.waitStatus &lt;= 0)                    compareAndSetNext(pred, predNext, next);            &#125; else &#123;                unparkSuccessor(node);            &#125;            node.next = node; // help GC        &#125;    &#125;</code></pre><p>此时在程序中，我们进行了判断。</p><ol><li>如果当前节点为<code>null</code>,则不作任何处理，直接方法结束</li><li>将当前<code>node</code>与<code>thread</code>进行解绑</li><li>如果我们当前节点的<code>prev</code>的<code>waitState</code>大于<code>0</code>，则一直往前找，直到找到<code>waitState</code>为<code>SIGNAL</code>或者是初始化的。</li><li>获取这个<code>waitState</code>为<code>SIGNAL</code>或者是初始化的的节点的后置节点</li><li>将当前的节点设置为<code>CANCELLED</code></li><li>在这里，我们要分为<code>3</code>中情况进行考虑<ul><li>如果我们当前节点是<code>tail</code>节点，则我们将当前节点的<code>tail</code>指针指向当前节点的<code>prev</code>节点。然后将当前节点的<code>prev</code>节点的<code>next</code>指针设置为<code>null</code>，在下面我们用图1进行表示。<br>  <img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay03/picture01.jpg" alt="图1"></li><li>对于第二种情况，我们判断两个条件，如果满足以下条件，则获取当前<code>node</code>节点的<code>next</code>节点。如果<code>next</code>节点不为<code>null</code>,并且<code>next</code>节点的<code>waitState</code>为<code>SIGNAL</code>，则我们将当前<code>prev</code>的<code>next</code>指针指向<code>node</code>的<code>next</code>节点，在下面，我们用图2进行表示。<ul><li>当前<code>node</code>的<code>prev</code>节点不是<code>head</code>节点</li><li>当前<code>node</code>的<code>prev</code>节点的<code>waitState</code>为<code>SIGNAL</code>，或者我们可以将当前<code>node</code>的<code>prev</code>节点的<code>waitState</code>设置为<code>SIGNAL</code></li><li>当前<code>node</code>的<code>prev</code>节点的<code>thread</code>不为<code>null</code><br><img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay03/picture02.jpg" alt="图2"></li></ul></li><li>对于第三种情况，我们首先获取<code>node</code>的<code>waitState</code>，如果<code>waitState</code>小于<code>0</code>,则更新为<code>0</code>。如果当前<code>node</code>的<code>next</code>节点为<code>null</code>或者是<code>next</code>节点的<code>waitState</code>大于0，则从<code>tail</code>节点开始往前，一致找到在<code>node</code>节点之后的第一个<code>waitState</code>小于0的节点，然后将当前节点执行<code>LockSupport.unpark</code>。如果没有找到，则不进行任何操作，在下面，我们用图3进行表示。<br>  <img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay03/picture03.jpg" alt="图3"></li></ul></li></ol><h3 id="unlock方法"><a href="#unlock方法" class="headerlink" title="unlock方法"></a>unlock方法</h3><p>首先，废话不多说，我们先上源码：</p><pre><code class="java"> public final boolean release(int arg) &#123;        if (tryRelease(arg)) &#123;            Node h = head;            if (h != null &amp;&amp; h.waitStatus != 0)                unparkSuccessor(h);            return true;        &#125;        return false;    &#125;</code></pre><p>通过当前代码，我们可以发现：首先我们会尝试释放锁，如果释放锁成功，我们会当前<code>head</code>指向的<code>node</code>进行判断，</p><ol><li>如果不为<code>null</code>，则代表队列有值</li><li>如果<code>waitState</code>不是初始化</li></ol><p>只有满足以上两点，我们才能够将锁给接下来的线程。</p><p>首先，我们看下<code>tryRelease</code>方法</p><pre><code class="java">    protected final boolean tryRelease(int releases) &#123;        int c = getState() - releases;        if (Thread.currentThread() != getExclusiveOwnerThread())            throw new IllegalMonitorStateException();        boolean free = false;        if (c == 0) &#123;            free = true;            setExclusiveOwnerThread(null);        &#125;        setState(c);        return free;    &#125;</code></pre><p>首先我们会对当前的<code>state</code>减1操作，代表我们已经出了一次同步方法。如果此时我们的<code>state</code>为0，代表此时线程已经不再需要锁，同时我们会把重入锁的对象设置为<code>null</code>。</p><p>接下来，我们看下<code>unparkSuccessor</code>方法。</p><pre><code class="java">    private void unparkSuccessor(Node node) &#123;        /*         * If status is negative (i.e., possibly needing signal) try         * to clear in anticipation of signalling.  It is OK if this         * fails or if status is changed by waiting thread.         */        int ws = node.waitStatus;        if (ws &lt; 0)            compareAndSetWaitStatus(node, ws, 0);        /*         * Thread to unpark is held in successor, which is normally         * just the next node.  But if cancelled or apparently null,         * traverse backwards from tail to find the actual         * non-cancelled successor.         */        Node s = node.next;        if (s == null || s.waitStatus &gt; 0) &#123;            s = null;            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)                if (t.waitStatus &lt;= 0)                    s = t;        &#125;        if (s != null)            LockSupport.unpark(s.thread);    &#125;</code></pre><p>首先我们获取当前节点的<code>waitState</code>,如果当前节点为<code>SIGNAL</code>，则将节点更新为初始化状态。这是因为我们的入参<code>node</code>正好是<code>head</code>。而<code>head</code>正好是我们之前认为的已经获取到锁的线程，现在这个线程已经释放了锁，因此，我们必须将该线程的<code>waitState</code>的状态从小于0改掉，在这里，我们一般是改成0,然后我们会从<code>tail</code>开始往回找，直到找到最后一个<code>waitState</code>为<code>SIGNAL</code>的，如果存在，我们直接将其唤醒即可。</p><h2 id="ReentrantLock实现公平锁"><a href="#ReentrantLock实现公平锁" class="headerlink" title="ReentrantLock实现公平锁"></a>ReentrantLock实现公平锁</h2><h3 id="lock方法-1"><a href="#lock方法-1" class="headerlink" title="lock方法"></a>lock方法</h3><p>对于<code>ReentrantLock</code>而言，它的<code>公平锁</code>和<code>非公平锁</code>非常的类似，在这里，我们进行不同部分的代码讲解即可：</p><pre><code class="java">    final void lock() &#123;    acquire(1);    &#125;</code></pre><p>我们发现，在这里，它并没有通过<code>CAS</code>在一开始的时候去获取锁，而是走了通用的逻辑<code>acquire</code>。而我们的公平锁类<code>FairSync</code>通用的也实现了<code>tryAcquire</code>方法。</p><h3 id="tryAcquire方法-1"><a href="#tryAcquire方法-1" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><pre><code class="java">    protected final boolean tryAcquire(int acquires) &#123;        final Thread current = Thread.currentThread();        int c = getState();        if (c == 0) &#123;            if (!hasQueuedPredecessors() &amp;&amp;                compareAndSetState(0, acquires)) &#123;                setExclusiveOwnerThread(current);                return true;            &#125;        &#125;        else if (current == getExclusiveOwnerThread()) &#123;            int nextc = c + acquires;            if (nextc &lt; 0)                throw new Error(&quot;Maximum lock count exceeded&quot;);            setState(nextc);            return true;        &#125;        return false;    &#125;</code></pre><h3 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h3><p>在这里，我们发现，唯一的不同在于方法<code>hasQueuedPredecessors</code>,而<code>hasQueuedPredecessors</code>的源码为：</p><pre><code class="java">    public final boolean hasQueuedPredecessors() &#123;        // The correctness of this depends on head being initialized        // before tail and on head.next being accurate if the current        // thread is first in queue.        Node t = tail; // Read fields in reverse initialization order        Node h = head;        Node s;        return h != t &amp;&amp;            ((s = h.next) == null || s.thread != Thread.currentThread());    &#125;</code></pre><p>在这个方法中，进行了判断，对于<code>head</code>的后置节点是否是当前的节点，如果不是当前的节点，则代表在当前的node节点之前，有更加重要的节点要获取锁，如果是当前节点，则代表当前节点就是要获取锁的节点。这样的好处是所有的节点都是按照<code>FIFO</code>的方式来获取锁。保证了获取锁的公平性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ReentrantLock</code>在实际的开发过程中是十分的重要的。对于<code>ReentrantLock</code>的源码的研究是十分的有必要的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> 锁问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java--synchronize关键字</title>
      <link href="//JavaLock/JavaLockDay02/"/>
      <url>//JavaLock/JavaLockDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="Java–synchronize关键字"><a href="#Java–synchronize关键字" class="headerlink" title="Java–synchronize关键字"></a>Java–synchronize关键字</h1><p><code>synchronize</code>是<code>JDK</code>中的一个关键字。是用来实现线程安全的。接下来，我们好好的研究下<code>synchronize</code>的魅力。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>修饰实例方法<span style="color:red;"> — </span>这个锁是作用在当前实例对象上的。当我们要进入到同步代码之前，我们需要当前实例对象获得锁。在执行完代码后，要释放锁。</li><li>修饰静态方法<span style="color:red;"> — </span>这个锁是作用在类对象上的。当我们要执行同步代码的时候，要获取到类对象的锁</li><li>修饰代码块<span style="color:red;"> — </span>指定了锁的对象，默认情况下，我们会使用<code>this</code>作为加锁条件。当我们使用<code>this</code>的时候，就相当于是第一种情况的当前实例对象。</li></ol><p>注意，这三种情况的获取锁、释放锁都是<code>JDK</code>自己完成的。不需要我们手动的完成。</p><h2 id="synchronize关键字原理"><a href="#synchronize关键字原理" class="headerlink" title="synchronize关键字原理"></a>synchronize关键字原理</h2><p>既然我们说了这么多，那么在<code>JDK</code>的底层中，对于<code>synchronize</code>关键字是怎么处理的呢？在这里，我们在解释这个问题，要先引申出另一个问题<span style="color:red;"> — </span>什么是<code>Monitor</code>？</p><h3 id="Monitor解释"><a href="#Monitor解释" class="headerlink" title="Monitor解释"></a>Monitor解释</h3><p>对于<code>Monitor</code>,我们可以把它理解成一个同步工具，也可以理解为一种同步机制，但是更多的，我们将它描述为一个对象。对于<code>Monitor</code>，它是线程私有的数据结构，而这个<code>Monitor</code>在什么地方呢？其实，<code>Monitor</code>在Java的<code>对象头</code>中。</p><p>那么<code>Monitor</code>到底是什么呢？其实<code>Monitor</code>只是一种数组结构，在<code>Monitor</code>中，包含了以下的信息：</p><ol><li>_owner：指向持有ObjectMonitor对象的线程</li><li>_WaitSet：存放处于wait状态的线程队列</li><li>_EntryList：存放处于等待锁block状态的线程队列</li><li>_recursions：锁的重入次数</li><li>_count：用来记录该线程获取锁的次数</li></ol><p>当多个线程同时访问一段同步代码时，首先会进入<code>_EntryList</code>队列中，当某个线程获取到对象的<code>monitor</code>后进入<code>_Owner</code>区域并把<code>monitor</code>中的<code>_owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>_count</code>加1。即获得对象锁。</p><p>若持有<code>monitor</code>的线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>_owner</code>变量恢复为<code>null</code>，<code>_count</code>自减1，同时该线程进入<code>_WaitSet</code>集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>(锁)并复位变量的值，以便其他线程进入获取<code>monitor</code>(锁)。</p><p>而对于<code>synchronize</code>而言，我们获取锁的过程，其实就是对象的一个从<code>Monitor</code>的<code>进入</code>到<code>走出</code>的过程。当对象获得锁的时候，此时使用的是<code>monitorenter</code>指令，而对象释放锁的时候，此时使用的是<code>monitorexit</code>指令。对于<code>JDK1.5</code>以及之前的<code>synchronize</code>,采用的就是这样的方式，但是这样的方式需要与操作系统进行打交道，因此，我们经常称呼为<code>重量级</code>锁。而线程之所以能够知道当前线程需不需要锁，也是通过方法上修饰的<code>ACC_SYNCHRONIZED</code>来进行判断的。</p><h3 id="Java的对象头"><a href="#Java的对象头" class="headerlink" title="Java的对象头"></a>Java的对象头</h3><p>那么什么是<code>Java</code>的对象头呢？其实，在JVM中，我们的每个对象，都是由<code>对象头</code>和<code>实例数据</code>两部分组成的。对象头保存了一个对象的元数据信息，而其他的数据，则是存在了<code>实例对象</code>中，那么对象头，都是由什么组成的呢？其实，对象头是由<code>markword</code>、<code>类型指针</code>和<code>数组长度</code>(<span style="color:red;">可选，只有对象为数组的时候，才存在这个值</span>)组成的。</p><h4 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h4><p><img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay02/markword.jpg" alt="markword示意图"></p><p>接下来，我们解释一下各个字段的含义</p><h5 id="biased-lock"><a href="#biased-lock" class="headerlink" title="biased_lock"></a>biased_lock</h5><p>在<code>JDK1.6</code>的版本之后，<code>JDK</code>的库工程师们对于<code>synchronize</code>关键字进行了优化，从之前的<code>重量级锁</code>，改成了可以是<code>无锁</code>、<code>偏向锁</code>、<code>轻量级锁</code>和之前就有的<code>重量级锁</code>。而这个字段表示的就是当前的锁状态是否是偏向锁，如果是<code>1</code>的话，则表示的是当前对象启用了<code>偏向锁</code>，而<code>0</code>表示的是当前对象并未启用<code>偏向锁</code>。在<code>markword</code>中，这个字段仅仅占用<code>1</code>位。</p><h5 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h5><p>这个字段表示的是锁的一个状态，由<code>2</code>位组成。我们可以将这个状态以一个表格的形式展示出来</p><table><thead><tr><th align="center">biased_lock</th><th align="center">lock</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">01</td><td align="center">无锁</td></tr><tr><td align="center">1</td><td align="center">01</td><td align="center">偏向锁</td></tr><tr><td align="center">0</td><td align="center">00</td><td align="center">轻量级锁</td></tr><tr><td align="center">0</td><td align="center">10</td><td align="center">重量级锁</td></tr><tr><td align="center">0</td><td align="center">11</td><td align="center">GC标记</td></tr></tbody></table><h5 id="age"><a href="#age" class="headerlink" title="age"></a>age</h5><p>这个字段表示的是<code>Java</code>对象的一个年龄。由<code>4</code>位组成。在<code>GC</code>中，如果对象在<code>Survivor</code>中存活一次，则直接age加<code>1</code>，当超过了设置的年龄阈值的时候，此时对象会晋升到老年代。默认情况下，并行<code>GC</code>的年龄阈值为<code>15</code>，并发<code>GC</code>的年龄阈值为<code>6</code>。由于<code>age</code>只有<code>4</code>位，所以最大值为<code>15</code>，这就是<code>-XX:MaxTenuringThreshold</code>选项最大值为<code>15</code>的原因。</p><h5 id="identity-hashcode："><a href="#identity-hashcode：" class="headerlink" title="identity_hashcode："></a>identity_hashcode：</h5><p><code>25</code>位的对象标识<code>Hash</code>码，采用延迟加载技术。调用方法<code>System.identityHashCode()</code>计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程<code>Monitor</code>中。</p><h5 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h5><p>持有偏向锁的线程ID</p><h5 id="epoch"><a href="#epoch" class="headerlink" title="epoch"></a>epoch</h5><p>偏向时间戳</p><h5 id="ptr-to-lock-record"><a href="#ptr-to-lock-record" class="headerlink" title="ptr_to_lock_record"></a>ptr_to_lock_record</h5><p>指向栈中锁记录的指针</p><h5 id="ptr-to-heavyweight-monitor"><a href="#ptr-to-heavyweight-monitor" class="headerlink" title="ptr_to_heavyweight_monitor"></a>ptr_to_heavyweight_monitor</h5><p>指向管程Monitor的指针</p><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为<code>JVM</code>的一个字大小，即<code>32</code>位的<code>JVM</code>为<code>32</code>位，<code>64</code>位的<code>JVM</code>为<code>64</code>位。</p><p>如果应用的对象过多，使用<code>64</code>位的指针将浪费大量内存。为了节约内存可以使用选项<code>+UseCompressedOops</code>开启指针压缩，其中，<code>oop</code>即<code>ordinary object pointer</code>普通对象指针。开启该选项后，下列指针将压缩至<code>32</code>位：</p><ol><li>每个Class的属性指针（即静态变量）</li><li>每个对象的属性指针（即对象变量）</li><li>普通对象数组的每个元素指针</li></ol><p>当然，也不是所有的指针都会压缩，一些特殊类型的指针<code>JVM</code>不会优化，比如指向<code>PermGen</code>的<code>Class</code>对象指针(<code>JDK8</code>中指向元空间的<code>Class</code>对象指针)、<code>本地变量</code>、<code>堆栈元素</code>、<code>入参</code>、<code>返回值</code>和<code>NULL指针</code>等。</p><h4 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h4><p>如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，这部分数据的长度也随着<code>JVM</code>架构的不同而不同：<code>32</code>位的<code>JVM</code>上，长度为<code>32</code>位；<code>64</code>位<code>JVM</code>则为<code>64</code>位。<code>64</code>位<code>JVM</code>如果开启<code>+UseCompressedOops</code>选项，该区域长度也将由<code>64</code>位压缩至<code>32</code>位。</p><h3 id="synchronize优化"><a href="#synchronize优化" class="headerlink" title="synchronize优化"></a>synchronize优化</h3><p><code>jdk1.6</code>以后对<code>synchronized</code>的锁进行了优化，引入了<code>偏向锁</code>、<code>轻量级锁</code>，锁的级别从低到高逐步升级：<code>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</code>。</p><h4 id="synchronize锁升级过程"><a href="#synchronize锁升级过程" class="headerlink" title="synchronize锁升级过程"></a>synchronize锁升级过程</h4><p>下面，我们可以借用网上的一张图片来进行说明</p><p><img src="https://shengouqiang.cn/img/JavaLock/JavaLockDay02/lockUpdate.png" alt="synchronize锁升级"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于同步方法，<code>synchronize</code>可谓是元老级的任务。对于<code>synchronize</code>的研究，在日后的学习中，还是很有必要的。对我们的帮助也是很大的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> 锁问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常见的锁问题汇总(持续更新中)</title>
      <link href="//JavaLock/JavaLockDay01/"/>
      <url>//JavaLock/JavaLockDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="Java常见的锁问题汇总"><a href="#Java常见的锁问题汇总" class="headerlink" title="Java常见的锁问题汇总"></a>Java常见的锁问题汇总</h1><p>说到锁，这个话题就比较长了。在最开始程序是单线程执行的时候，此时根本用不到锁。因为锁的目的是为了防止程序的并发执行。后来，在Java中出现了多线程、线程池的概念，为了保证<code>临界资源</code>的正常访问，我们推出了锁的概念，用的最多的就是<code>synchronize</code>和<code>Lock</code>。但是随着互联网的兴起，和请求业务量的增加，此时往往一台<code>Server</code>已经很难满足我们的业务需求，因此出现了<code>分布式</code>的概念，而上面说的两种锁，仅仅在单<code>Server</code>上生效，无法保证在分布式的系统中的数据一致性，因此，我们又提出了<code>分布式锁</code>。</p><p>接下来，我们讲解下，每种锁的应用和不同。</p><h2 id="Java中一共有哪些锁"><a href="#Java中一共有哪些锁" class="headerlink" title="Java中一共有哪些锁"></a>Java中一共有哪些锁</h2><ol><li>公平锁/非公平锁</li><li>可重入锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ol><p>注意，这里面提到的这么多锁的名字，并不代表在JDK中都是一一对应存在的。这些都是按照锁的特性，来进行划分的。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>在讲解这些锁之前，我们先说一下<a href="/JavaLock/JavaLockDay02/">synchronize</a>和<a href="/JavaLock/JavaLockDay03/">ReentrantLock</a>。</p><h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h3><p>对于JDK自身提供的锁内容，<code>synchronize</code>关键字只能是非公平锁。而<code>ReentrantLock</code>既可以是公平锁、也可以是非公平锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 锁问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
            <tag> 锁问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiIgnore注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay08/"/>
      <url>//Swagger/SwaggerDocumentLearnDay08/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiIgnore注解"><a href="#Swagger文档API学习–ApiIgnore注解" class="headerlink" title="Swagger文档API学习–ApiIgnore注解"></a>Swagger文档API学习–ApiIgnore注解</h1><p>这个注解主要是用来在<code>Swagger</code>生成文档的时候，自动忽略掉、隐藏掉打上该注解的内容。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">package springfox.documentation.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;)public @interface ApiIgnore &#123;  /**   * A brief description of why this parameter/operation is ignored   * @return  the description of why it is ignored   */  String value() default &quot;&quot;;&#125;</code></pre><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>简明的说明为什么要忽略掉这个参数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个注解和其他注解中的<code>hidden</code>属性有很多类似的地方。在实际的使用中，我们可以根据自己的习惯，进行选择性的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiParam注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay07/"/>
      <url>//Swagger/SwaggerDocumentLearnDay07/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiParam注解"><a href="#Swagger文档API学习–ApiParam注解" class="headerlink" title="Swagger文档API学习–ApiParam注解"></a>Swagger文档API学习–ApiParam注解</h1><p>这个注解也是用来描述一些请求的请求参数的。和<code>@ApiImplicitParams</code>比较类似。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Adds additional meta-data for operation parameters. * &lt;p&gt; * This annotation can be used only in combination of JAX-RS 1.x/2.x annotations. */@Target(&#123;ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ApiParam &#123;    /**     * The parameter name.     * &lt;p&gt;     * The name of the parameter will be derived from the field/method/parameter name,     * however you can override it.     * &lt;p&gt;     * Path parameters must always be named as the path section they represent.     */    String name() default &quot;&quot;;    /**     * A brief description of the parameter.     */    String value() default &quot;&quot;;    /**     * Describes the default value for the parameter.     * &lt;p&gt;     * If the parameter is annotated with JAX-RS&#39;s &#123;@code @DefaultValue&#125;, that value would     * be used, but can be overridden by setting this property.     */    String defaultValue() default &quot;&quot;;    /**     * Limits the acceptable values for this parameter.     * &lt;p&gt;     * There are three ways to describe the allowable values:     * &lt;ol&gt;     * &lt;li&gt;To set a list of values, provide a comma-separated list.     * For example: &#123;@code first, second, third&#125;.&lt;/li&gt;     * &lt;li&gt;To set a range of values, start the value with &quot;range&quot;, and surrounding by square     * brackets include the minimum and maximum values, or round brackets for exclusive minimum and maximum values.     * For example: &#123;@code range[1, 5]&#125;, &#123;@code range(1, 5)&#125;, &#123;@code range[1, 5)&#125;.&lt;/li&gt;     * &lt;li&gt;To set a minimum/maximum value, use the same format for range but use &quot;infinity&quot;     * or &quot;-infinity&quot; as the second value. For example, &#123;@code range[1, infinity]&#125; means the     * minimum allowable value of this parameter is 1.&lt;/li&gt;     * &lt;/ol&gt;     */    String allowableValues() default &quot;&quot;;    /**     * Specifies if the parameter is required or not.     * &lt;p&gt;     * Path parameters will always be set as required, whether you set this property or not.     */    boolean required() default false;    /**     * Allows for filtering a parameter from the API documentation.     * &lt;p&gt;     * See io.swagger.core.filter.SwaggerSpecFilter for further details.     */    String access() default &quot;&quot;;    /**     * Specifies whether the parameter can accept multiple values by having multiple occurrences.     */    boolean allowMultiple() default false;    /**     * Hides the parameter from the list of parameters.     */    boolean hidden() default false;    /**     * a single example for non-body type parameters     *     * @since 1.5.4     *     * @return     */    String example() default &quot;&quot;;    /**     * Examples for the parameter.  Applies only to BodyParameters     *     * @since 1.5.4     *     * @return     */    Example examples() default @Example(value = @ExampleProperty(mediaType = &quot;&quot;, value = &quot;&quot;));    /**     * Adds the ability to override the detected type     *     * @since 1.5.11     *     * @return     */    String type() default &quot;&quot;;    /**     * Adds the ability to provide a custom format     *     * @since 1.5.11     *     * @return     */    String format() default &quot;&quot;;    /**     * Adds the ability to set a format as empty     *     * @since 1.5.11     *     * @return     */    boolean allowEmptyValue() default false;    /**     * adds ability to be designated as read only.     *     * @since 1.5.11     *     */    boolean readOnly() default false;    /**     * adds ability to override collectionFormat with `array` types     *     * @since 1.5.11     *     */    String collectionFormat() default &quot;&quot;;&#125;</code></pre><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>参数的命名。</p><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>参数的简明描述。</p><h3 id="defaultValue属性"><a href="#defaultValue属性" class="headerlink" title="defaultValue属性"></a>defaultValue属性</h3><p>参数默认值</p><h3 id="allowableValues属性"><a href="#allowableValues属性" class="headerlink" title="allowableValues属性"></a>allowableValues属性</h3><p>标明字段的取值范围，设置的方式有三种<br>1.第一种是采用枚举的形式。<br>例如：<code>allowableValue=&quot;&#123;first, second, third&#125;&quot;</code><br>2.第二种是采用一个有限的范围，例如<code>&quot;range[1, 5]&quot;</code>、<code>&quot;range(1, 5)&quot;</code>、<code>&quot;range[1, 5)&quot;</code>。其中，<br>2.1 <code>[</code>表示是大于等于<br>2.2 <code>(</code>表示是大于<br>2.3 <code>]</code>表示是小于等于<br>2.4 <code>)</code>表示是小于<br>3.标识的是一个无限的范围。其中，我们使用<code>infinity</code>表示无限大，使用<code>-infinity</code>表示负无限大。<br>例如:<code>&quot;range[1, infinity]&quot;</code>。</p><h3 id="required属性"><a href="#required属性" class="headerlink" title="required属性"></a>required属性</h3><p>确定是否是必传字段，默认<code>是false</code>。</p><h3 id="access属性"><a href="#access属性" class="headerlink" title="access属性"></a>access属性</h3><p>这个属性的意思是允许从API文档中过滤属性，详情，我们可以参见<code>io.swagger.core.filter.SwaggerSpecFilter</code>。在接下来的代码中我们会讲到。</p><h3 id="allowMultiple属性"><a href="#allowMultiple属性" class="headerlink" title="allowMultiple属性"></a>allowMultiple属性</h3><p>表示的是允许多个，一般用在<code>Array</code>、<code>List</code>上面。</p><h3 id="hidden属性"><a href="#hidden属性" class="headerlink" title="hidden属性"></a>hidden属性</h3><p>从参数列表中隐藏该属性，默认<code>是false</code>。</p><h3 id="example属性"><a href="#example属性" class="headerlink" title="example属性"></a>example属性</h3><p>对于非<code>body</code>类型的参数的一个举例说明。</p><h3 id="examples属性"><a href="#examples属性" class="headerlink" title="examples属性"></a>examples属性</h3><p>参数的举例说明，仅适用于<code>body</code>类型。</p><h3 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h3><p>参数的类型。这字段适用于<code>paramType</code>为非<code>body</code>的情况，可选的参数类型为：</p><ol><li>string</li><li>number</li><li>integer</li><li>boolean</li><li>array</li><li>file –如果是file的话，那么<code>consumes</code>字段必须是<code>multipart/form-data</code>, <code>application/x-www-form-urlencoded</code>中的一种或几种。</li></ol><h3 id="format属性"><a href="#format属性" class="headerlink" title="format属性"></a>format属性</h3><p>自定义参数的格式。</p><table><thead><tr><th align="center">实际参数名(Common Name)</th><th align="center">类型(type)</th><th align="center">参数格式(format)</th><th align="center">备注(Comments)</th></tr></thead><tbody><tr><td align="center">integer</td><td align="center">integer</td><td align="center">int32</td><td align="center">32位整数</td></tr><tr><td align="center">long</td><td align="center">integer</td><td align="center">int64</td><td align="center">64位整数</td></tr><tr><td align="center">float</td><td align="center">number</td><td align="center">float</td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">number</td><td align="center">double</td><td align="center"></td></tr><tr><td align="center">string</td><td align="center">string</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">byte</td><td align="center">string</td><td align="center">byte</td><td align="center">一个byte数组</td></tr><tr><td align="center">binary</td><td align="center">string</td><td align="center">binary</td><td align="center">二进制序列</td></tr><tr><td align="center">boolean</td><td align="center">boolean</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">date</td><td align="center">string</td><td align="center">date</td><td align="center">根据<code>RFC3339</code>定义的日期格式</td></tr><tr><td align="center">dateTime</td><td align="center">string</td><td align="center">date-time</td><td align="center">根据<code>RFC3339</code>定义的时间格式</td></tr><tr><td align="center">password</td><td align="center">string</td><td align="center">password</td><td align="center">用于提示是否需要掩码输入</td></tr></tbody></table><h3 id="allowEmptyValue属性"><a href="#allowEmptyValue属性" class="headerlink" title="allowEmptyValue属性"></a>allowEmptyValue属性</h3><p>允许参数为空，模式是<code>false</code>。</p><h3 id="readOnly属性"><a href="#readOnly属性" class="headerlink" title="readOnly属性"></a>readOnly属性</h3><p>设置参数是只读模式，不允许修改。</p><h3 id="collectionFormat属性"><a href="#collectionFormat属性" class="headerlink" title="collectionFormat属性"></a>collectionFormat属性</h3><p>在这里，如果我们的参数类型是一个数组的话，在这里，我们可以设定数组的格式，通常有：</p><ol><li>csv—利用逗号<code>,</code>分割值</li><li>ssv—利用空格分割值</li><li>tsv—利用制表符<code>\t</code>分割值</li><li>pipes—利用管道<code>|</code>分割值</li><li>multi—多元素分割值。<br>默认情况下，是<code>csv</code>格式的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@ApiImplicitParams</code>和<code>@ApiParam</code>注解的功能高度的类似，在实际的使用中，我们可以有选择的使用即可。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiImplicitParams注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay06/"/>
      <url>//Swagger/SwaggerDocumentLearnDay06/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiImplicitParams注解"><a href="#Swagger文档API学习–ApiImplicitParams注解" class="headerlink" title="Swagger文档API学习–ApiImplicitParams注解"></a>Swagger文档API学习–ApiImplicitParams注解</h1><p>这个注解主要是用来描述方法的请求参数的。例如我们在做<code>MVC</code>的开发过程中，当我们需要别人给我们传递参数的时候，我们就可以使用这样的注解，而在我们的代码当中，我们可以使用<code>Request request</code>进行接收。例如下面的代码：</p><pre><code class="java"> @ApiImplicitParams(&#123;    @ApiImplicitParam(name = &quot;name&quot;, value = &quot;User&#39;s name&quot;, required = true, dataType = &quot;string&quot;, paramType = &quot;query&quot;),    @ApiImplicitParam(name = &quot;email&quot;, value = &quot;User&#39;s email&quot;, required = false, dataType = &quot;string&quot;, paramType = &quot;query&quot;),    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;User ID&quot;, required = true, dataType = &quot;long&quot;, paramType = &quot;query&quot;)  &#125;) public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;...&#125;</code></pre><h2 id="源码-–-ApiImplicitParams"><a href="#源码-–-ApiImplicitParams" class="headerlink" title="源码 – ApiImplicitParams"></a>源码 – ApiImplicitParams</h2><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * A wrapper to allow a list of multiple &#123;@link ApiImplicitParam&#125; objects. * * @see ApiImplicitParam */@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ApiImplicitParams &#123;    /**     * A list of &#123;@link ApiImplicitParam&#125;s available to the API operation.     */    ApiImplicitParam[] value();&#125;</code></pre><p>通过源码我们知道,<code>@ApiImplicitParams</code>注解仅仅只是接收一个<code>@ApiImplicitParam</code>注解的数组而已，因此，真正的重点在于<code>@ApiImplicitParam</code>注解。</p><h2 id="源码-–-ApiImplicitParam"><a href="#源码-–-ApiImplicitParam" class="headerlink" title="源码 – ApiImplicitParam"></a>源码 – ApiImplicitParam</h2><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Represents a single parameter in an API Operation. * &lt;p&gt; * While &#123;@link ApiParam&#125; is bound to a JAX-RS parameter, * method or field, this allows you to manually define a parameter in a fine-tuned manner. * This is the only way to define parameters when using Servlets or other non-JAX-RS * environments. * &lt;p&gt; * This annotation must be used as a value of &#123;@link ApiImplicitParams&#125; * in order to be parsed. * * @see ApiImplicitParams */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ApiImplicitParam &#123;    /**     * Name of the parameter.     * &lt;p&gt;     * For proper Swagger functionality, follow these rules when naming your parameters based on &#123;@link #paramType()&#125;:     * &lt;ol&gt;     * &lt;li&gt;If &#123;@code paramType&#125; is &quot;path&quot;, the name should be the associated section in the path.&lt;/li&gt;     * &lt;li&gt;For all other cases, the name should be the parameter name as your application expects to accept.&lt;/li&gt;     * &lt;/ol&gt;     *     * @see #paramType()     */    String name() default &quot;&quot;;    /**     * A brief description of the parameter.     */    String value() default &quot;&quot;;    /**     * Describes the default value for the parameter.     */    String defaultValue() default &quot;&quot;;    /**     * Limits the acceptable values for this parameter.     * &lt;p&gt;     * There are three ways to describe the allowable values:     * &lt;ol&gt;     * &lt;li&gt;To set a list of values, provide a comma-separated list.     * For example: &#123;@code first, second, third&#125;.&lt;/li&gt;     * &lt;li&gt;To set a range of values, start the value with &quot;range&quot;, and surrounding by square     * brackets include the minimum and maximum values, or round brackets for exclusive minimum and maximum values.     * For example: &#123;@code range[1, 5]&#125;, &#123;@code range(1, 5)&#125;, &#123;@code range[1, 5)&#125;.&lt;/li&gt;     * &lt;li&gt;To set a minimum/maximum value, use the same format for range but use &quot;infinity&quot;     * or &quot;-infinity&quot; as the second value. For example, &#123;@code range[1, infinity]&#125; means the     * minimum allowable value of this parameter is 1.&lt;/li&gt;     * &lt;/ol&gt;     */    String allowableValues() default &quot;&quot;;    /**     * Specifies if the parameter is required or not.     * &lt;p&gt;     * Path parameters should always be set as required.     */    boolean required() default false;    /**     * Allows for filtering a parameter from the API documentation.     * &lt;p&gt;     * See io.swagger.core.filter.SwaggerSpecFilter for further details.     */    String access() default &quot;&quot;;    /**     * Specifies whether the parameter can accept multiple values by having multiple occurrences.     */    boolean allowMultiple() default false;    /**     * The data type of the parameter.     * &lt;p&gt;     * This can be the class name or a primitive.     */    String dataType() default &quot;&quot;;    /**     * The class of the parameter.     * &lt;p&gt;     * Overrides &#123;@code dataType&#125; if provided.     */    Class&lt;?&gt; dataTypeClass() default Void.class;    /**     * The parameter type of the parameter.     * &lt;p&gt;     * Valid values are &#123;@code path&#125;, &#123;@code query&#125;, &#123;@code body&#125;,     * &#123;@code header&#125; or &#123;@code form&#125;.     */    String paramType() default &quot;&quot;;    /**     * a single example for non-body type parameters     *     * @since 1.5.4     *     * @return     */    String example() default &quot;&quot;;    /**     * Examples for the parameter.  Applies only to BodyParameters     *     * @since 1.5.4     *     * @return     */    Example examples() default @Example(value = @ExampleProperty(mediaType = &quot;&quot;, value = &quot;&quot;));    /**     * Adds the ability to override the detected type     *     * @since 1.5.11     *     * @return     */    String type() default &quot;&quot;;    /**     * Adds the ability to provide a custom format     *     * @since 1.5.11     *     * @return     */    String format() default &quot;&quot;;    /**     * Adds the ability to set a format as empty     *     * @since 1.5.11     *     * @return     */    boolean allowEmptyValue() default false;    /**     * adds ability to be designated as read only.     *     * @since 1.5.11     *     */    boolean readOnly() default false;    /**     * adds ability to override collectionFormat with `array` types     *     * @since 1.5.11     *     */    String collectionFormat() default &quot;&quot;;&#125;</code></pre><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>请求参数的名字，如果在你的代码中，设置了<code>paramType</code>,则该属性代表的是请求路径中的某个关联值，如果没有设置<code>paramType</code>属性，则name代表的就是普通的参数的名字。</p><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>参数的简明描述。</p><h3 id="defaultValue属性"><a href="#defaultValue属性" class="headerlink" title="defaultValue属性"></a>defaultValue属性</h3><p>参数默认值</p><h3 id="allowableValues属性"><a href="#allowableValues属性" class="headerlink" title="allowableValues属性"></a>allowableValues属性</h3><p>标明字段的取值范围，设置的方式有三种<br>1.第一种是采用枚举的形式。<br>例如：<code>allowableValue=&quot;&#123;first, second, third&#125;&quot;</code><br>2.第二种是采用一个有限的范围，例如<code>&quot;range[1, 5]&quot;</code>、<code>&quot;range(1, 5)&quot;</code>、<code>&quot;range[1, 5)&quot;</code>。其中，<br>2.1 <code>[</code>表示是大于等于<br>2.2 <code>(</code>表示是大于<br>2.3 <code>]</code>表示是小于等于<br>2.4 <code>)</code>表示是小于<br>3.标识的是一个无限的范围。其中，我们使用<code>infinity</code>表示无限大，使用<code>-infinity</code>表示负无限大。<br>例如:<code>&quot;range[1, infinity]&quot;</code>。</p><h3 id="required属性"><a href="#required属性" class="headerlink" title="required属性"></a>required属性</h3><p>确定是否是必传字段，默认<code>是false</code>。</p><h3 id="access属性"><a href="#access属性" class="headerlink" title="access属性"></a>access属性</h3><p>这个属性的意思是允许从API文档中过滤属性，详情，我们可以参见<code>io.swagger.core.filter.SwaggerSpecFilter</code>。在接下来的代码中我们会讲到。</p><h3 id="allowMultiple属性"><a href="#allowMultiple属性" class="headerlink" title="allowMultiple属性"></a>allowMultiple属性</h3><p>表示的是允许多个，一般用在<code>Array</code>、<code>List</code>上面。</p><h3 id="dataType属性"><a href="#dataType属性" class="headerlink" title="dataType属性"></a>dataType属性</h3><p>参数的数据类型，如果我们设置了这个属性，将被覆盖掉通过内省获得的参数的数据类型。并且这个数据类型可以是基本数据类型，也可以是类的名字。如果是基本数据类型，为了防止抛出<code>XXX</code>的错误<br>1.我们可以采用配置<code>example</code>属性一起使用<br>2.我们可以通过升级<code>swagger-annotations</code>和<code>swagger-models</code>的版本来避免，升级到<code>XXX</code>版本即可。</p><h3 id="dataTypeClass属性"><a href="#dataTypeClass属性" class="headerlink" title="dataTypeClass属性"></a>dataTypeClass属性</h3><p>指定参数的class文件。如果我们在设置中提供了该参数，将自动的覆盖掉<code>dataType</code>参数。</p><h3 id="paramType属性"><a href="#paramType属性" class="headerlink" title="paramType属性"></a>paramType属性</h3><p>参数的参数类型，一般有：</p><ol><li>path</li><li>query</li><li>body</li><li>header</li><li>form</li></ol><h3 id="example属性"><a href="#example属性" class="headerlink" title="example属性"></a>example属性</h3><p>对于非<code>body</code>类型的参数的一个举例说明。</p><h3 id="examples属性"><a href="#examples属性" class="headerlink" title="examples属性"></a>examples属性</h3><p>参数的举例说明，仅适用于<code>body</code>类型。</p><h3 id="type属性"><a href="#type属性" class="headerlink" title="type属性"></a>type属性</h3><p>参数的类型。这字段适用于<code>paramType</code>为非<code>body</code>的情况，可选的参数类型为：</p><ol><li>string</li><li>number</li><li>integer</li><li>boolean</li><li>array</li><li>file –如果是file的话，那么<code>consumes</code>字段必须是<code>multipart/form-data</code>, <code>application/x-www-form-urlencoded</code>中的一种或几种。</li></ol><h3 id="format属性"><a href="#format属性" class="headerlink" title="format属性"></a>format属性</h3><p>自定义参数的格式。</p><table><thead><tr><th align="center">实际参数名(Common Name)</th><th align="center">类型(type)</th><th align="center">参数格式(format)</th><th align="center">备注(Comments)</th></tr></thead><tbody><tr><td align="center">integer</td><td align="center">integer</td><td align="center">int32</td><td align="center">32位整数</td></tr><tr><td align="center">long</td><td align="center">integer</td><td align="center">int64</td><td align="center">64位整数</td></tr><tr><td align="center">float</td><td align="center">number</td><td align="center">float</td><td align="center"></td></tr><tr><td align="center">double</td><td align="center">number</td><td align="center">double</td><td align="center"></td></tr><tr><td align="center">string</td><td align="center">string</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">byte</td><td align="center">string</td><td align="center">byte</td><td align="center">一个byte数组</td></tr><tr><td align="center">binary</td><td align="center">string</td><td align="center">binary</td><td align="center">二进制序列</td></tr><tr><td align="center">boolean</td><td align="center">boolean</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">date</td><td align="center">string</td><td align="center">date</td><td align="center">根据<code>RFC3339</code>定义的日期格式</td></tr><tr><td align="center">dateTime</td><td align="center">string</td><td align="center">date-time</td><td align="center">根据<code>RFC3339</code>定义的时间格式</td></tr><tr><td align="center">password</td><td align="center">string</td><td align="center">password</td><td align="center">用于提示是否需要掩码输入</td></tr></tbody></table><h3 id="allowEmptyValue属性"><a href="#allowEmptyValue属性" class="headerlink" title="allowEmptyValue属性"></a>allowEmptyValue属性</h3><p>允许参数为空，模式是<code>false</code>。</p><h3 id="readOnly属性"><a href="#readOnly属性" class="headerlink" title="readOnly属性"></a>readOnly属性</h3><p>设置参数是只读模式，不允许修改。</p><h3 id="collectionFormat属性"><a href="#collectionFormat属性" class="headerlink" title="collectionFormat属性"></a>collectionFormat属性</h3><p>在这里，如果我们的参数类型是一个数组的话，在这里，我们可以设定数组的格式，通常有：</p><ol><li>csv—利用逗号<code>,</code>分割值</li><li>ssv—利用空格分割值</li><li>tsv—利用制表符<code>\t</code>分割值</li><li>pipes—利用管道<code>|</code>分割值</li><li>multi—多元素分割值。<br>默认情况下，是<code>csv</code>格式的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@ApiImplicitParams</code>和<code>@ApiImplicitParam</code>注解主要是用来描述请求参数的一些基本信息的，在实际的工作中经常会用的到。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiModelProperty注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay05/"/>
      <url>//Swagger/SwaggerDocumentLearnDay05/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiModelProperty注解"><a href="#Swagger文档API学习–ApiModelProperty注解" class="headerlink" title="Swagger文档API学习–ApiModelProperty注解"></a>Swagger文档API学习–ApiModelProperty注解</h1><p>这个注解是配合<code>@ApiModel</code>注解一起使用的。同时这个注解与<code>@ApiModel</code>不同，<code>@ApiModel</code>是描述的是类的信息，而<code>@ApiModelProperty</code>属性描述的是类的属性的信息。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Adds and manipulates data of a model property. */@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ApiModelProperty &#123;    /**     * A brief description of this property.     */    String value() default &quot;&quot;;    /**     * Allows overriding the name of the property.     *     * @return the overridden property name     */    String name() default &quot;&quot;;    /**     * Limits the acceptable values for this parameter.     * &lt;p&gt;     * There are three ways to describe the allowable values:     * &lt;ol&gt;     * &lt;li&gt;To set a list of values, provide a comma-separated list.     * For example: &#123;@code first, second, third&#125;.&lt;/li&gt;     * &lt;li&gt;To set a range of values, start the value with &quot;range&quot;, and surrounding by square     * brackets include the minimum and maximum values, or round brackets for exclusive minimum and maximum values.     * For example: &#123;@code range[1, 5]&#125;, &#123;@code range(1, 5)&#125;, &#123;@code range[1, 5)&#125;.&lt;/li&gt;     * &lt;li&gt;To set a minimum/maximum value, use the same format for range but use &quot;infinity&quot;     * or &quot;-infinity&quot; as the second value. For example, &#123;@code range[1, infinity]&#125; means the     * minimum allowable value of this parameter is 1.&lt;/li&gt;     * &lt;/ol&gt;     */    String allowableValues() default &quot;&quot;;    /**     * Allows for filtering a property from the API documentation. See io.swagger.core.filter.SwaggerSpecFilter.     */    String access() default &quot;&quot;;    /**     * Currently not in use.     */    String notes() default &quot;&quot;;    /**     * The data type of the parameter.     * &lt;p&gt;     * This can be the class name or a primitive. The value will override the data type as read from the class     * property.     */    String dataType() default &quot;&quot;;    /**     * Specifies if the parameter is required or not.     */    boolean required() default false;    /**     * Allows explicitly ordering the property in the model.     */    int position() default 0;    /**     * Allows a model property to be hidden in the Swagger model definition.     */    boolean hidden() default false;    /**     * A sample value for the property.     */    String example() default &quot;&quot;;    /**     * Allows a model property to be designated as read only.     *     * @deprecated As of 1.5.19, replaced by &#123;@link #accessMode()&#125;     *     */    @Deprecated    boolean readOnly() default false;    /**     * Allows to specify the access mode of a model property (AccessMode.READ_ONLY, READ_WRITE)     *     * @since 1.5.19     */    AccessMode accessMode() default AccessMode.AUTO;    /**     * Specifies a reference to the corresponding type definition, overrides any other metadata specified     */    String reference() default &quot;&quot;;    /**     * Allows passing an empty value     *     * @since 1.5.11     */    boolean allowEmptyValue() default false;    /**     * @return an optional array of extensions     */    Extension[] extensions() default @Extension(properties = @ExtensionProperty(name = &quot;&quot;, value = &quot;&quot;));    enum AccessMode &#123;        AUTO,        READ_ONLY,        READ_WRITE;    &#125;&#125;</code></pre><h2 id="ApiModelProperty注解"><a href="#ApiModelProperty注解" class="headerlink" title="@ApiModelProperty注解"></a>@ApiModelProperty注解</h2><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>简洁的介绍字段描述。</p><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>如果设置这个字段，会覆盖原本属性的名字。</p><h3 id="allowableValues属性"><a href="#allowableValues属性" class="headerlink" title="allowableValues属性"></a>allowableValues属性</h3><p>标明字段的取值范围，设置的方式有三种<br>1.第一种是采用枚举的形式。<br>例如：<code>allowableValues=&quot;first, second, third&quot;</code><br>2.第二种是采用一个有限的范围，例如<code>&quot;range[1, 5]&quot;</code>、<code>&quot;range(1, 5)&quot;</code>、<code>&quot;range[1, 5)&quot;</code>。其中，<br>2.1 <code>[</code>表示是大于等于<br>2.2 <code>(</code>表示是大于<br>2.3 <code>]</code>表示是小于等于<br>2.4 <code>)</code>表示是小于<br>3.标识的是一个无限的范围。其中，我们使用<code>infinity</code>表示无限大，使用<code>-infinity</code>表示负无限大。<br>例如:<code>&quot;range[1, infinity]&quot;</code>。</p><h3 id="access属性"><a href="#access属性" class="headerlink" title="access属性"></a>access属性</h3><p>这个属性的意思是允许从API文档中过滤属性，详情，我们可以参见<code>io.swagger.core.filter.SwaggerSpecFilter</code>。在接下来的代码中我们会讲到。</p><h3 id="notes属性"><a href="#notes属性" class="headerlink" title="notes属性"></a>notes属性</h3><p>该字段是预留字段，目前并未被使用。</p><h3 id="dataType属性"><a href="#dataType属性" class="headerlink" title="dataType属性"></a>dataType属性</h3><p>参数的数据类型，如果我们设置了这个属性，将被覆盖掉通过内省获得的参数的数据类型。并且这个数据类型可以是基本数据类型，也可以是类的名字。如果是基本数据类型，为了防止抛出<code>java.lang.NumberFormatException: For input string: &quot;&quot;</code>的错误<br>1.我们可以采用配置<code>example</code>属性一起使用<br>2.我们可以通过升级<code>swagger-annotations</code>和<code>swagger-models</code>的版本来避免，升级到<code>1.5.21</code>版本即可。</p><h3 id="required属性"><a href="#required属性" class="headerlink" title="required属性"></a>required属性</h3><p>表示的是当前字段是否是必须的，默认是<code>false</code>。</p><h3 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h3><p>已过时的方法，代表是属性在文档中的位置排序。</p><h3 id="hidden属性"><a href="#hidden属性" class="headerlink" title="hidden属性"></a>hidden属性</h3><p>表示的是是否隐藏当前字段，默认是<code>false</code>。</p><h3 id="example属性"><a href="#example属性" class="headerlink" title="example属性"></a>example属性</h3><p>举例说明。</p><h3 id="readOnly属性"><a href="#readOnly属性" class="headerlink" title="readOnly属性"></a>readOnly属性</h3><p>过时方法，在<code>Swagger1.5.19</code>版本之后，采用<code>accessMode</code>注解代替。</p><h3 id="accessMode属性"><a href="#accessMode属性" class="headerlink" title="accessMode属性"></a>accessMode属性</h3><p>属性的数据模式。使用的是一个枚举<code>AccessMode</code>的值，其中包括<code>AUTO</code>、<code>READ_ONLY</code>、<code>READ_WRITE</code>。</p><h3 id="reference属性"><a href="#reference属性" class="headerlink" title="reference属性"></a>reference属性</h3><p>指定了属性的类型引用，如果设置了当前属性，会覆盖任何其他的元数据(<code>不常使用</code>)。</p><h3 id="allowEmptyValue属性"><a href="#allowEmptyValue属性" class="headerlink" title="allowEmptyValue属性"></a>allowEmptyValue属性</h3><p>是否允许该字段为空，默认是<code>false</code>。</p><h3 id="extensions属性"><a href="#extensions属性" class="headerlink" title="extensions属性"></a>extensions属性</h3><p>该属性用于进行额外的描述。是一个可选项的数组组成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@ApiModelProperty</code>注解主要是对于类的内部的一个属性的描述。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiModel注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay04/"/>
      <url>//Swagger/SwaggerDocumentLearnDay04/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiModel注解"><a href="#Swagger文档API学习–ApiModel注解" class="headerlink" title="Swagger文档API学习–ApiModel注解"></a>Swagger文档API学习–ApiModel注解</h1><p><code>@ApiModel</code>这个注解是比较重要的一个注解。因为在实际的开发过程中，我们知道了请求的地址后，我们更加重要的是关心这个接口的请求入参和返回值。而对于<code>@ApiModel</code>这个注解,可以良好的展示出请求参数的含义和返回参数的含义。</p><h2 id="源码展示"><a href="#源码展示" class="headerlink" title="源码展示"></a>源码展示</h2><pre><code class="java">import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Provides additional information about Swagger models. * &lt;p&gt; * Classes will be introspected automatically as they are used as types in operations, * but you may want to manipulate the structure of the models. */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface ApiModel &#123;    /**     * Provide an alternative name for the model.     * &lt;p&gt;     * By default, the class name is used.     */    String value() default &quot;&quot;;    /**     * Provide a longer description of the class.     */    String description() default &quot;&quot;;    /**     * Provide a superclass for the model to allow describing inheritance.     */    Class&lt;?&gt; parent() default Void.class;    /**     * Supports model inheritance and polymorphism.     * &lt;p&gt;     * This is the name of the field used as a discriminator. Based on this field,     * it would be possible to assert which sub type needs to be used.     */    String discriminator() default &quot;&quot;;    /**     * An array of the sub types inheriting from this model.     */    Class&lt;?&gt;[] subTypes() default &#123;&#125;;    /**     * Specifies a reference to the corresponding type definition, overrides any other metadata specified     */    String reference() default &quot;&quot;;&#125;</code></pre><h2 id="ApiModel这个注解"><a href="#ApiModel这个注解" class="headerlink" title="@ApiModel这个注解"></a><code>@ApiModel</code>这个注解</h2><p>这个注解的是作用在类上面的，是用来描述类的一些基本信息的。下面，我们会逐个的进行讲解。</p><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>这个属性，提供的是类的一个备用名。如果我们不设置的的话，那么默认情况下，将使用的是<code>class</code>类的名字。</p><h3 id="description属性"><a href="#description属性" class="headerlink" title="description属性"></a>description属性</h3><p>对于类，提供一个详细的描述信息</p><h3 id="parent属性"><a href="#parent属性" class="headerlink" title="parent属性"></a>parent属性</h3><p>这个属性，描述的是类的一些父类的信息。</p><h3 id="discriminator属性"><a href="#discriminator属性" class="headerlink" title="discriminator属性"></a>discriminator属性</h3><p>这个属性解释起来有些麻烦，因为这个类主要是体现出了断言当中。</p><h3 id="subTypes属性"><a href="#subTypes属性" class="headerlink" title="subTypes属性"></a>subTypes属性</h3><p>举个实例，如果我们此时有一个父类<code>Animal</code>。同时，对于这个父类，我们的系统中有这个类的子类<code>Cat</code>、<code>Dog</code>、<code>Pig</code>等。如果我们在我们的父类上，通过这个属性，指定了我们想要使用的子类的话，那么在生成<code>Swagger</code>的文档的话，会自动的展示的是<code>Animal</code>这个属性，但是在属性的字段中，会显示出子类的一些独有的属性，其实在这里，是不推荐使用的。因为这样会让别人认为，这些子类独有的属性，也是父类才有的。</p><p>假如我们有如下的几个类：</p><p>Pet类</p><pre><code class="java">@ApiModel(value = &quot;Pet&quot;, subTypes = &#123;Cat.class&#125;,discriminator = &quot;type&quot;)public class Pet &#123;    private long id;    private Category category;    private String name;    private List&lt;String&gt; photoUrls = new ArrayList&lt;String&gt;();    private List&lt;Tag&gt; tags = new ArrayList&lt;Tag&gt;();    @ApiModelProperty(value = &quot;pet status in the store&quot;, allowableValues = &quot;available,pending,sold&quot;)    private String status;    public long getId() &#123;        return id;    &#125;    public void setId(long id) &#123;        this.id = id;    &#125;    public Category getCategory() &#123;        return category;    &#125;    public void setCategory(Category category) &#123;        this.category = category;    &#125;    @ApiModelProperty(example = &quot;doggie&quot;, required = true)    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public List&lt;String&gt; getPhotoUrls() &#123;        return photoUrls;    &#125;    public void setPhotoUrls(List&lt;String&gt; photoUrls) &#123;        this.photoUrls = photoUrls;    &#125;    public List&lt;Tag&gt; getTags() &#123;        return tags;    &#125;    public void setTags(List&lt;Tag&gt; tags) &#123;        this.tags = tags;    &#125;    public String getStatus() &#123;        return status;    &#125;    public void setStatus(String status) &#123;        this.status = status;    &#125;    private String type;    @ApiModelProperty(required = true)    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;&#125;</code></pre><p>Cat类</p><pre><code class="java">import  javax.xml.bind.annotation.XmlRootElement;public class Cat extends Pet &#123;    String catBreed;    public String getCatBreed() &#123;        return catBreed;    &#125;    public void setCatBreed(String catBreed) &#123;        this.catBreed = catBreed;    &#125;&#125;</code></pre><p>接口类</p><pre><code class="java">public interface OrderWebApi &#123;    @RequestMapping(value = &quot;/shen/testOne&quot;,method = RequestMethod.GET)    Result&lt;Cat&gt; getOrderDetail(@RequestParam(&quot;order_id&quot;) Integer orderId);&#125;</code></pre><p>真正的<code>Controller</code>类</p><pre><code class="java">@RestControllerpublic class OrderWebController  implements OrderWebApi &#123;    @Override    public Result&lt;Cat&gt; getOrderDetail(Integer orderId) &#123;        System.out.println(orderId);        OrderWebResVo orderWebResVo = new OrderWebResVo();        orderWebResVo.setAb(SexEnum.MAN);        orderWebResVo.setAge(20);        orderWebResVo.setMoney(4000L);        orderWebResVo.setMoneyOne(3000.0F);        orderWebResVo.setName(&quot;shen&quot;);        orderWebResVo.setSex(new Byte(&quot;1&quot;));        Result&lt;Cat&gt; result = new Result&lt;&gt;();        result.setCode(20080);        result.setMessage(&quot;SUCCESS&quot;);        result.setData(new Cat());        return result;    &#125;&#125;</code></pre><p>但是真正的<code>Swagger</code>文档为</p><p><img src="https://shengouqiang.cn/img/swagger/DocumentDay04/subTypes.png" alt="subTypes属性"></p><h3 id="reference属性"><a href="#reference属性" class="headerlink" title="reference属性"></a>reference属性</h3><p>指定对相应类型定义的引用，覆盖指定的任何其他元数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个注解主要讲解的是<code>model</code>的信息信息，但是对于<code>POJO</code>中的内在属性需要参考下一篇文章讲解的<code>@ApiModelProperty</code>属性。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiResponses注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay03/"/>
      <url>//Swagger/SwaggerDocumentLearnDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiResponses注解"><a href="#Swagger文档API学习–ApiResponses注解" class="headerlink" title="Swagger文档API学习–ApiResponses注解"></a>Swagger文档API学习–ApiResponses注解</h1><p>今天我们讲解<code>Swagger</code>的第三个注解，也是一个比较重要的注解—<code>@ApiResponses</code>注解。根据以往的惯例，首先先上源码。</p><h2 id="ApiResponses源码"><a href="#ApiResponses源码" class="headerlink" title="ApiResponses源码"></a>ApiResponses源码</h2><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * A wrapper to allow a list of multiple &#123;@link ApiResponse&#125; objects. * &lt;p&gt; * If you need to describe a single &#123;@link ApiResponse&#125;, you still * must use this annotation and wrap the &#123;@code @ApiResponse&#125; in an array. * * @see ApiResponse */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ApiResponses &#123;    /**     * A list of &#123;@link ApiResponse&#125;s provided by the API operation.     */    ApiResponse[] value();&#125;</code></pre><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Describes a possible response of an operation. * &lt;p&gt; * This can be used to describe possible success and error codes from your REST API call. * You may or may not use this to describe the return type of the operation (normally a * successful code), but the successful response should be described as well using the * &#123;@link ApiOperation&#125;. * &lt;p&gt; * This annotation can be applied at method or class level; class level annotations will * be parsed only if an @ApiResponse annotation with the same code is not defined at method * level or in thrown Exception * &lt;p&gt; * If your API has uses a different response class for these responses, you can describe them * here by associating a response class with a response code. * Note, Swagger does not allow multiple response types for a single response code. * &lt;p&gt; * This annotation is not used directly and will not be parsed by Swagger. It should be used * within the &#123;@link ApiResponses&#125;. * * @see ApiOperation * @see ApiResponses */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface ApiResponse &#123;    /**     * The HTTP status code of the response.     * &lt;p&gt;     * The value should be one of the formal &lt;a target=&quot;_blank&quot; href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;HTTP Status Code Definitions&lt;/a&gt;.     */    int code();    /**     * Human-readable message to accompany the response.     */    String message();    /**     * Optional response class to describe the payload of the message.     * &lt;p&gt;     * Corresponds to the `schema` field of the response message object.     */    Class&lt;?&gt; response() default Void.class;    /**     * Specifies a reference to the response type. The specified reference can be either local or remote and     * will be used as-is, and will override any specified response() class.     */    String reference() default &quot;&quot;;    /**     * A list of possible headers provided alongside the response.     *     * @return a list of response headers.     */    ResponseHeader[] responseHeaders() default @ResponseHeader(name = &quot;&quot;, response = Void.class);    /**     * Declares a container wrapping the response.     * &lt;p&gt;     * Valid values are &quot;List&quot;, &quot;Set&quot; or &quot;Map&quot;. Any other value will be ignored.     */    String responseContainer() default &quot;&quot;;    /**     * Examples for the response.     *     * @since 1.5.20     *     * @return     */    Example examples() default @Example(value = @ExampleProperty(value = &quot;&quot;, mediaType = &quot;&quot;));&#125;</code></pre><h2 id="ApiResponses注解"><a href="#ApiResponses注解" class="headerlink" title="@ApiResponses注解"></a>@ApiResponses注解</h2><p>通过上面的源码，我们依然可以看出，这个注解可以使用在方法上和类的上面，但是一般的情况下， 我们都是用在方法上面。代表的是一个<code>Http</code>请求的返回值的描述。通过上面我们可以看出，<code>@ApiResponses</code>仅仅只是接收一个<code>@ApiResponse</code>的数组，因此，真正的重点其实是<code>@ApiResponse</code>注解。</p><h3 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h3><p><code>http</code>返回状态码</p><h3 id="message属性"><a href="#message属性" class="headerlink" title="message属性"></a>message属性</h3><p>响应码对应的描述</p><h3 id="response属性"><a href="#response属性" class="headerlink" title="response属性"></a>response属性</h3><p>描述的是返回的类型</p><h3 id="responseHeaders属性"><a href="#responseHeaders属性" class="headerlink" title="responseHeaders属性"></a>responseHeaders属性</h3><p>指定<code>response</code>中<code>header</code>的信息列表</p><h3 id="responseContainer属性"><a href="#responseContainer属性" class="headerlink" title="responseContainer属性"></a>responseContainer属性</h3><p>在这里，说明的是包装相应的容器。默认情况下，有效值为 <code>List</code>、<code>Set</code>、<code>Map</code>，任何其它值都将被忽略</p><h3 id="examples属性"><a href="#examples属性" class="headerlink" title="examples属性"></a>examples属性</h3><p><code>response</code>返回的举例说明</p><h2 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h2><p><code>@ApiResponses</code>主要描述的是接口的返回信息。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--ApiOperation注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay02/"/>
      <url>//Swagger/SwaggerDocumentLearnDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger文档API学习–ApiOperation注解"><a href="#Swagger文档API学习–ApiOperation注解" class="headerlink" title="Swagger文档API学习–ApiOperation注解"></a>Swagger文档API学习–ApiOperation注解</h1><p>今天我们讲解下<code>Swagger</code>文档的第二个注解<code>@ApiOperation</code>。首先我们先看一下源码。</p><pre><code class="java">/** * Copyright 2016 SmartBear Software * &lt;p&gt; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * &lt;p&gt; * http://www.apache.org/licenses/LICENSE-2.0 * &lt;p&gt; * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * Describes an operation or typically a HTTP method against a specific path. * &lt;p&gt; * Operations with equivalent paths are grouped in a single Operation Object. * A combination of a HTTP method and a path creates a unique operation. */@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface ApiOperation &#123;    /**     * Corresponds to the `summary` field of the operation.     * &lt;p&gt;     * Provides a brief description of this operation. Should be 120 characters or less     * for proper visibility in Swagger-UI.     */    String value();    /**     * Corresponds to the &#39;notes&#39; field of the operation.     * &lt;p&gt;     * A verbose description of the operation.     */    String notes() default &quot;&quot;;    /**     * A list of tags for API documentation control.     * &lt;p&gt;     * Tags can be used for logical grouping of operations by resources or any other qualifier.     * A non-empty value will override the value received from &#123;@link Api#value()&#125; or &#123;@link Api#tags()&#125;     * for this operation.     *     * @since 1.5.2-M1     */    String[] tags() default &quot;&quot;;    /**     * The response type of the operation.     * &lt;p&gt;     * In JAX-RS applications, the return type of the method would automatically be used, unless it is     * &#123;@code javax.ws.rs.core.Response&#125;. In that case, the operation return type would default to `void`     * as the actual response type cannot be known.     * &lt;p&gt;     * Setting this property would override any automatically-derived data type.     * &lt;p&gt;     * If the value used is a class representing a primitive (&#123;@code Integer&#125;, &#123;@code Long&#125;, ...)     * the corresponding primitive type will be used.     */    Class&lt;?&gt; response() default Void.class;    /**     * Declares a container wrapping the response.     * &lt;p&gt;     * Valid values are &quot;List&quot;, &quot;Set&quot; or &quot;Map&quot;. Any other value will be ignored.     */    String responseContainer() default &quot;&quot;;    /**     * Specifies a reference to the response type. The specified reference can be either local or remote and     * will be used as-is, and will override any specified response() class.     */    String responseReference() default &quot;&quot;;    /**     * Corresponds to the `method` field as the HTTP method used.     * &lt;p&gt;     * If not stated, in JAX-RS applications, the following JAX-RS annotations would be scanned     * and used: &#123;@code @GET&#125;, &#123;@code @HEAD&#125;, &#123;@code @POST&#125;, &#123;@code @PUT&#125;, &#123;@code @DELETE&#125; and &#123;@code @OPTIONS&#125;.     * Note that even though not part of the JAX-RS specification, if you create and use the &#123;@code @PATCH&#125; annotation,     * it will also be parsed and used. If the httpMethod property is set, it will override the JAX-RS annotation.     * &lt;p&gt;     * For Servlets, you must specify the HTTP method manually.     * &lt;p&gt;     * Acceptable values are &quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot; and &quot;PATCH&quot;.     */    String httpMethod() default &quot;&quot;;    /**     * Not used in 1.5.X, kept for legacy support.     */    @Deprecated int position() default 0;    /**     * Corresponds to the `operationId` field.     * &lt;p&gt;     * The operationId is used by third-party tools to uniquely identify this operation. In Swagger 2.0, this is     * no longer mandatory and if not provided will remain empty.     */    String nickname() default &quot;&quot;;    /**     * Corresponds to the `produces` field of the operation.     * &lt;p&gt;     * Takes in comma-separated values of content types.     * For example, &quot;application/json, application/xml&quot; would suggest this operation     * generates JSON and XML output.     * &lt;p&gt;     * For JAX-RS resources, this would automatically take the value of the &#123;@code @Produces&#125;     * annotation if such exists. It can also be used to override the &#123;@code @Produces&#125; values     * for the Swagger documentation.     */    String produces() default &quot;&quot;;    /**     * Corresponds to the `consumes` field of the operation.     * &lt;p&gt;     * Takes in comma-separated values of content types.     * For example, &quot;application/json, application/xml&quot; would suggest this API Resource     * accepts JSON and XML input.     * &lt;p&gt;     * For JAX-RS resources, this would automatically take the value of the &#123;@code @Consumes&#125;     * annotation if such exists. It can also be used to override the &#123;@code @Consumes&#125; values     * for the Swagger documentation.     */    String consumes() default &quot;&quot;;    /**     * Sets specific protocols (schemes) for this operation.     * &lt;p&gt;     * Comma-separated values of the available protocols. Possible values: http, https, ws, wss.     *     * @return the protocols supported by the operations under the resource.     */    String protocols() default &quot;&quot;;    /**     * Corresponds to the `security` field of the Operation Object.     * &lt;p&gt;     * Takes in a list of the authorizations (security requirements) for this operation.     *     * @return an array of authorizations required by the server, or a single, empty authorization value if not set.     * @see Authorization     */    Authorization[] authorizations() default @Authorization(value = &quot;&quot;);    /**     * Hides the operation from the list of operations.     */    boolean hidden() default false;    /**     * A list of possible headers provided alongside the response.     *     * @return a list of response headers.     */    ResponseHeader[] responseHeaders() default @ResponseHeader(name = &quot;&quot;, response = Void.class);    /**     * The HTTP status code of the response.     * &lt;p&gt;     * The value should be one of the formal &lt;a target=&quot;_blank&quot; href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html&quot;&gt;HTTP Status Code Definitions&lt;/a&gt;.     */    int code() default 200;    /**     * @return an optional array of extensions     */    Extension[] extensions() default @Extension(properties = @ExtensionProperty(name = &quot;&quot;, value = &quot;&quot;));    /**     * Ignores JsonView annotations while resolving operations and types. For backward compatibility     *     */    boolean ignoreJsonView() default false;&#125;</code></pre><p>接下来，我们一个一个的进行讲解。</p><h2 id="ApiOperation注解"><a href="#ApiOperation注解" class="headerlink" title="@ApiOperation注解"></a>@ApiOperation注解</h2><p>通过上面的代码，我们可以知道，这个注解可以使用在方法上和类的上面，但是一般的情况下， 我们都是用在方法上面。代表的是一个<code>Http</code>请求方法的描述。</p><h3 id="value属性"><a href="#value属性" class="headerlink" title="value属性"></a>value属性</h3><p>对于<code>value</code>属性，表示的是这个方法的一个总结性的描述，在官网的文档中，建议的是我们在描述的时候，尽可能的总结，将字数控制在<code>120</code>个字符以为就行。</p><h3 id="notes属性"><a href="#notes属性" class="headerlink" title="notes属性"></a>notes属性</h3><p>对于<code>note</code>属性，标识的是对于一个方法的具体性的描述。</p><h3 id="tags属性"><a href="#tags属性" class="headerlink" title="tags属性"></a>tags属性</h3><p>这个操作和之前的<code>@API</code>的<code>tags</code>属性特别的像，都是给类、请求进行分组、打标签使用的。但是在这里有一点是需要注意的，就是如果同时设置了<code>@API</code>的<code>tags</code>属性和<code>@ApiOperation</code>的<code>tags</code>属性，那么此时会通过<code>@API</code>的<code>tags</code>属性将<code>Controller</code>进行分类，而通过<code>@ApiOperation</code>的<code>tags</code>属性，<code>Controller</code>中的请求进行分类。</p><h3 id="response属性"><a href="#response属性" class="headerlink" title="response属性"></a>response属性</h3><p>这个属性设置的是当前请求的返回值类型。例如，我们返回的如果是一个<code>String</code>的话，那么在这里写的就是  <code>String.class</code>。</p><h3 id="responseContainer属性"><a href="#responseContainer属性" class="headerlink" title="responseContainer属性"></a>responseContainer属性</h3><p>在这里，说明的是包装相应的容器。默认情况下，有效值为 <code>List</code>、<code>Set</code>、<code>Map</code>，任何其它值都将被忽略。</p><h3 id="responseReference属性"><a href="#responseReference属性" class="headerlink" title="responseReference属性"></a>responseReference属性</h3><p>这里设置的是一个相应类型的引用。这个引用可以是本地的，也可以是远程的。如果设置了这个值，将会覆盖<code>response</code>属性的值。</p><h3 id="httpMethod属性"><a href="#httpMethod属性" class="headerlink" title="httpMethod属性"></a>httpMethod属性</h3><p>请求方式，例如<code>GET</code>、<code>HEAD</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>OPTIONS</code>。</p><h3 id="position属性"><a href="#position属性" class="headerlink" title="position属性"></a>position属性</h3><p>这个属性在<code>Swagger1.5X</code>版本中已经不再推荐使用了。因此标记了<code>@Deprecated</code>注解。如果配置了多个请求方法，想改变显示的顺序位置</p><h3 id="nickname属性"><a href="#nickname属性" class="headerlink" title="nickname属性"></a>nickname属性</h3><p>这个字段对应的是<code>operationId</code>字段。第三方工具使用<code>operationId</code>来唯一表示此操作.在<code>Swagger2.0</code>之后的版本中，这个字段是不在强制的，如果没有，则系统默认为空。</p><h3 id="produces属性"><a href="#produces属性" class="headerlink" title="produces属性"></a>produces属性</h3><p>指定返回的内容类型，仅当<code>request</code>请求头中的(<code>Accept</code>)类型中包含该指定类型才返回，例如:<code>application/json</code>。</p><h3 id="consumes属性"><a href="#consumes属性" class="headerlink" title="consumes属性"></a>consumes属性</h3><p>指定处理请求的提交内容类型(<code>Content-Type</code>)，例如<code>application/json</code>。</p><h3 id="protocols属性"><a href="#protocols属性" class="headerlink" title="protocols属性"></a>protocols属性</h3><p>标识的是当前的请求支持的协议，例如：<code>http</code>、<code>https</code>、<code>ws</code>、<code>wss</code>。</p><h3 id="authorizations属性"><a href="#authorizations属性" class="headerlink" title="authorizations属性"></a>authorizations属性</h3><p>高级特性认证时配置。</p><h3 id="hidden属性"><a href="#hidden属性" class="headerlink" title="hidden属性"></a>hidden属性</h3><p>配置为<code>true</code>将在文档中隐藏。隐藏整个<code>Controller</code>资源。作用与<code>@ApiIgnore</code>类似，但是没有<code>@ApiIgnore</code>功能强大。</p><h3 id="responseHeaders属性"><a href="#responseHeaders属性" class="headerlink" title="responseHeaders属性"></a>responseHeaders属性</h3><p>指定<code>response</code>中<code>header</code>的信息列表</p><h3 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h3><p><code>http</code>返回状态码</p><h3 id="extensions属性"><a href="#extensions属性" class="headerlink" title="extensions属性"></a>extensions属性</h3><p>可选的扩展数组,举例：<code>extensions = @Extension(properties =&#123;@ExtensionProperty(name = &quot;author&quot;, value = &quot;test@xx.com&quot;)&#125;)</code>。</p><h3 id="ignoreJsonView属性"><a href="#ignoreJsonView属性" class="headerlink" title="ignoreJsonView属性"></a>ignoreJsonView属性</h3><p>忽略<code>JsonView</code>注解，主要的目的是为了做到向下兼容</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们讲解了关于<code>@ApiOperation</code>注解的用法。在下面的文章中，我们会总结其他的注解。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger文档API学习--API注解</title>
      <link href="//Swagger/SwaggerDocumentLearnDay01/"/>
      <url>//Swagger/SwaggerDocumentLearnDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="Swagger–文档API学习–API"><a href="#Swagger–文档API学习–API" class="headerlink" title="Swagger–文档API学习–API"></a>Swagger–文档API学习–API</h1><p>在日常的开发当中，我们经常需要维护我们自己工程的一份接口文档。接口文档准备的好，起到了事半功倍的作用，接口文档准备的不好，往往起到事倍功半的作用。因此，对于后台服务来说，有一份好的接口文档，就显得尤为重要。</p><p>在我经理的工作中，用来组织接口文档的方式有很多。有采用<code>showDoc</code>方式的，也有采用<code>cwiki</code>方式的。在这里，我们讲解另外的一种方式–<code>Swagger</code>方式。</p><p><code>Swagger</code>的官方文档地址是:<a href="https://github.com/swagger-api/swagger-core/wiki/Annotations-1.5.X#quick-annotation-overview" title="Swagger官方文档">Swagger官方文档</a></p><p><code>Swagger</code>的API文档地址是:<a href="http://docs.swagger.io/swagger-core/v1.5.X/apidocs/index.html?io/swagger/annotations/Api.html" title="Swagger API">Swagger API</a></p><p>对于<code>Swagger</code>的解释，网上的说法有很多，总结的说：</p><blockquote><blockquote><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。</p></blockquote></blockquote><h2 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h2><p>&1;在讲解这个注解<code>@API</code>之前，我们首先看一下这个接口的源码</p><pre><code class="java">package io.swagger.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface Api &#123;    String value() default &quot;&quot;;    String[] tags() default &#123;&quot;&quot;&#125;;    /** @deprecated */    @Deprecated    String description() default &quot;&quot;;    /** @deprecated */    @Deprecated    String basePath() default &quot;&quot;;    /** @deprecated */    @Deprecated    int position() default 0;    String produces() default &quot;&quot;;    String consumes() default &quot;&quot;;    String protocols() default &quot;&quot;;    Authorization[] authorizations() default &#123;@Authorization(&quot;&quot;)&#125;;    boolean hidden() default false;&#125;</code></pre><p>通过上面的源码<code>@Target(&#123;ElementType.TYPE&#125;)</code>，我们可以发现，这个注解是作用在类上面的。因此，这个注解<code>@API</code>是类的注解，可以给控制器添加描述和标签信息，同时，我们将这个注解添加在控制器上，代表这个类是<code>Swagger</code>的资源，受<code>Swagger</code>的管理与解析。</p><h3 id="API–value属性"><a href="#API–value属性" class="headerlink" title="API–value属性"></a>API–value属性</h3><p>请注意，这个属性在<code>Swagger2.0</code>之后的版本中，没有什么实际的意义了。因为在<code>Swagger2.0</code>之后的版本中，<code>Swagger</code>官网推荐的是使用<code>tags</code>属性进行代替，并且，如果我们在<code>@API</code>中同时声明了<code>value</code>和<code>tags</code>，此时<code>value</code>的属性会被覆盖掉，同时，对于<code>tags</code>属性，我们可以设置多个标签。</p><h3 id="API–tags属性"><a href="#API–tags属性" class="headerlink" title="API–tags属性"></a>API–tags属性</h3><p>对于官网，给定的是<code>API</code>文档的的控制标签的列表。在实际的使用中，我们经常会将<code>Controller</code>进行分类，因此，我们可以采用<code>tags</code>标签将我们的请求分类。</p><h3 id="API–description属性"><a href="#API–description属性" class="headerlink" title="API–description属性"></a>API–description属性</h3><p>这个属性在<code>Swagger1.5X</code>版本中已经不再推荐使用了。因此标记了<code>@Deprecated</code>注解。对于这个属性，一般描述的是某个<code>Controller</code>的一个详细的具体信息。</p><h3 id="API–basePath属性"><a href="#API–basePath属性" class="headerlink" title="API–basePath属性"></a>API–basePath属性</h3><p>这个属性在<code>Swagger1.5X</code>版本中已经不再推荐使用了。因此标记了<code>@Deprecated</code>注解。标识的是请求的基本路径。</p><h3 id="API–position属性"><a href="#API–position属性" class="headerlink" title="API–position属性"></a>API–position属性</h3><p>这个属性在<code>Swagger1.5X</code>版本中已经不再推荐使用了。因此标记了<code>@Deprecated</code>注解。如果配置多个Api想改变显示的顺序位置</p><h3 id="API–produces属性"><a href="#API–produces属性" class="headerlink" title="API–produces属性"></a>API–produces属性</h3><p>指定返回的内容类型，仅当<code>request</code>请求头中的(<code>Accept</code>)类型中包含该指定类型才返回，例如:<code>application/json</code>。</p><h3 id="API–consumes属性"><a href="#API–consumes属性" class="headerlink" title="API–consumes属性"></a>API–consumes属性</h3><p>指定处理请求的提交内容类型(<code>Content-Type</code>)，例如<code>application/json</code>。</p><h3 id="API–protocols属性"><a href="#API–protocols属性" class="headerlink" title="API–protocols属性"></a>API–protocols属性</h3><p>标识的是当前的请求支持的协议，例如：<code>http</code>、<code>https</code>、<code>ws</code>、<code>wss</code>。</p><h3 id="API–authorizations属性"><a href="#API–authorizations属性" class="headerlink" title="API–authorizations属性"></a>API–authorizations属性</h3><p>高级特性认证时配置。</p><h3 id="API–hidden属性"><a href="#API–hidden属性" class="headerlink" title="API–hidden属性"></a>API–hidden属性</h3><p>配置为<code>true</code>将在文档中隐藏。隐藏整个<code>Controller</code>资源。作用与<code>@ApiIgnore</code>类似，但是没有<code>@ApiIgnore</code>功能强大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>@API</code>注解是<code>@Swagger</code>文档注解中比较比较重要的一个。在下面的时间中，我会总结其他的<code>Swagger</code>的注解，在所有的注解讲解完之后，会有一个通用的例子，来辅助理解这些注解的内容。</p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式–责任链模式</title>
      <link href="//DesignPattern/ResponsibilityChainPattern01/"/>
      <url>//DesignPattern/ResponsibilityChainPattern01/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式–责任链模式"><a href="#设计模式–责任链模式" class="headerlink" title="设计模式–责任链模式"></a>设计模式–责任链模式</h1><p>在工作当中，或多或少都会有一些报销上面的问题，经常情况下，我们的报销流程是“经理–&gt;总经理–&gt;总监”这样的一个流程。如果采用<code>Java</code>代码的话，不考虑任何的设计模式的话，此时我们的代码会很长，并且在<code>Java</code>代码中，我们会采用很多的<code>if-else</code>的方式，或者是<code>switch</code>的方式，但是这样的代码，扩展性不高，每次有新的审批流的时候，都需要改动原来的代码，此时非常的不便于程序的维护。因此，面对这样的场景，我们可以采用设计模式中的“责任链”模式进行开发，便于程序的后续维护和扩展。</p><p>并且在<code>Spring</code>中，也大量的采用了责任链的模式，例如它的<code>Filter</code>和<code>Interceptor</code>。在这样的情况下，为了后续研究<code>Spring</code>源码的方便，我们也需要研究一下什么是“责任链模式”。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求。从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><h2 id="使用设计模式之前"><a href="#使用设计模式之前" class="headerlink" title="使用设计模式之前"></a>使用设计模式之前</h2><p>使用设计模式之前，我们也可以使用<code>Java</code>代码达到上面的要求。</p><p>举例：例如，公司有规定，对于每次报销，如果是低于500元的，直接经理就可以报销，如果是超过500元，小于1000元的，需要总经理进行报销，对于超过1000元的，需要总监才可以报销。因此，对于这样的规则，我们可以采用下面的代码进行判断：</p><p>此时审批类代码如下：</p><pre><code class="java">public class AuditService &#123;    public void handle(double money) &#123;        if (money &lt;= 0) &#123;            System.out.println(&quot;金额异常，无须报销，结束流程&quot;);            return;        &#125;        if (money &lt; 500.0D) &#123;            System.out.println(&quot;经理审批通过，报销金额为：&quot; + money);        &#125; else if (money &lt; 1000.0D) &#123;            System.out.println(&quot;总经理审批通过，报销金额为：&quot; + money);        &#125; else &#123;            System.out.println(&quot;总监审批通过，报销金额为：&quot; + money);        &#125;    &#125;&#125;</code></pre><p>此时客户端的代码如下：</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        AuditService auditService = new AuditService();        double money1 = 100.0D;        auditService.handle(money1);        double money2 = 600.0D;        auditService.handle(money2);        double money3 = 2000.0D;        auditService.handle(money3);    &#125;&#125;</code></pre><p>此时程序的运行结果如下：</p><pre><code>经理审批通过，报销金额为：100.0总经理审批通过，报销金额为：600.0总监审批通过，报销金额为：2000.0</code></pre><p>咋一看，这样的代码没有什么问题，依然可以满足业务上的需要，同时也没有任何的BUG问题。但是这样的代码的可扩展性特别的差，因为如果以后规则的改变，我们需要去修改上面的<code>handle</code>方法，违反了设计模式的<code>开放-封闭</code>的原则，同时，因为修改原有的代码，导致程序的测试覆盖率也会上升。并且面临着每修改一次，之前的业务功能也要覆盖一次的问题。那么有没有好的方法，能够实现上面的业务逻辑呢？答案是有的。</p><h2 id="使用设计模式之后"><a href="#使用设计模式之后" class="headerlink" title="使用设计模式之后"></a>使用设计模式之后</h2><p>还是上面的业务需求，此时我们采用<code>责任链模式</code>进行开发，你就会发现，在满足业务需求的同时，我们可以让我们的代码更加的简洁、易懂、优雅。</p><p>首先，我们观察上面的<code>AuditService</code>方法，在这个方法中，其实承担了<code>经理</code>、<code>总经理</code>、<code>总监</code>的职责，其实这样是严重的违反了设计模式中的<code>单一原则</code>的。因此，我们完全可以抽象出三个类，来代表<code>经理</code>、<code>总经理</code>、<code>总监</code>。同时，我们会发现，在这三个类中，都有了对于金额的处理，如果不在自己处理的范围内，将请求扔给下一个人，如果自己有处理请求的能力，则直接中断请求链，返回即可。<br>因此，我们首先可以抽象出来一个接口，这个接口中有两个抽象的方法，一个是处理当前的请求，一个是指定下一个处理人是谁即可。</p><p>此时接口代码如下：</p><pre><code class="java">public interface Manager &#123;    void handle(double money);    void superior(Manager manager);&#125;</code></pre><p>此时经理实现类如下：</p><pre><code class="java">public class ProjectManager implements  Manager &#123;    private Manager superiorManager;    @Override    public void handle(double money) &#123;        if(money &lt; 500.0D)&#123;            System.out.println(&quot;经理审批通过，报销金额为：&quot; + money);            return;        &#125;        if(this.superiorManager != null)&#123;            this.superiorManager.handle(money);        &#125;    &#125;    @Override    public void superior(Manager manager) &#123;        if(null != manager)&#123;            this.superiorManager = manager;        &#125;    &#125;&#125;</code></pre><p>此时总经理实现类如下：</p><pre><code class="java">public class TotalManager implements Manager &#123;    private Manager superiorManager;    @Override    public void handle(double money) &#123;        if(money &lt; 1000.0D)&#123;            System.out.println(&quot;总经理审批通过，报销金额为：&quot; + money);            return;        &#125;        if(this.superiorManager != null)&#123;            this.superiorManager.handle(money);        &#125;    &#125;    @Override    public void superior(Manager manager) &#123;        if(null != manager)&#123;            this.superiorManager = manager;        &#125;    &#125;&#125;</code></pre><p>此时总监实现类如下：</p><pre><code class="java">public class GeneralManager implements Manager &#123;    private Manager superiorManager;    @Override    public void handle(double money) &#123;        if(money &gt;= 1000.0D)&#123;            System.out.println(&quot;经理审批通过，报销金额为：&quot; + money);            return;        &#125;        if(this.superiorManager != null)&#123;            this.superiorManager.handle(money);        &#125;    &#125;    @Override    public void superior(Manager manager) &#123;        if(null != manager)&#123;            this.superiorManager = manager;        &#125;    &#125;&#125;</code></pre><p>此时客户端类如下：</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;       Manager projectManager  = new ProjectManager();       Manager totalManager = new TotalManager();       Manager generalManager = new GeneralManager();       projectManager.superior(totalManager);       totalManager.superior(generalManager);       projectManager.handle(100.0D);       projectManager.handle(600.0D);       projectManager.handle(2000.0D);    &#125;&#125;</code></pre><p>运行结果如下：</p><pre><code>经理审批通过，报销金额为：100.0总经理审批通过，报销金额为：600.0经理审批通过，报销金额为：2000.0</code></pre><p>此时我们发现，当我们要新增一个审批节点的时候，其实，我们只需要新建一个类，实现<code>Manager</code>接口，然后，修改一下客户端<code>Client</code>的调用方法即可。此时，实现了程序良好的扩展性。</p><h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><p>在上面的代码中，我们发现，其实在<code>经理</code>、<code>总经理</code>、<code>总监</code>的实体类中，存在了大量的重复代码，因此，我们可以在接口与实体类之间，添加一层实现类，从而实现代码复用的效果。</p><p>抽象虚类–<code>CommonManager</code></p><pre><code class="java">public abstract class CommonManager implements Manager &#123;    private Manager superiorManager;    public abstract boolean canHandle(double money);    @Override    public void handle(double money) &#123;        if(canHandle(money))&#123;            return;        &#125;        if(this.superiorManager != null)&#123;            this.superiorManager.handle(money);        &#125;    &#125;    @Override    public void superior(Manager manager)&#123;        if(null != manager)&#123;            this.superiorManager = manager;        &#125;    &#125;&#125;</code></pre><p>接下来修改三个实体类：</p><p>经理类</p><pre><code class="java">public class ProjectManager  extends CommonManager &#123;    @Override    public boolean canHandle(double money) &#123;        if(money &lt; 500.0D)&#123;            System.out.println(&quot;经理审批通过，报销金额为：&quot; + money);            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>总经理类</p><pre><code class="java">public class TotalManager extends CommonManager &#123;    @Override    public boolean canHandle(double money) &#123;        if(money &lt; 1000.0D)&#123;            System.out.println(&quot;总经理审批通过，报销金额为：&quot; + money);            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>总监类</p><pre><code class="java">public class GeneralManager extends CommonManager &#123;    @Override    public boolean canHandle(double money) &#123;        if(money &gt;= 1000.0D)&#123;            System.out.println(&quot;经理审批通过，报销金额为：&quot; + money);            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>客户端的代码不变，测试运行结果如下：</p><pre><code>经理审批通过，报销金额为：100.0总经理审批通过，报销金额为：600.0经理审批通过，报销金额为：2000.0</code></pre><p>此时，我们发现，通过抽象出了<code>CommonManager</code>虚类，可以让我们的实体类更加的通俗易懂，可以让整个处理流程，更加的清晰明朗。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在日常的开发当中，我们经常会用到<code>责任链</code>模式，因此对于学习<code>责任链</code>模式显得就尤为的重要。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--观察者模式</title>
      <link href="//DesignPattern/ObserverPattern01/"/>
      <url>//DesignPattern/ObserverPattern01/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式–观察者模式"><a href="#设计模式–观察者模式" class="headerlink" title="设计模式–观察者模式"></a>设计模式–观察者模式</h1><p>在设计模式中，有一类模式是我们经常提到的，或者在观看源代码的时候，也经常能够遇到的。那就是–<code>观察者模式</code>。观察者模式是一种常用的设计模式。</p><h2 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h2><p>既然观察者模式是常用设计模式中的一种，那么什么是观察者模式呢？在这里，我们举个栗子：</p><p>观察者模式其实十分的简单。说白了就是<code>发布-订阅</code>的模式，如果你不知道什么是<code>发布-订阅</code>的模式化，那么我们可以采取<code>通知-收到</code>的模式进行讲解。</p><p>例如，有一天，警察收到通知，说在XX店铺经常发生盗窃的行为，警察为了抓住小偷，会经常穿着便衣到店铺进行潜伏。某一天，当小偷进来后，开始逛商场而没有发现发现警察的存在。当小偷开始进行盗窃后，此时警察关注了小偷偷窃的行为，会立即上前逮捕小偷。在这里，就是一个典型的<code>观察者</code>模式。当小偷开始偷东西后，此时警察因为关注着小偷，发现小偷的举动，来进行逮捕。在这里，我们可以理解为：小偷偷东西这个动作，可以是通知警察可以逮捕的一个行为、命令，当警察接收到这个命令后，此时会对小偷进行逮捕。接下来，我们将这段偷盗，逮捕的行为，写成一段代码：</p><h2 id="普通的偷盗、逮捕代码"><a href="#普通的偷盗、逮捕代码" class="headerlink" title="普通的偷盗、逮捕代码"></a>普通的偷盗、逮捕代码</h2><p>小偷的代码：</p><pre><code class="java">public class Thief &#123;    private Police police1 = new Police();    private Police police2 = new Police();    private String name=&quot;thief&quot;;    public Thief()&#123;    &#125;    public  Thief(String name)&#123;        this.name=name;    &#125;    /**     * 偷东西后被警察发现     */    public void nodifyPolice()&#123;        police1.arrestThief(this);        police2.arrestThief(this);    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p>警察的代码：</p><pre><code class="java">public class Police &#123;    /**     * 逮捕小偷     * @return     */    public void arrestThief(Thief thief)&#123;        System.out.println(thief.getName() + &quot; 双手举起，你被逮捕了&quot;);    &#125;    @Override    public int hashCode() &#123;        return super.hashCode();    &#125;    @Override    public boolean equals(Object obj) &#123;        return super.equals(obj);    &#125;&#125;</code></pre><p>客户端类：</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        Thief thief = new Thief(&quot;偷心贼&quot;);        thief.nodifyPolice();    &#125;&#125;</code></pre><p>程序运行截图：</p><p><img src="https://shengouqiang.cn/img/DesignPattern/ObserverPattern01/01.jpg" alt="程序运行结果"></p><h2 id="优化一：提炼出警察个数问题"><a href="#优化一：提炼出警察个数问题" class="headerlink" title="优化一：提炼出警察个数问题"></a>优化一：提炼出警察个数问题</h2><p>ok，到此，我们发现我们的代码目前处于仅仅只能跑通的成分。但是对于我们程序员而言，我们追求的是代码的完善和代码的通读性。我们发现，上面的代码中，对于小偷而言，他并不知道当他要被逮捕的时候，到底有多少个警察？难道以后每次增加一个警察就要改动这个类，新增一个对象吗？这明显不符合设计模式中的<code>开放-封闭原则</code>这么做显然是有问题的：因此，我们需要对我们的代码进行改动。</p><p>小偷的代码：</p><pre><code class="java">public class Thief &#123;    private List&lt;Police&gt;  policeList;    private String name=&quot;thief&quot;;    public Thief()&#123;        policeList = new ArrayList&lt;&gt;();    &#125;    public  Thief(String name)&#123;        this();        this.name=name;    &#125;    /**     * 增加警察     * @param police     */    public void addPolice(Police police)&#123;        if(null == police)&#123;            return;        &#125;        policeList.add(police);    &#125;    /**     * 删除警察     * @param police     */    public void delPolice(Police police)&#123;        policeList.remove(police);    &#125;    /**     * 偷东西后被警察发现     */    public void nodifyPolice()&#123;        policeList.forEach(police -&gt; police.arrestThief(this));    &#125;    public String getName() &#123;        return name;    &#125;&#125;</code></pre><p>客户端的代码：</p><pre><code class="java">public class Client &#123;    public static void main(String[] args) &#123;        Thief thief = new Thief(&quot;偷心贼&quot;);       thief.addPolice(new Police());       thief.addPolice(new Police());       thief.addPolice(new Police());       thief.addPolice(new Police());       thief.addPolice(new Police());       thief.nodifyPolice();    &#125;&#125;</code></pre><p>程序运行截图：</p><p><img src="https://shengouqiang.cn/img/DesignPattern/ObserverPattern01/02.jpg" alt="程序运行结果"></p><p>至此，我们已经实现了将警察的个数与小偷逮捕的过程进行了解构。在小偷逮捕的过程中，我们可以随意的修改警察的个数，而不是修改<code>Thief</code>的代码了</p><h2 id="优化二：只有警察追捕小偷吗？还是警察只抓捕小偷"><a href="#优化二：只有警察追捕小偷吗？还是警察只抓捕小偷" class="headerlink" title="优化二：只有警察追捕小偷吗？还是警察只抓捕小偷"></a>优化二：只有警察追捕小偷吗？还是警察只抓捕小偷</h2><p>通过上面的问题，我们知道了，在上面的代码中，我们知道了警察可以追捕小偷，但是如果此时街道命令的是刑警，而不是普通警察呢？如果此时追捕的不是小偷，而是抢劫银行的大盗呢？我们总不能再去写一份十分相似的代码吧？在这里，我们用到了设计模式中的另一个原则<code>依赖倒转原则</code>。因此，我们需要做的是将小偷的偷窃和警察的抓捕都封装成对应的接口，如果以后来了刑警或者是大盗，我们只需要实现这个接口就行了。</p><p>在这里，我们把小偷、大盗提取出来一个接口：</p><pre><code class="java">public interface TheftAndRobberyInterface &#123;    /**     * 添加通知者     * @param arrestInterface     */    void addNotifyPerson(ArrestInterface arrestInterface);    /**     * 减少通知者     * @param arrestInterface     */    void delNotifyPerson(ArrestInterface arrestInterface);    /**     * 盗窃过程     */    void theftAndRobbery();    /**     * 获取名字     * @return     */    String getName();&#125;</code></pre><p>在这里，我们把警察、刑警提取出来一个接口：</p><pre><code class="java">public interface ArrestInterface &#123;    /**     * 抓捕接口     * @param t     */    void arrest(TheftAndRobberyInterface t);&#125;</code></pre><p>此时我们重写警察和小偷的实现类：</p><p>小偷实现类：</p><pre><code class="java">public class ThiefOne implements TheftAndRobberyInterface &#123;    private String thiefName;    private List&lt;ArrestInterface&gt; arrestInterfaceList ;    public ThiefOne(String name)&#123;        this.thiefName=name;        this.arrestInterfaceList = new ArrayList&lt;&gt;();    &#125;    @Override    public void addNotifyPerson(ArrestInterface arrestInterface) &#123;        if(null  == arrestInterface)&#123;            return;        &#125;        this.arrestInterfaceList.add(arrestInterface);    &#125;    @Override    public void delNotifyPerson(ArrestInterface arrestInterface) &#123;        this.arrestInterfaceList.remove(arrestInterface);    &#125;    @Override    public void theftAndRobbery() &#123;        this.arrestInterfaceList.forEach(arrestInterface -&gt; arrestInterface.arrest(this));    &#125;    @Override    public String getName() &#123;        return this.thiefName;    &#125;&#125;</code></pre><p>警察实现类：</p><pre><code class="java">public class PoliceOne implements ArrestInterface &#123;    @Override    public void arrest(TheftAndRobberyInterface t) &#123;        System.out.println(t.getName() + &quot; 双手举起，你被逮捕了&quot;);    &#125;&#125;</code></pre><p>客户端实现类：</p><pre><code class="java"> @Test    public  void testThree()&#123;        TheftAndRobberyInterface t = new ThiefOne(&quot;偷心贼&quot;);        t.addNotifyPerson(new PoliceOne());        t.addNotifyPerson(new PoliceOne());        t.addNotifyPerson(new PoliceOne());        t.addNotifyPerson(new PoliceOne());        t.addNotifyPerson(new PoliceOne());        t.theftAndRobbery();    &#125;</code></pre><p>程序运行截图：</p><p><img src="https://shengouqiang.cn/img/DesignPattern/ObserverPattern01/03.jpg" alt="程序运行结果"></p><p>至此，我们发现，无论是小偷，还是警察，他们在内部依赖的都是借口。而不是具体的实现类。当我们有刑警追捕大盗的时候，我们仅仅只是需要新写两个具体的类，分别实现<code>TheftAndRobberyInterface</code>和<code>ArrestInterface</code>接口即可。无须改动其他的内容。同时，客户让我们的代码更加的灵活，例如：如果警察有事，需要刑警代替警察追捕小偷呢？我们只需要改动，客户端的代码即可。这样在满足了<code>开放-封闭原则</code>的同时，我们也满足了<code>依赖倒转原则</code>。</p><h2 id="观察者模式适合的场景"><a href="#观察者模式适合的场景" class="headerlink" title="观察者模式适合的场景"></a>观察者模式适合的场景</h2><h3 id="观察者模式定义"><a href="#观察者模式定义" class="headerlink" title="观察者模式定义"></a>观察者模式定义</h3><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化是，会通知所有观察者对象，使他们能够自动更新自己。</p><h3 id="观察者模式的特定"><a href="#观察者模式的特定" class="headerlink" title="观察者模式的特定"></a>观察者模式的特定</h3><p>一般情况下，我们想要将一个系统分割成一系列相互协作的类有个很不好的副作用。那就是对象间的一致性问题。我们不希望通过将类分解，导致我们的代码过度的耦合，而是希望他们能够通过<code>发布-订阅</code>的方式，让代码进行解耦。从事达到当一个对象更新的时候，只需要发出通知，这样其他的对象可以自动更新，保持一致性。在这样的情况下，我们可以采用观察者模式。</p><p>总的来说，观察者模式就是为了实现程序间的解耦进行操作的。让程序彼此之间依赖于抽象，而不是依赖于具体。同样的，当我们并不知道有多少观察者的时候，其实是用观察者最好的方式。</p><h3 id="观察者模式的不足"><a href="#观察者模式的不足" class="headerlink" title="观察者模式的不足"></a>观察者模式的不足</h3><p>通过上面的代码，我们发现，在观察者模式中，我们需要将观察者共同实现一个接口，然后每次通知观察者，都是调用这个接口。其实，这样是降低了程序的可读性的。因为对于小偷而言，他可能仅仅是指偷偷摸摸，而对于江洋大盗而言，他们可能抢劫银行等。如果用用一个名字作为方法的名称，不便于代码后续的维护。那么有没有什么好的方法呢？其实，这里是有的。只不过要在后续中进行讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown插入视频</title>
      <link href="//Other/MarkDownInsertVideo/"/>
      <url>//Other/MarkDownInsertVideo/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown插入视频"><a href="#MarkDown插入视频" class="headerlink" title="MarkDown插入视频"></a>MarkDown插入视频</h1><p>在这里，我们采用html5的方式，插入视频</p><video id="video" controls="controls" controlslist="nodownload"  width="640" height="480" preload="none" poster="https://shengouqiang.cn/img/video/poster.png">      <source id="mp4" src="https://shengouqiang.cn/video/1122.mp4" type="video/mp4"></video><p>该视频来源于抖音，如有疑问，请与我联系。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频 </tag>
            
            <tag> Markdown用法 </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每天一个Linux命令--ls</title>
      <link href="//Linux/Linux-order-day-01/"/>
      <url>//Linux/Linux-order-day-01/</url>
      
        <content type="html"><![CDATA[<h1 id="每天一个Linux命令–ls"><a href="#每天一个Linux命令–ls" class="headerlink" title="每天一个Linux命令–ls"></a>每天一个Linux命令–ls</h1><p>在这里，我们不介绍一些花里胡哨的命令，介绍的是我们经常使用的命令。如果里面的命令不在我们的日常的使用当中，可以给我留言，我会第一时间补充进去的。</p><h2 id="ls的语法格式"><a href="#ls的语法格式" class="headerlink" title="ls的语法格式"></a>ls的语法格式</h2><pre><code class="shell">ls [OPTION]... [FILE]...</code></pre><h2 id="ls基本命令介绍"><a href="#ls基本命令介绍" class="headerlink" title="ls基本命令介绍"></a>ls基本命令介绍</h2><p>在我们执行ls命令的过程中，我们通常是采用<code>ls</code>，然后直接敲击回车，此时代表的是罗列出当前目录下的文件、文件夹等内容，其实，我们可以指定目录，让<code>ls</code>仅仅只是展示我们想要目录的内容，而不一定是当前目录的内容。假如，我们现在再<code>&quot;/shen/A&quot;</code>目录下，如果我们想要看<code>&quot;/shen/B&quot;</code>目录下，此时我们可以直接使用<code>ls /shen/B</code>进行查看<code>&quot;/shen/B&quot;</code>目录下的内容，也可以先用<code>cd</code>命令，切换到<code>&quot;/shen/B&quot;</code>目录下，然后执行<code>ls</code>命令即可。</p><p>同样的，如果一个文件夹下有很多的文件，此时我们想要查找其中的某一个文件在当前文件夹中是否存在，此时我们可以采用<code>ls 文件名</code>的方式进行查看，如果返回的是有值，则代表当前文件夹中含有这个文件，如果<code>ls</code>返回的是<code>No such file or directory</code>，则代表这个目录中，没有你想要的文件。</p><h2 id="ls参数介绍"><a href="#ls参数介绍" class="headerlink" title="ls参数介绍"></a>ls参数介绍</h2><h3 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h3><p><code>-a</code>命令是Linux最基本的命令之一，他的主要作用是展示命令目录下，所有的文件。注意，这里所有的文件指的是</p><ol><li>当前目录，以<code>.</code>表示</li><li>上一层目录，以<code>..</code>表示</li><li>当前目录下的文件、文件夹、链接等</li><li>当前目录下隐藏的文件、文件夹、链接等</li></ol><p>举例：</p><pre><code class="shell">ls -a</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-a-down.jpg" alt="ls -a 命令"></p><p>此时，我们可以发现，在当前目录中，我们已经把上面包含的内容全部显示的出来。</p><h3 id="A"><a href="#A" class="headerlink" title="-A"></a>-A</h3><p>这个参数和<code>-a</code>的区别是不显示当前目录<code>.</code>和上一层目录<code>..</code>。</p><p>举例：</p><pre><code class="shell">ls -A</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-a-up.jpg" alt="ls -A 命令"></p><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p>首先<code>-l</code>命令是以列表的形式打印出来的，一个文件占用一行。另外，除了能够查看文件的名称之外，还可以查看其它的内容。这个命令我们会着重的介绍一下的。因为真的很关键。差不过通过这个命令，我们可以查看到这个文件的大部分基本属性了。</p><p>举例：</p><pre><code class="shell">ls -l</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-l-down.jpg" alt="ls -l 命令"></p><p>好，从这里开始，我们介绍下：</p><p>我们可以看见，对于每个文件而言，它都存在着9列，并且列与列之间采用<b><span style="color:red;">空格</span></b>的形式进行分割的。那么接下来，我们要讲解下每一个列的含义</p><h4 id="第一列-drwxrwxr-x"><a href="#第一列-drwxrwxr-x" class="headerlink" title="第一列(drwxrwxr-x)"></a>第一列(<span style="color:red;">drwxrwxr-x</span>)</h4><p>其中，我们以<span style="color:red;">drwxrwxr-x</span>举例，我们发现，这个值是以<code>d</code>开头的。那么这个<code>d</code>是什么含义呢？其实，这个<code>d</code>指的是目录文件的含义。另外，我们把开头的这一个字母叫做——<code>文件类型</code>。除了<code>d</code>,还有其他字符：</p><ol><li><code>-</code>  普通文件</li><li><code>d</code>  目录文件</li><li><code>p</code>  管理文件</li><li><code>l</code>  链接文件</li><li><code>b</code>  块设备文件</li><li><code>c</code>  字符设备文件</li><li><code>s</code>  套接字文件</li></ol><p>OK,接下来我们看第2~4个字符，是<code>rwx</code>。其实这个指的是文件的一个权限。其中：</p><ol><li><code>r</code>  读权限</li><li><code>w</code>  写权限</li><li><code>x</code>  可执行权限</li><li><code>-</code>  无权限</li></ol><p>而我们发现，在这个值中，除了第一个字符，其他的值可以每三个值分成一组。分别问：<code>rwx</code>、<code>rwx</code>、<code>r-x</code>。那么为什么Linux要分成三个这样的值呢？是因为在Linux中大致的可以把用户分成三类：</p><ol><li>自己</li><li>自己所在的组内的其他成员(<span style="color:red;">此时不包括自己</span>)</li><li>其他组的成员(<span style="color:red;">此时不包括自己所在的组</span>)</li></ol><p>那么这个值的第2~4位指的就是自己所拥有的权限，我们可以看到，我们的权限是<code>rwx</code>，那么此时我们对于这个文件存在可读、可写、可执行的权限。</p><p>而这个值的第5~7位指的是组内其他成员所拥有的权限，我们可以看到，此时的权限是<code>rwx</code>，那么我们组内的其他人对于这个文件，也同样存在着可读、可写、可执行的权限。</p><p>而这个值的第8~10位指的是其他组所拥有的权限，此时我们发现，现在的权限是<code>r-x</code>。也就是说，其他组的人对于这个文件只有读取和执行的权限，没有写入的权限。</p><h4 id="第二列-2"><a href="#第二列-2" class="headerlink" title="第二列(2)"></a>第二列(<span style="color:red;">2</span>)</h4><p>这一列比较特殊，我们发现，这一列仅仅只是一个数字<code>2</code>，没有其他任何的解释。其实，其实，这一列的话，主要是要分为文件夹和文件来进行讲解。在讲解之前，我们先来了解下Linux系统中<a href="/blog/Linux/Linux-order-day-02/">链接概念</a>。</p><p>通过上面的文章，我们已经很清楚了。</p><ol><li>如果当前表示的是一个文件的话，那么此时，这个值标识的是文件的硬链接数。</li><li>如果表示的是一个目录的话，那么此时表示的是当前目录中子文件夹的个数。<ul><li>这个仅仅只是统计的是子文件夹的个数，不包括文件的个数</li><li>默认情况下是2，因为就算你一个子文件夹都没有，那么他还是会默认存在两个子文件夹的。当前目录<code>.</code>和上一层目录<code>..</code></li></ul></li></ol><h4 id="第三列-shen"><a href="#第三列-shen" class="headerlink" title="第三列(shen)"></a>第三列(<span style="color:red;">shen</span>)</h4><p>这一列很简单，标识的文件的拥有者，也就是这个文件是哪个账户创建的。</p><h4 id="第四列-shen"><a href="#第四列-shen" class="headerlink" title="第四列(shen)"></a>第四列(<span style="color:red;">shen</span>)</h4><p>这一列很简单，标识的文件的拥有者所在的组的名字。</p><h4 id="第五列-4096"><a href="#第五列-4096" class="headerlink" title="第五列(4096)"></a>第五列(<span style="color:red;">4096</span>)</h4><p>在这里，也是要进行区分的。如果是一个文件，标识的是文件的大小。而如果是一个文件夹的话，表示的是文件夹的大小。注意，而不是文件夹以及它下面的文件的总大小。之所以这样，是因为在Linux中，其实把文件夹当做了一个特殊的文件而已。</p><h4 id="第六、七、八列-May-24-19-37"><a href="#第六、七、八列-May-24-19-37" class="headerlink" title="第六、七、八列(May 24 19:37 )"></a>第六、七、八列(<span style="color:red;">May 24 19:37 </span>)</h4><p>这里表示的是文件夹或者是文件的最后的修改时间。</p><p>这里要注意一下，如果当前指的是文件，那么很好说，就是修改文件的时间。</p><p>如果这里指的是文件夹，那么如果我们单纯的修改文件夹下已有文件的内容的时候，Linux是不会更新文件夹的最后修改时间的。只有当我们在文件夹添加/删除-文件夹/文件的时候，此时Linux才会去更新文件夹的最后更新时间。</p><h4 id="第九列-bin"><a href="#第九列-bin" class="headerlink" title="第九列(bin)"></a>第九列(<span style="color:red;">bin</span>)</h4><p>这里表示的是文件或文件夹的名字。</p><h4 id="特殊行-total-32"><a href="#特殊行-total-32" class="headerlink" title="特殊行(total 32)"></a>特殊行(<span style="color:red;">total 32</span>)</h4><p>我们会发现，当我们执行命令的时候，在命令结果的第一行，有个<code>total 32</code>这个内容。那么这个内容到底是什么呢？</p><p>其实，这个内容是当前这个文件夹中所占用的文件块的总大小。</p><p>首先，我们通过命令<code>getconf PAGESIZE</code>可以查看到我的系统中，一块的大小是4096。因此，我们认为a.txt占用了3块，而后面的每个文件夹，占用了1块。因此一共占用了9块。而每块的大小是4K。因此一共占用了36K。也就是上面展示的36。</p><p>另外，如果在当前目录中我们存在<code>软链接(符号链接)</code>。那么，是不计入到计算当中的。因为符号连接的<code>st_size</code>表示的是符号链接所指地址的长度。</p><h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><p>显示文件和目录的inode编号</p><p>举例：</p><pre><code class="shell">ls -i</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-i-down.jpg" alt="ls -i 命令"></p><h3 id="m"><a href="#m" class="headerlink" title="-m"></a>-m</h3><p>用”,”号区隔每个文件和目录的名称</p><p>举例：</p><pre><code class="shell">ls -m</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-m-down.jpg" alt="ls -m 命令"></p><h3 id="h"><a href="#h" class="headerlink" title="-h"></a>-h</h3><p>显示文件大小(人类可读的显示方法),在这里，我们通常配合<code>-l</code>命令一起显示。</p><p>举例：</p><pre><code class="shell">ls -lh</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-lh-down.jpg" alt="ls -lh 命令"></p><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p>此时进行逆向排序，这个命令一般与<code>-h</code>、<code>-t</code>、<code>-S</code>配合使用。</p><h3 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h3><p>按照时间进行排序,在这里，我们通常配合<code>-l</code>命令一起显示。</p><p>举例：</p><pre><code class="shell">ls -lt</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-lt-down.jpg" alt="ls -lt 命令"></p><p>此时默认是进行了时间的倒叙排列，如果我们想要按照时间的正序排列，可以使用上面的<code>-r</code>命令。</p><p>举例：</p><pre><code class="shell">ls -ltr</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-ltr-down.jpg" alt="ls -ltr 命令"></p><h3 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h3><p>按照文件的大小进行排序,在这里，我们通常配合<code>-l</code>命令一起显示。</p><p>举例：</p><pre><code class="shell">ls -lS</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-lS-up.jpg" alt="ls -lS 命令"></p><p>此时默认是进行了文件大小的倒叙排列，如果我们想要按照文件大小的正序排列，可以使用上面的<code>-r</code>命令。</p><p>举例：</p><pre><code class="shell">ls -lSr</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-lSr-up.jpg" alt="ls -lSr 命令"></p><h3 id="–color"><a href="#–color" class="headerlink" title="–color"></a>–color</h3><p>以指定颜色显示</p><p>举例：</p><pre><code class="shell">ls --color=&quot;red&quot;</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls--color.jpg" alt="ls --color 命令"></p><p>此时常用的参数有：</p><ol><li>always</li><li>yes</li><li>force</li><li>no</li><li>never</li><li>none</li><li>auto</li><li>tty</li><li>if-tty</li></ol><h3 id="u"><a href="#u" class="headerlink" title="-u"></a>-u</h3><p>以文件上次被访问的时间排序</p><p>举例：</p><pre><code class="shell">ls -lu</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-lu-down.jpg" alt="ls -lu 命令"></p><h3 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h3><p>与<code>-l</code>命令一致，只不过不展示组信息</p><p>举例：</p><pre><code class="shell">ls -o</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-o-down.jpg" alt="ls -o 命令"></p><h3 id="R"><a href="#R" class="headerlink" title="-R"></a>-R</h3><p>以递归的方式列出所有的目录和所有目录下的所有的文件</p><p>举例：</p><pre><code class="shell">ls -lR</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-lR-up.jpg" alt="ls -lR 命令"></p><h3 id="Q"><a href="#Q" class="headerlink" title="-Q"></a>-Q</h3><p>把输出的文件名用双引号括起来</p><p>举例：</p><pre><code class="shell">ls -Q</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-Q-up.jpg" alt="ls -Q 命令"></p><h3 id="pf"><a href="#pf" class="headerlink" title="-pf"></a>-pf</h3><p>每个文件后附上一个字符说明该文件的类型。</p><ol><li>“*”代表可执行的普通文件</li><li>“/”表示目录</li><li>“@”表示符号链接</li><li>“|”表示FIFO</li><li>“=”表示套接字</li></ol><p>举例：</p><pre><code class="shell">ls -pF</code></pre><p>此时的执行结果如下：</p><p><img src="https://shengouqiang.cn/img/Linux/Command/Day01/ls-pF-up.jpg" alt="ls -pF 命令"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天一个Linux命令 </tag>
            
            <tag> 命令 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql学习--基本命令学习</title>
      <link href="//mysql/MYSQL-LEARN-DAY-01/"/>
      <url>//mysql/MYSQL-LEARN-DAY-01/</url>
      
        <content type="html"><![CDATA[<p>#MySql学习–基本命令学习</p><pre><code class="sql">-- 查看自动提交设置SHOW VARIABLES LIKE &#39;AUTOCOMMIT&#39;;-- 开启自动提交SET AUTOCOMMIT =1;-- 关闭自动提交SET AUTOCOMMIT =0;-- 查看当前会话隔离级别select @@tx_isolation;-- 查看系统当前隔离级别select @@global.tx_isolation;-- 设置当前会话隔离级别-- READ UNCOMMITTED  未提交读-- READ COMMITTED    不可重复读-- REPEATABLE READ   可重复读-- SERIALIZABLE      串行化SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;-- 设置系统当前隔离级别set global transaction isolation level repeatable read;-- 查看相关表的信息SHOW TABLE STATUS  like &#39;test_table&#39;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
          <category> 命令语句 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql学习 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同一电脑配置多个Git账号</title>
      <link href="//Git/gitOneMoreAccount/"/>
      <url>//Git/gitOneMoreAccount/</url>
      
        <content type="html"><![CDATA[<h1 id="同一个电脑配置多个GIt账号"><a href="#同一个电脑配置多个GIt账号" class="headerlink" title="同一个电脑配置多个GIt账号"></a>同一个电脑配置多个GIt账号</h1><p>在我们日常开发的过程中，我们经常需要在我们的电脑中配置多个<code>Git</code>账户的<code>SSH-KEY</code>信息,但是在默认的情况下，我们通常会给我们的电脑配置一个全局的<code>SSH-KEY</code>信息，因此，在这里，我们讲解下如何配置过个<code>SSH-KEY</code>信息。</p><h2 id="1-清除全局配置信息"><a href="#1-清除全局配置信息" class="headerlink" title="1.清除全局配置信息"></a>1.清除全局配置信息</h2><p>因为在我们的电脑中以后会存在多个<code>Git</code>账户，因此我们需要将我们全局的<code>Git</code>的邮箱与用户名进行取消掉，取消命令如下：</p><pre><code class="shell">git config --global --unset user.namegit config --global --unset user.email</code></pre><p>如果你没有配置，那么是不需要删除的。如果执行完命令后，想查看是否成功，可以使用命令：</p><pre><code class="shell">git config --list</code></pre><h2 id="2-配置公私钥"><a href="#2-配置公私钥" class="headerlink" title="2.配置公私钥"></a>2.配置公私钥</h2><p>首先我们进入到我们终端，在终端的默认目录下，进入到隐藏文件夹<code>.ssh</code>文件夹中，此时假设分别有<code>github</code>和<code>gitee</code>的账号，测试我们可以进行如下配置：</p><h3 id="2-1先配置github"><a href="#2-1先配置github" class="headerlink" title="2.1先配置github"></a>2.1先配置github</h3><p>此时我们执行如下命令：</p><pre><code class="shell">ssh-keygen -t rsa -C &quot;github邮箱账号&quot;</code></pre><p>此时我们看见出现了如下的提示：</p><p><img src="https://shengouqiang.cn/img/gitOneMoreAccount/saveTheGitHubKey.jpg" alt="填写公私钥的位置信息"></p><p>此时在这里我们写入:<code>id_rsa_github</code>，写完之后，我们输入回车，此时会出现是否要对公私钥添加密码信息，此时我们选择不需要，然后直接一路回车到最后就可以了。</p><h3 id="2-2再配置gitee"><a href="#2-2再配置gitee" class="headerlink" title="2.2再配置gitee"></a>2.2再配置gitee</h3><p>此时我们执行如下命令：</p><pre><code class="shell">ssh-keygen -t rsa -C &quot;gitee邮箱账号&quot;</code></pre><p>此时我们看见出现了如下的提示：</p><p><img src="https://shengouqiang.cn/img/gitOneMoreAccount/saveTheGiteeKey.jpg" alt="填写公私钥的位置信息"></p><p>此时在这里我们写入:<code>id_rsa_gitee</code>，写完之后，我们输入回车，此时会出现是否要对公私钥添加密码信息，此时我们选择不需要，然后直接一路回车到最后就可以了。</p><h2 id="3-添加config配置文件"><a href="#3-添加config配置文件" class="headerlink" title="3.添加config配置文件"></a>3.添加config配置文件</h2><p>在<code>.ssh</code>文件夹中，我们首先创建一个文件</p><pre><code class="shell">touch config</code></pre><p>此时，我们打开文件，写入如下配置：</p><pre><code>Host githubHostname github.comUser gitIdentityFile ~/.ssh/id_rsa_githubHost gitee.comHostname gitee.comUser gitIdentityFile ~/.ssh/id_rsa_gitee</code></pre><p>在这里，我们说下配置中每一项的内容：</p><ol><li><code>Host</code>：名字可以取为自己喜欢的名字，不过这个会影响<code>git</code>相关命令,例如：如果我们的<code>Host</code>改成<code>myOwn</code>的话，此时执行<code>git clone</code> 的话,会变成 <code>git clone git@myOwn:XXXXXX</code>。</li><li><code>Hostname</code>：这个是真实的域名地址</li><li><code>User</code>：配置使用用户名,这里默认是<code>git</code>,不需要进行改动。</li><li><code>IdentityFile</code>：默认为公钥文件的绝对路径地址信息。</li></ol><h2 id="4-添加公钥到对应的平台上"><a href="#4-添加公钥到对应的平台上" class="headerlink" title="4.添加公钥到对应的平台上"></a>4.添加公钥到对应的平台上</h2><p>此时，我们以<code>gitee</code>为例：</p><ol><li>首先登陆<code>gitee.com</code></li><li>输入用户名、密码</li><li>进入我的码云，然后点击头像，进行设置</li></ol><p><img src="https://shengouqiang.cn/img/gitOneMoreAccount/findTheSettings.jpg" alt="填写公私钥的位置信息"></p><ol start="4"><li>在这里，我们首先找到在第二步生成的<code>id_rsa_gitee.pub</code>文件，将文件的内容复制到下面中：</li></ol><p><img src="https://shengouqiang.cn/img/gitOneMoreAccount/addTheSshKey.jpg" alt="填写公私钥的位置信息"></p><h2 id="5-进行测试"><a href="#5-进行测试" class="headerlink" title="5.进行测试"></a>5.进行测试</h2><p>在这里，我们测试可以使用<code>ssh</code>的一个命令：</p><pre><code class="shell">ssh -T gitee.com</code></pre><p>如果此时程序出现的是：</p><p><img src="https://shengouqiang.cn/img/gitOneMoreAccount/showSuccessResult.jpg" alt="填写公私钥的位置信息"></p><p>那么此时恭喜你，你已经配置成功了。如果出现了</p><p><img src="https://shengouqiang.cn/img/gitOneMoreAccount/showErrorResult.jpg" alt="填写公私钥的位置信息"></p><p>那么你可以执行如下命令，查看问题的具体原因：</p><pre><code>ssh -T -v gitee.com</code></pre><h2 id="6-初始化文件"><a href="#6-初始化文件" class="headerlink" title="6.初始化文件"></a>6.初始化文件</h2><p>因为我们在第一步取消了<code>email</code>和<code>name</code>的全局配置，因此我们在执行<code>git clone</code>和<code>git init</code>的时候，可以执行如下的两条命令，来初始化配置一些信息</p><pre><code class="shell">git config user.name &quot;yourname&quot;git config user.email &quot;youremail&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图学习--类图</title>
      <link href="//UML/UML-02/"/>
      <url>//UML/UML-02/</url>
      
        <content type="html"><![CDATA[<h1 id="UML类图学习–类图"><a href="#UML类图学习–类图" class="headerlink" title="UML类图学习–类图"></a>UML类图学习–类图</h1><h2 id="类图包含了什么"><a href="#类图包含了什么" class="headerlink" title="类图包含了什么"></a>类图包含了什么</h2><h3 id="属性元素"><a href="#属性元素" class="headerlink" title="属性元素"></a>属性元素</h3><p>在日常的开发和文档编写中，我们用到的最多的就是类图。在这里，我们讲解下类图的使用方法。</p><p>对于类图而言，我们包含了一个重要的元素，这个元素就是类。当然，在实际中，我们把接口也当作一种特殊的类。因此实际上，类图所包含的属性元素有：</p><ol><li>接口</li><li>真正的类</li></ol><p>而这个“真正的类”中，我们包含了</p><ol><li>实体类</li><li>控制类</li><li>边界内</li></ol><p>下面我们一一进行讲解</p><h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>实体类对应系统需求中的每个实体，它们通常需要保存在永久存储体中，一般使用数据库表或文件来记录，实体类既包括存储和传递数据的类，还包括操作数据的类。实体类来源于需求说明中的名词，例如学生、商品等。</p><h4 id="控制类"><a href="#控制类" class="headerlink" title="控制类"></a>控制类</h4><p>控制类用于体现应用程序的执行逻辑，提供相应的业务操作，将控制类抽象出来可以降低界面和数据库之间的耦合度。控制类一般是由动宾结构的短语（动词+名词）转化来的名词，如增加商品对应有一个商品增加类，注册对应有一个用户注册类等。</p><h4 id="边界类"><a href="#边界类" class="headerlink" title="边界类"></a>边界类</h4><p>边界类用于对外部用户与系统之间的交互对象进行抽象，主要包括界面类，如对话框、窗口、菜单等。</p><h3 id="模型元素"><a href="#模型元素" class="headerlink" title="模型元素"></a>模型元素</h3><ol><li>依赖关系</li><li>泛化关系</li><li>关联关系</li><li>聚合关系</li><li>组合关系</li><li>实现关系</li></ol><h2 id="类图模型元素讲解"><a href="#类图模型元素讲解" class="headerlink" title="类图模型元素讲解"></a>类图模型元素讲解</h2><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>对于接口而言，我们在上文已经说明了，在UML中我们把接口当作一中特殊的类。下面我们先来一个图片，看一下，在UML中接口是长什么样子的，在这里，我们以ProcessOn为例进行描述，与网上的图片可能有差异。</p><p><img src="https://shengouqiang.cn/img/UML/10/interface.png" alt="UML类图之接口描述"></p><p>其实，在这里，我们用这一个图就可以说明：</p><ol><li>首先，在最上面我们定了一个接口的名字，叫做”EatInterface”。</li><li>在这个接口中，我们定义了三个方法，而这三个方法含有描述符。<ul><li><font color=red>+</font>  代表该方法是public</li><li><font color=red>-</font>  代表该方法是private</li><li><font color=red>#</font>  代表该方法是protected</li></ul></li><li>如果当前方法存在参数，则需要将参数列出来</li><li>方法与返回值之间用”:”进行分割，”:”后面的是方法的返回值</li></ol><h3 id="真正的类"><a href="#真正的类" class="headerlink" title="真正的类"></a>真正的类</h3><p>对于实体类而言，在processOn方法中，与接口的展示是一致的。只不过在实体类中，可以存在成员变量。</p><p><img src="https://shengouqiang.cn/img/UML/10/class.png" alt="UML类图之实类描述"></p><p>在这里，我们对于方法不在进行过多的阐述，因为与之前的接口中的说明一致，在这里，我们发现在”Student”类，存在成员变量”name”、”id”。改描述与方法一致。在这里，不再阐述。</p><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>依赖关系真的是多个类之间的依存关系。比如：植物类依赖土壤、水源、空气等。同时，依赖关系可以继续细分，分成5个小类：</p><ol><li>绑定依赖</li><li>实现依赖</li><li>使用依赖</li><li>抽象依赖</li><li>授权依赖</li></ol><p>依赖关系是用<font color=red>虚线箭头</font>来表示的，箭头指向的方向，就是当前类所需要依赖的实体。<br>下面我们举例说明：</p><p><img src="https://shengouqiang.cn/img/UML/10/dependency.png" alt="UML类图之依赖关系描述"></p><h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化关系这个名词头一次听的一定比较懵逼，不知道是什么高大上的意思。其实，泛化关系就是继承关系，是用<font color=red>空心三角形+实线</font>来表示的，箭头指向的方向，就是当前类所需要依赖的实体。</p><p>下面我们举例说明：</p><p><img src="https://shengouqiang.cn/img/UML/10/generalization.jpg" alt="UML类图之泛化关系描述"></p><h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系是一种相关影响的关系。例如，森林可以影响气候，而气候也可以影响森林。关联关系是用<font color=red>双向箭头+实线</font>来进行表示的。</p><p>下面我们举例说明：</p><p><img src="https://shengouqiang.cn/img/UML/10/composition.png" alt="UML类图之关联关系描述"></p><h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>聚合关系是类之间的一种较弱的耦合关系，如一个字符串数组和一个字符串就是一种聚合关系。在UML中，聚合关系用<font color=red>空心的菱形+实线箭头</font>来表示，箭头指向为被聚合的类。</p><p>下面我们举例说明：</p><p><img src="https://shengouqiang.cn/img/UML/10/association.png" alt="UML类图之聚合关系描述"></p><h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系是类之间一种整体与部分之间的关系，如一只青蛙有四条腿，青蛙类与青蛙腿类之间的关系就是组合关系。在UML中，组合关系用<font color=red>实心的菱形+实线箭头</font>来表示，箭头指向为被组合的类。</p><p>下面我们举例说明：</p><p><img src="https://shengouqiang.cn/img/UML/10/aggregation.png" alt="UML类图之组合关系描述"></p><h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>一般来讲实现关系是针对类与接口之间的关系而言的。在UML中，实现关系用<font color=red>空心三角形+虚线</font>来表示。</p><p>下面我们举例说明：</p><p><img src="https://shengouqiang.cn/img/UML/10/realization.png" alt="UML类图之实现关系描述"></p><h2 id="组合成一个整体"><a href="#组合成一个整体" class="headerlink" title="组合成一个整体"></a>组合成一个整体</h2><p><img src="https://shengouqiang.cn/img/UML/10/all.png" alt="UML类图之实现关系描述"></p>]]></content>
      
      
      <categories>
          
          <category> UML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML学习概述</title>
      <link href="//UML/UML-01/"/>
      <url>//UML/UML-01/</url>
      
        <content type="html"><![CDATA[<h1 id="UML学习概述"><a href="#UML学习概述" class="headerlink" title="UML学习概述"></a>UML学习概述</h1><p>在之前，一直都想要学习UML类图，但是因为工作与加班的原因，一直都没有来得及学习，其实是工作中根本用不到。最近在研究Spring的源码，在看源码的时候，直接被各种方法跳来跳去的给跳懵了。所以下定决心，想要学习下UML。</p><h2 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h2><p>UML作为一种国际规范建模语言，他的建模分为9种图：</p><ol><li>类图<ul><li>Class Diagram</li><li>描述系统所包含的类、类内部结构及类之间的关系</li></ul></li><li>对象图<ul><li>Object Diagram</li><li>是类图的一个具体实例</li></ul></li><li>组件图<ul><li>Object Diagram</li><li>描述代码部件的物理结构以及各部件之间的依赖关系</li></ul></li><li>部署图<ul><li>Deployment Diagram</li><li>定义系统中软、硬件的物理体系结构</li></ul></li><li>用例图<ul><li>Usecase Diagram</li><li>从用户的角度出发描述系统的功能、需求，展示系统外部的各类角色与系统内部的* 各种用例之间的关系</li></ul></li><li>时序图<ul><li>Sequence Diagram</li><li>表示对象之间动态合作的关系</li></ul></li><li>协作图<ul><li>Collaboration Diagram</li><li>描述对象之间的协作关系</li></ul></li><li>状态图<ul><li>Statechart Diagram</li><li>描述一类对象的所有可能的状态及事件发生时状态的转移条件</li></ul></li><li>活动图<ul><li>Activity Diagram</li><li>描述系统中各种活动的执行顺序</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> UML学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 工具学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于Lamdba的引入</title>
      <link href="//Java8Action/IntroduceLamdba/"/>
      <url>//Java8Action/IntroduceLamdba/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章如有不足之处，敬请指出 。欢迎多多交流。本人看到，会第一时间回复信息的。</p><h1 id="Lamdba表达式的引入"><a href="#Lamdba表达式的引入" class="headerlink" title="Lamdba表达式的引入"></a>Lamdba表达式的引入</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>在日常的开发过程中，我们能够唯一确定的就是对于需求总是在不停的变化的。而对于一个好的开发人员而言，我们所能做的，就是尽可能的让我们的代码适应尽可能的需求变化，对于每次需求的改动，尽可能的在减少开发量的同事，保持程序的稳定性和健壮性，以及对于未来的可扩展性性是我们追求的目标。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在这篇文章中，我们并不会讲解<code>lamdba</code>表达式的具体用法和高级特性，而是讲解下为什么我们需要使用<code>lamdba</code>表达式，和用了<code>lamdba</code>表达式对于我们的好处是什么。</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p>下面我们举个栗子，例如我们给一个果农做一个产品筛选系统，目前，这个果农仅仅只是售卖苹果这一种产品，而对于苹果而言，果农需要对于苹果进行进行不同的区分，苹果的颜色分为绿色、红色等，将所有的红颜色的苹果都筛选出来。</p><h2 id="解决一"><a href="#解决一" class="headerlink" title="解决一"></a>解决一</h2><p>基于以上的例子，只要是会<code>Java</code>开发的人而言，我们可以迅速的进行代码开发，然后交给果农进行验证：<br>首先我们创建一个<code>Apple</code>的类</p><pre><code class="java">public class Apple&#123;    private final String color;    private final  Double weight;    private Apple(AppleBuilder appleBuilder)&#123;        this.color = appleBuilder.getColor();        this.weight = appleBuilder.getWeight();    &#125;    public String getColor() &#123;        return color;    &#125;    public Double getWeight() &#123;        return weight;    &#125;    @Override    public String toString() &#123;        return &quot;Apple&#123;&quot; +                &quot;color=&#39;&quot; + color + &#39;\&#39;&#39; +                &quot;, weight=&quot; + weight +                &#39;&#125;&#39;;    &#125;    static class AppleBuilder&#123;        private String color;        private Double weight;        public AppleBuilder color(String color)&#123;            this.color = color;            return this;        &#125;        public AppleBuilder weight(Double weight)&#123;            this.weight = weight;            return this;        &#125;        public String getColor() &#123;            return color;        &#125;        public void setColor(String color) &#123;            this.color = color;        &#125;        public Double getWeight() &#123;            return weight;        &#125;        public void setWeight(Double weight) &#123;            this.weight = weight;        &#125;        public Apple build()&#123;            return new Apple(this);        &#125;    &#125;&#125;</code></pre><p>然后如下解决问题：</p><pre><code class="java">import org.junit.Before;import org.junit.Test;import java.util.Arrays;import java.util.List;public class TestOne &#123;    public static final String APPLE_COLOR_RED_CODE=&quot;red&quot;;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList=Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(checkApple(apple))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;    private boolean checkApple(Apple apple)&#123;        if(APPLE_COLOR_RED_CODE.equals(apple.getColor()))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><h2 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h2><p>很好，到目前为止，你已经完成了将系统中所有的红苹果都筛选出来的需求了。当你兴高采烈的将功能提供给果农用的时候，果农突然改变了注意，他不再想要红颜色的苹果了，而是想要绿颜色的苹果。</p><h2 id="解决二"><a href="#解决二" class="headerlink" title="解决二"></a>解决二</h2><p>此时，你也许会觉得那我直接在代码中定义一个绿色的常量，然后将判断改成判断绿色不就可以了吗？<br>然后你迅速的将代码改成了如下的方式：</p><pre><code class="java">import org.junit.Before;import org.junit.Test;import java.util.Arrays;import java.util.List;public class TestOne &#123;    public static final String APPLE_COLOR_RED_CODE=&quot;red&quot;;    public static final String APPLE_COLOR_GREEN_CODE=&quot;green&quot;;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList=Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(checkApple(apple))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;    private boolean checkApple(Apple apple)&#123;        if(APPLE_COLOR_GREEN_CODE.equals(apple.getColor()))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>当你写完这样的代码，你们的技术经理肯定会有这样的疑问？那如果果农突然又想要筛选红色的苹果呢？你难道再改回来吗？<br>带着这样的疑问，你开始了代码的第一版优化：</p><pre><code class="java">public class TestOne &#123;    public static final String APPLE_COLOR_RED_CODE=&quot;red&quot;;    public static final String APPLE_COLOR_GREEN_CODE=&quot;green&quot;;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList=Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(checkAppleRed(apple))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;    private boolean checkAppleRed(Apple apple)&#123;        if(APPLE_COLOR_RED_CODE.equals(apple.getColor()))&#123;            return true;        &#125;        return false;    &#125;    private boolean checkAppleGreen(Apple apple)&#123;        if(APPLE_COLOR_GREEN_CODE.equals(apple.getColor()))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>此情此景，你觉得你可以满足用户的需求，当用户想要从查询红色苹果到绿色苹果，我们只需要替换一下调用的方法而已：可是，这真的最好的方法吗？我们写代码的根本目的在于让程序更加的通用，能够更加满足需求的变化，那如果以后摘选粉色的、白色的苹果呢？难道还需要添加一个新的方法吗？这样只能会让你的方法、你的代码越来越不受控制。拿到我们就没有更好的办法来解决这个问题了吗？<br>此时，你可能回想，我可以把颜色这个作为一个参数传递进去，从而达到优化代码的作用：<br>代码的第二版优化：</p><pre><code class="java">public class TestOne &#123;    public static final String APPLE_COLOR_RED_CODE=&quot;red&quot;;    public static final String APPLE_COLOR_GREEN_CODE=&quot;green&quot;;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList= Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(checkApple(apple,APPLE_COLOR_RED_CODE))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;    private boolean checkApple(Apple apple,String appleColor)&#123;        if(appleColor.equals(apple.getColor()))&#123;            return true;        &#125;        return false;    &#125;</code></pre><p>ok，此时你认为终于找到了这个问题的通用方法。终于找到了最优解。no,you are wrong.此时果农又有了新的需求，他需要查找出红色的苹果，并且重量大于150g的苹果。显然，你目前的代码是肯定不支持的。如果你想要将重量也传进去，那无疑会对现在已有的代码起到了冲击(需要对于已经调用的地方都添加重量参数)，并且也会让你的方法的参数也来越多。这显然不是一个很好的解决办法。<br>因此，在这里，我们借鉴下设计模式中的”策略者模式”进行对代码第三版优化：<br>我们通过上面的分析可以发现，真正变化的，其实是<code>private boolean checkApple(Apple apple)</code>这个方法，第一版优化，也仅仅只是在对于这个函数实现了不同的扩展而已。那么我们可以将这个方法抽象成一个接口<code>算法族</code>，等到以后我们采用不同的筛选条件的时候，也只需要去实现这个接口，实现当前这个接口的方法而已<code>策略</code>。<br>首先，我们定义一个接口：</p><pre><code class="java">public interface AppleCheckInterface &#123;    public static final String APPLE_COLOR_RED_CODE=&quot;red&quot;;    public static final String APPLE_COLOR_GREEN_CODE=&quot;green&quot;;    boolean checkApple(Apple apple);&#125;</code></pre><p>在这个接口中，我们将对于苹果的筛选抽取出一个接口，然后我们对于红苹果、绿苹果的筛选，试下两个不同的实现类：<br>第一个是筛选红苹果：</p><pre><code class="java">public class CheckRedApple implements AppleCheckInterface &#123;    @Override    public boolean checkApple(Apple apple) &#123;       if(APPLE_COLOR_RED_CODE.equalsIgnoreCase(apple.getColor()))&#123;           return true;       &#125;       return false;    &#125;&#125;</code></pre><p>第二个是筛选绿苹果：</p><pre><code class="java">public class CheckGreenApple implements  AppleCheckInterface &#123;    @Override    public boolean checkApple(Apple apple) &#123;        if(APPLE_COLOR_GREEN_CODE.equalsIgnoreCase(apple.getColor()))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>此时我们的筛选调用代码改为：</p><pre><code class="java">public class TestOne &#123;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList= Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(checkApple(apple,new CheckRedApple()))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;    private boolean checkApple(Apple apple, AppleCheckInterface appleCheckInterface)&#123;        if(appleCheckInterface.checkApple(apple))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>此时，我们发现这种方式比之前的方式优美了很多，等到以后我来了一个新的筛选条件的时候，我也仅仅只是需要实现一个<code>AppleCheckInterface</code>接口，然后在调用的时候，传入适合的对象即可。同时，和上面不同的是，我们无需改动其他的类。减少了回归测试的成本。但是这种方式还是有一个问题，那就是每次实现一个筛选条件，就需要创建一个新的<code>AppleCheckInterface</code>接口的实现类。等待筛选条件特别多的时候，会出现实现类也超级多，不方便管理的情况。对于这种情况，我们可以采用JDK提供的另外一种方法-匿名内部类来实现，下面是第四版代码优化：</p><pre><code class="java">public class TestOne &#123;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList= Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(checkApple(apple, new AppleCheckInterface() &#123;                @Override                public boolean checkApple(Apple apple) &#123;                    if(APPLE_COLOR_RED_CODE.equals(apple.getColor()))&#123;                        return true;                    &#125;                    return false;                &#125;            &#125;))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;    private boolean checkApple(Apple apple, AppleCheckInterface appleCheckInterface)&#123;        if(appleCheckInterface.checkApple(apple))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>在这里，我们采用匿名内部类的方式，来替代了我们<code>AppleCheckInterface</code>接口的实现类，但是匿名内部类有个致命的缺陷，就是十分不利于代码的阅读。当前是因为程序的简单，可能你还能读得懂这个匿名内部类的意思，一旦这个接口是一个超级复杂的接口，直接回导致你崩溃掉。那就没有更好的方式来实现了吗？<br>在上面我们分析到，其实真正有用的代码就是你的那个判断而已，其他都是为了让这句话的语法通顺和符合JDK的标准而写的样板代码而已。那么我们可不可以有这样的一个函数，将这个判断像是参数一样传递进去，然后直接返回我们想要的结果呢？<br>不用担心，在<code>JDK1.8</code>中已经支持了你的这个想法，那就是<code>“行为参数化”</code>。<br>下面我们直接使用<code>JDK1.8</code>中的<code>Stream</code>流和<code>lamdba</code>来实现这个需求，至于这两个功能，会在后面的文章中进行介绍，此处仅仅只是体验先JDK1.8的<code>Stream</code>流和<code>lamdba</code>表达式给我们带来的便捷：<br>首先，我们先定义一个接口：</p><pre><code class="java">public interface Predicate&lt;T&gt; &#123;    boolean test(T t);    static &lt;T&gt; boolean check(T t,Predicate&lt;T&gt; p)&#123;        if(p.test(t))&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre><p>然后看调用方法：</p><pre><code class="java">public class TestOne &#123;    public static final String APPLE_COLOR_RED_CODE=&quot;red&quot;;    public static final String APPLE_COLOR_GREEN_CODE=&quot;green&quot;;    private List&lt;Apple&gt; appleList;    @Before    public void prepare()&#123;        appleList= Arrays.asList(new Apple.AppleBuilder().color(&quot;red&quot;).weight(12.0).build(),new Apple.AppleBuilder().color(&quot;green&quot;).weight(9.8).build(),new Apple.AppleBuilder().color(&quot;red&quot;).weight(6.6).build());    &#125;    @Test    public void testOne()&#123;        for(Apple apple : appleList)&#123;            if(Predicate.check(apple,a -&gt; APPLE_COLOR_RED_CODE.equals(a.getColor())))&#123;                System.out.println(apple);            &#125;        &#125;    &#125;&#125;</code></pre><p>此时我们看到，原来啰嗦的第一版、第二版、第三版、第四版代码直接由现在的一行代码搞定。这个就是<code>JDK1.8</code>中<code>Stream</code>流和<code>lamdba</code>表达式给我们带来的便捷与优越。<br>在这里，不用去考虑程序的效率问题，后期会有一片单独的文章来讲解<code>lamdba</code>的性能问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Java8学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lamdba </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
