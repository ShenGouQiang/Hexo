---
title: Java-BIO NIO AIO
permalink: Java/JDK/IO/JavaBioNioAio
date: 2020-06-10 23:32:35
categories:
- Java
- JDK
tags:
- Java学习
- JDK学习
- IO模型
---

# Java 的 BIO NIO AIO

在讲解什么是IO之前，我们先来聊一下 同步、异步、阻塞、非阻塞 这四个概念，因为这四个概念贯穿我们始终，因此在真正的了解什么是IO之前，我们先讲明白这四个概念。

## 同步 异步

同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。而异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。我们可以用打电话和发短信来很好的比喻同步与异步操作。

## 阻塞 非阻塞

阻塞与非阻塞主要是从 CPU 的消耗上来说的，阻塞就是 CPU 停下来等待一个慢的操作完成 CPU 才接着完成其它的事。非阻塞就是在这个慢的操作在执行时 CPU 去干其它别的事，等这个慢的操作完成时，CPU 再接着完成后续的操作。虽然表面上看非阻塞的方式可以明显的提高 CPU 的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的 CPU 使用时间能不能补偿系统的切换成本需要好好评估。

剩下的就是他们之间的一个组合，接下来，我们通过一个例子，来进行通俗的解释。

假如有一天，你的老婆出差了，家里就剩下你和你的儿子，而你们要烧一壶水，通过不同的父子表现，我们来解析不同的组合。

| 组合方式   | 通俗解释                                                     |
| ---------- | ------------------------------------------------------------ |
| 同步阻塞   | 你让你儿子烧一壶水，在烧水的期间，你就一直在客厅等着水开，而你的儿子看着水壶，什么时候水烧开了，你儿子告诉你，你把热水倒入杯中，放在茶几上。 |
| 同步非阻塞 | 你让你儿子烧一壶水，在烧水的期间，你就一直在客厅等着谁开，而你的儿子在把水壶通电后，就去玩游戏去了，等什么时候水壶开，什么时候告诉你，你把热水倒入杯中，放在茶几上。 |
| 异步阻塞   | 你让你儿子烧一壶水，在烧毁的期间，你吃着零食，看着电视，而你的儿子看着水壶，什么时候水烧开了，你儿子把热水倒入杯中，放在茶几上，通知你，有热水喝了。 |
| 异步非阻塞 | 你让你儿子烧一壶水，在烧毁的期间，你吃着零食，看着电视，而你的儿子在把水壶通电后，就去玩游戏去了，等什么时候水壶开，你儿子把热水倒入杯中，放在茶几上，通知你，有热水喝了。 |

在以上的四种方式中，无疑，第四种方式是效率最高的一种方式，也是我们一直所追求的方式。

## 什么是IO

接下来，我们讲解下什么是IO。以及对于IO，咋Linux底层的一个大致的实现原理。

下面我们引用维基百科的一段关于IO的定义:

> **I/O**（英语：**I**nput/**O**utput），即**输入／输出**，通常指[数据](https://zh.wikipedia.org/wiki/数据)在[存储器](https://zh.wikipedia.org/wiki/存储器)（内部和外部）或其他周边设备之间的输入和输出，是信息处理系统（例如[计算机](https://zh.wikipedia.org/wiki/計算機)）与外部世界（可能是人类或另一信息处理系统）之间的通信。输入是系统接收的信号或数据，输出则是从其发送的信号或数据。该术语也可以用作行动的一部分；到“运行I/O”是运行输入或输出的操作。

对于Linux，而言，我们的IO大致上是同构下面的方式进行的：

![IO基本模型](/img/Java/IO/IO_Base_Module.jpg)

通过上图我们可知，对于Linux而言，无论是用于网络传输的Socket的IO，还是基于磁盘文件读取的IO操作。他们都是首先会将内容存放到内核(Kernel)的缓冲区中， 然后我们的系统进程再从内核(Kernel)中读取出来。但是用户态进程对于内核的调用的处理方式，和内核对于IO操作的处理方式，就组成了不同的IO类型，接下来，我们逐一进行讲解。

## BIO

BIO，也叫做同步阻塞IO。那么这个IO的模型是什么样子的呢？我们可以看下图：

![BIO 模型](/img/Java/IO/Linxu_BIO_01.jpg)

在Linux系统中，一切皆文件。对于不同的Socket、IO，在Linux系统中，都是采用文件描述符(fd,全程是file descriptor)来标识的。因此对于一个Socket而言，就是一个文件描述符。

而在早期的Socket通信通过中，Kernel提供的Socket方式是阻塞方式的。因此，对于这样的方式

1. 当每次需要一个新的Socket链接的时候，此时我们的服务需要新启动一个进程，然后调用Kernel的read 命令，指定相应的fd，如果此时有数据传输，则直接读取，如果没有数据传输，那么当前进程就处于阻塞的状态。
2. Kernel提供的read函数格式如下：`nt read(int fd,void *buf,size_t count)`。具体的请详见 `man 2 read`

对于上面的方案，采用的是 同步 + 阻塞 的方式来实现的。这样的实现方式：

1. 优点：
   - 简单
2. 缺点：
   - 效率低下，无法充分利用CPU的性能
   - 

# NIO 

但是上面这样的处理方式是有问题的。假如我们服务的并发量很高，此时我们又100个Socket，那么我们就要有对应的100个进程。并且，创建一个进程是很耗费系统资源的。基于以上问题,Kernel进行了改进，将可以将Socket改为非阻塞的方式。因此，我们的程序就可以有了下面的变化：

![NIO+轮询 模型](/img/Java/IO/Linxu_NIO_01.jpg)

在这样的方式下，我们不再需要100个进程，只需要一个进程，对这100个fd去进行轮询即可。这是因为此时我们的Socket是非阻塞的方式。

对于上面的方案，依然是同步的方式，只是
